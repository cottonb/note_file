# linux开发环境及应用

# 开始使用linux

## 终端，tty，控制台，命令行，shell

我们先来介绍终端，tty，控制台，命令行，shell这几个概念的区别

首先，计算机总要有一个人机交互的接口程序，这就是控制台，是计算机自带的

然后，以前的计算机很贵，而unix系统支持多用户，但怎么多用户呢？总不能一堆人交替使用一个计算机，每次都要切换用户吧，这样计算机的性能根本没有用上，所以我们需要一个设备，能作为一个人机交互的设备，给主机进行交互就行，这个设备最开始就是一个打字机，能把人打的字传给主机，主机发过来的信息打印出来

![image-20230224213105730](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230224213105730.png)

teletypewriter，简写为tty

后面就有了电子显示字符的机器

![image-20230224213232411](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230224213232411.png)

不用浪费纸了

到这里我们就发现，控制台，tty，或者字符终端，其实干的就是人机交互，是计算机的最后一段路，所以称之为终端，在这个时候，终端还是有形的，在现实中有实体设备对应

然后我们还提出了shell的概念

![image-20230224213608735](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230224213608735.png)

我们可以看到进行人机交互的程序，就像一层壳一样包住了里面的内核，通过api去和内核交互，连接了人与机器，所以这种人机交互的抽象我们就称为shell

再到后来，我们出现了gui，出现了显示屏，终端设备就慢慢消失了，只能在博物馆看到了。但我们还想用终端的功能怎么办？所以出现了终端模拟器，在gui中创建一个进程去连接主机的终端接口，然后模拟终端的运行。到现在，我们所提到的终端，其实都是终端模拟器

命令行其实就是windows下的自带的终端，而powershell是跨平台的终端，功能也更加强大

## 行律

终端只负责把用户在键盘输入的字符传给主机，再把主机的字符输出打印出来，其他什么都不会干，连字符的重定义都不会干，也就是说你按换行，你希望的是回车，换行，但终端只会向主机发一个\\n，那主机不就只会\\n了吗？太脑瘫了，所以我们在传给主机前，有一个规则，帮我们把一些字符输入的惯例转换一下，这个就是行律

![image-20230224220536533](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230224220536533.png)

在终端，你在键盘输入 “ctrl+字母” ，这个实际上是一个字符，ascii码就对应1~26，那这些字符又不能打印，有个鸡巴用？我们可以将这些字符在行律去作为一个控制信号，像是经典的 “ctrl+c”，这个ascii码就是3，传给行律后，行律自动把这个字符转化为终止这个终端在主机上的进程运行的信号。

又比如，行律可以把\\n转化为\\b\\n，这样就能正常的回车了。还有backspace删除键，发出的只是一个\\b，而行律会把\\b转化为'\\b'+' '+'\\b'，光标回退，空格擦除，再光标回退，这样就完成了删除的功能了

又比如我们的终端是不进行字符的缓冲的，也就是说，键盘按下发出的信号，终端只管发，根本没缓冲，那么就需要行律去缓冲这些字符，直到接收到了终端的\\n，才把这些字符传给进程。

我们可以通过stty命令去调整行律，stty -a 打印行律的所有控制信息

## Esc终端转移序列

我们可以通过Esc去转义字符，去改变字符串打印的颜色，还有下划线

![image-20230224230326799](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230224230326799.png)

```
\33[0m 关闭所有属性 
\33[1m 设置高亮度
\33[4m 下划线 
\33[5m 闪烁 
\33[7m 反显 
\33[8m 消隐 
\33[30m -- \33[37m 设置前景色（字体色）30:黑 31:红     32:绿 33:黄    34:蓝色 35:紫色 36:深绿 37:白色
\33[40m -- \33[47m 设置背景色                  40:黑 41:深红 42:绿 43:黄色 44:蓝色 45:紫色 46:深绿 47:白色
\33[nA 光标上移n行 
\33[nB 光标下移n行 
\33[nC 光标右移n行 
\33[nD 光标左移n行 
\33[y;xH设置光标位置 
\33[2J 清屏 
\33[K 清除从光标到行尾的内容 
\33[s 保存光标位置 
\33[u 恢复光标位置 
\33[?25l 隐藏光标 
\33[?25h 显示光标
```



## 终端和主机的流量控制

早期的终端显示速度太慢了，需要流量控制

可以用信号线控制，终端要爆了就给主机发个消息就好了

但信号线太贵了，多装也很傻逼，所以我们直接用软件的方式，利用流控字符Xon，Xoff，想让主机别发了，就发个Xoff，可以发了，就发个Xon，而这两个字符对应的就是Xoff-'ctrl+s'，Xon-'ctrl+q'，可以手动流控，所以在unix里，不像windows的保存ctrl+s，在unix ctrl+s就是暂停发送，所以到时候别以为死机了

## 登录

### root用户

管理员用户，拥有所有权限

### 申请账号

root用户使用useradd命令创建用户

### 登录过程

输入登录名后，密码输入由于是终端传输，很可能被人偷了，所以为了防偷，所以行律干脆不回显，所以看起来就没输入，其实是输入了的

## shell提示符

```
[mozhiyan@localhost ~]$
```

- mozhiyan是启动shell的用户名
- localhost就是主机名
- ~是主目录的简写
- $是普通用户的意思，如果是#，那就是root用户

## 关机

使用shutdown指令，这样会把一些缓冲区的数据写到硬盘中，这样文件就不会丢了。只有root用户能使用

## 第一周作业

第11题

```
echo HelloLinux | md5sum
```

![image-20230305200423334](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230305200423334.png)

结果

```
edda87e248f8d2f1f8f8e3b38b66e494  -
```

## 错题

![image-20230305200800600](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230305200800600.png)

# 第二周

date指令获取当前时间，由于计算机自己的计时很不准，一天能差几十秒，所以需要和一个服务器去校准。且就算你表快了，也不会往回拨，因为很多程序是依赖于时间的，这样会出很多问题的，所以是把时间变慢，每过两秒系统时间增加一秒

# 文本处理总结

## cat

```python
cat file1 file2 …… file #打印所有参数名的文件
cat -n file1 #打印文件的时候显示行号
cat #没有参数时会从stdin获取输入，输出到stdout，可以重定向到一个文件，从而可以实现文件的远程传输
```

## od

```python
od file #用八进制打印每个两个字节

#t表示type，下面是和t搭配的格式
#o表示八进制，d表示十进制，u表示无符号的十进制，x表示16进制，由于一个字节8位，最少打印一个字节，所以没有二进制的参数
#c表示字符，数字表示每几个字节作为打印单位

#-N 15 表示输出15个字节
#-w 13 表示每行显示的字节数，默认16字节

#组合起来就是
od -to2 file #格式为每两个字节八进制表示
od -tx2 file #格式为每两个字节十六进制表示
od -tx2c file #格式为每两个字节十六进制，然后再输出一行字符格式的
od -tx2c -N 15 -w 32 file #好像每行显示最少16个字节
```

另外，输出的数字是小端，所以在前面的字符显示在16进制的后两位，后面的字符显示在16进制的前两位

## head

```python
head -n 15 file1 file2 file3 #显示每个文件的头部的15行
head -n -20 file1 #去除尾部的20行后，显示剩余的部分
head -20 file1 #等价于-n 20
```

## tail

```python
tail -n 20 file1 file2 #显示每个文件的尾部20行
tail -20 file1 #等价于-n 20
tail -n +20 file1 #去除文件头部的20行后，显示剩余部分
tail +20 file #等价于 -n +20
tail -f file1 #实时打印文件尾部被追加的内容，像是一些日志文件，追加了就打印（-f forever)
```

## tee

```python
#将stdin的输入输出到stdout和指定文件里面
tee file1 #会把stdin作为输入，输入ctrl-d停止stdin输入
#可以通过管道，把其他文件的输出作为输入
cat file1 | tee file2 #这样就可以在屏幕输出，又可以输入到文件file2里，省的cat file2了
```

## wc

```python
#word count
wc file1 file2
#输出如下
1 1 5 file1
4 11 65 file2
5 12 70 total
#第一列表示行数，第二列表示单词数（被空格隔开的就是一个单词），第三列表示字符数，最后一行是总和
```

## sort

```python
sort file #以file为输入，按字符串大小，以每行为单位进行排序
sort #以stdin作为输入，主要是管道的用法
sort -n -r -k 2 #-n为把字符串当数字比大小，-r为逆序，由大到小，-k 2为以每行的第二个单词作为排序的key
```

## tr

```python
tr string1 string2
#把输入的文本中的string1替换为string2
```

## uniq

```sh
# 2023/6/15 期末重新解释
uniq file # 当前行和上一行不同，输出 ——重复的行合并成一行，使uniq
uniq -u file # 当前行与上下两行都不同，输出 ——只输出不重复的行，使-u，独一无二
uniq -d file # 当前行和上一行不同，与下一行相同，输出 ——只输出重复行，使-d，只留重复duplicate
uniq -c file # 执行和uniq一样的工作，只是在前面附带重复次数
```



```python
uniq
uniq file
#遍历输入的每一行，如果当前行和上一行相同，则删除当前行
uniq -c file #输出时，第一列附带本行重复次数，次数包括本身。准确的来说是遇到一个和上一行不同的就重新计数，直到遇到不同的行，输出本行和计数
uniq -u file #若本行紧跟了相同的行，则不输出，所以输出的是-u unique的行。uniq原本是去重，加上-u就只输出没有重复的行了
uniq -d file #若本行后面没有紧跟的行，则不输出。所以只保留有重复的行，但只打印一次
```

## 正则表达式

### 使用范围

vim， visual studio， word等文本编辑器

注意，正则表达式和文件名通配符的规则不同，且使用的场合不同

正则表达式是文本场合，文件名通配符是文件场合

### 元字符

```python
.
*
[
\
^
$
```

上面这六个字符是特殊字符，不表自身的字符的含义

#### \\（转义）

\\是转义字符，可以进行转义表达自身的含义

#### . （圆点）

匹配任意的单个字符

#### []（集合）

```python
[abcd] #匹配a或b或c或d的单个字符
[\*.] #括号里面的这三个字符就表示原字符，元字符在集合中都不表示自己元的能力
[a-d] #减号在中间的时候，表示区间的含义，这里表示a到d的集合
[ad-] #减号在末尾的时候，就表示原字符
[^a-z] #^表示这个集合的补集的意思，即除了a-z的集合的字符
[a^] #^在末尾表示原字符
[][] #这里表示一个]和[的集合
[^][] #这里表示不是]和[的集合
```

#### *(星号)

```python
[asd]* #跟在单个字符后面，表示这个字符出现0或任意次
```

#### $（锚点）

在字符串尾部时，才表示尾部的锚点的意思，即

```python
sd$ #表示尾部为sd的字符串
$sd #这时的$就是原字符
```

#### ^（锚点）

仅在字符串的头部时，才表示头部的锚点的意思，即

```python
^sdf #表示头部为sdf的字符串
sd^d #这时候的^就表示原字符
```

### 正则表达式拓展

原本的正则表达式叫BRE

扩展的正则表达式叫ERE

增加了以下格式

#### ()（分组）

```python
(xy)* #可以表示xy, xyxyxy
(pi|asd) #可以表示pi或asd
#解决了原本集合只表示单个字符的问题
```

#### +?\\{m,n\\}（重复次数）

```python
[0-9]+ #表示出现1或任意多次
[0-9]? #表示出现0或1次
[0-9]\{6,9\} #表示出现6到9次
```

## 正则表达式处理相关的指令

### grep

```python
grep echo #从stdin读入，并且找到有echo这个字符串的行，输出，并且把echo标红，并且被标记的字符不会再参与后面的字符匹配，也就是说，如果你想匹配'aa'，那么aaa，只有前面两个a会被匹配，后面两个不会，所以只有前面两个a标红，最后一个不红
grep 'asdf asd' *.h #grep会把第二个空格后的作为文件集输入，所以需要单引号把要查找的字符串包起来。并且由于以多个文件作为输入，所以输出的时候，会在开头带上"文件名:"，

-n #输出本行在文件中的行号，如果输入为多个文件，则先显示文件名，再显示行号
-v #输出不含该字符串的行
-i #比较字符串的时候忽略字母的大小写
-E #使用ERE正则表达式
```

### sed

sed是一个可以读脚本来处理文件的指令，也可以不读脚本来处理文件，主要的功能是替换，修改字符串。需要注意的是，替换的是匹配的部分，也就是说，一行没有被匹配的地方是原封不动的

```python
sed -e '3,10s/.*-\([0-9][0-9]\).rmvb/mv \0 第\1集.rmvb/' files
#-e可以省略，本意就是执行后面的语句，这里的语句是sed的特有的语法，数字3,10表示对3到10行进行处理，数字后的字母表示执行的动作，s表示swap，替换，格式是's/被替换的正则语句/替换完的正则语句/num'，num可以填g，表示全部符合的都替换，也可以填数字，如5，表示符合的第5个被替换，不填就默认为1
#'s/被替换的正则语句/替换完的正则语句/num'里，被替换的正则语句里使用\(\)作为分组，这里叫做模式。替换完的正则语句的\1,\2……，表示的是被替换的正则语句中的第几个模式，就相当于一个变量。而\0就表示整行本身。这样我们就可以把一些东西重组到不同的位置上了。不过sed最多只能记录9个模式。

sed -f 命令文件 文件名列表
#这个就是从命令文件里面执行上面的语句

#像是ERE里的分组()，0或1次?，1到任意多次+，n次{n}，这些符号都需要用\去转义，如\(\), \?, \+, \{n\}

#下面是一些例子
#一个输入
[快视频www.kuai-vdo.com]-电视剧《三国演义》中文字幕_1080p高清_央视1994版-69.rmvb
#不输入\0的时候
sed 's/.*-\([0-9][0-9]\)\.rmvb/mv 第\1集.rmvb/'
```

### awk（复杂文本处理）

```python
#awk的执行逻辑是 “-啥”是调整默认参数，后面跟一个语句表示要执行的动作，语句里面是当前行是否匹配，匹配的话print啥，按啥格式print。最后跟一个输入流，不填就是stdin，填就从这个文件里取。还可以-f，-f后面的参数就是命令语句文件，从这个文件里面读执行的动作

#打印有两种，一种是{print 元素1,元素2……}，一种是{printf("%d %s",NR,$1)}

#首先，$0表示原本的行，$1,$2……表示按默认分隔符FS=空格分割后得到的第几段
#然后我们也可以自定义FS，使用-F
awk -F , '{print $1,$3}' #这样我们就定义FS为','了
awk -F '[ ,]' '{print $2}' #这样我们就把集合[ ,]定义为分隔符了，先用空格分割，再用逗号分割

#然后我们进行模式匹配
awk '/asdf/{printf("row %d: %s",NR,$0);}' file #//里面是正则表达式，如果前面没有指定是哪个段匹配这个正则表达式，就会用一整行去看看是否匹配，匹配就执行后面的print，不匹配就不执行
awk '$1~/.*\.txt/ && $2==10 || $3!~/sdf/ {print $1}' #第一段匹配.*\.txt，第二段等于10，第三段没有sdf的行就输出

#-v可以声明变量，这个变量可以在语句里执行加减乘除
awk -v a=1 '{print $1,$1+a}' file

#awk 还有if 和 for循环，先不写了
```

# 文件内容比对

## cmp

```python
#就一个个字节比对，遇到不同就打印第一个不同的地方，同样就啥都不干
cmp file1 file2
```

## md5sum/sha1sum

```python
#使用散列函数，把文件内容映射成一串数字，那么只要这个数字足够大，那么文件重合的可能性就极低。另外，散列函数本身要能够均匀地分布，且难以反向破译，难以人工构造有相同key的文件
md5sum file1 file2
sha1sum file1 file2
#我们可以存文件的key，如果两个key相同，就可以认为两个文件是相同的文件，然后再进行文本处理，得到我们要批处理的文件的指令，放到脚本文件里，直接在脚本里sh执行脚本
```

# 文件版本差异

我们不仅想知道两个文件是否相同，还想知道差异在哪，这就有了这几个指令

## diff

```python
diff file1 file2
diff -u file1 file2
#diff 有两种不同的输出格式，一种是normal，就是不加参数的情况，一种是unified，git使用的就是这种格式。normal的格式很老了，所以也不是很好读
```

normal格式

![image-20230320092003364](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230320092003364.png)

unified格式

![image-20230320092520586](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230320092520586.png)

第1，2行的---，+++表示改动前的文件，改动后的文件

@@  @@包起来的是两个版本的哪几行的意思，-表示前一个文件的，+表示后一个文件的，这里的+-后的第一个数字表示从第几行开始，第二个数字表示包括几行，第二个数字没有默认为1。而我看网上的版本，第一个数字表示第几行开始，第二个数字表示第几行结束，这个可能是因为这里用的是-u0，而不是-u

再往后就是具体的语句变化，-表示去掉，+表示添加，也可以理解为-是上一个版本的东西，所以要抛弃，+是这个版本新增的东西，所以表示增加。而修改就可以理解为先去掉，再添加

# vim的使用

## 个性化

可以通过调整配置文件来对vim的显示进行调整

```
用户HOME目录下的文件.exrc，记作$HOME/.exrc
(每用户一份，用户独立设置)
set number 每行左边显示行号
set tabstop=4 制表符位置为4格对齐
用运行时检查偏好设置
:set
```

## 工作状态的转换

![image-20230320224231513](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230320224231513.png)

i是插入，a是追加，二者都是进入文本状态的键，只是一个光标在当前的地方，后者光标往后退一格

## 光标移动

在命令状态下

- h 光标左移一列
- j 光标下移一行
- k 光标上移一行
- l 光标右移一列

可以在上面的指令前面加数字表示执行多少次，如

- 5h 表示左移5次

## 翻页

ctrl-b 向后翻页

ctrl-f 向前翻页

同样可以在命令前加数字表示重复执行多少次

## 光标快速移动

^ 回到行首

$ 回到行尾

w 右移一个单词

b 左移一个单词

同样可以加数字重复

## 光标移动到指定行

冒号是行编辑的意思，后面跟的就是行编辑的动作

冒号加数字就可以跳转到指定的行，如

```python
:47 #到47行
:. #.表示当前行，可以用来相对偏移
:.-3 #当前行号减3
:.+4 #当前行号加4
:$ #$表示最后一行，都可以数字加减
:1 #第一行就1，没有^的说法
```

## %（括号配对）

光标在括号或有能配对的符号，按%就可以跳到和它配对的符号上

## 删除命令

命令模式下，可以用

x删除当前光标指向的字符，同样可以用数字表示重复次数

注意一般的命令一般都不回显，像是x指令，填进去就执行了，就看起来就完全没回显一样，所以填了数字就显示，一填x就可以解释了，之前填的数字就不见了

dd表示删除当前行，也可以用数字表示重复

## 替换命令

r表示替换当前光标指向的字符，如rk表示替换当前光标字符为k

数字也可以表示重复，但需要注意的是，重复次数大于1的r，会替换后面对应数量的字符，而不是在原地重复执行，并且光标会停留在最后一个替换的字符的地方

## 撤销和重复

u 表示撤回上一次的命令

. 表示重复上一次的命令

## 文件操作命令

-  存盘退出 ZZ 或 :wq 
- 存盘不退出 :w 
- 不存盘退出 :q!

- r表示读入文件，插入到当前行之下 
  - :r xyz.c 
- w表示写文件，前面的数字表示行号范围
  - :50,\$w file1 
  - :50,$w! file1 强制覆盖

- d表示删除，并拷贝到剪贴板 ，前面的数字表示范围
  - :10,50d 删除第10-50行 
  - :1,.d 删除文件首至当前行的部分 
  - :.,$d 删除当前行到文件尾 
- y表示不删除，拷贝到剪贴板(yank) 
  - :10,50y 
- p表示粘贴剪贴板信息（paste） 
  - p
- co表示复制
  - :5,10co56 把5到10行复制到56行下面
- m表示移动
  - :8,34m78 移动第8-34行到第78行之下
- ctrl-l 刷新屏幕
- ctrl-g 显示状态

## 模式，正则表达式相关的

### 模式查找

```python
/pattern #/后面跟正则表达式，进行模式匹配
n #向下查找下一个
N #向上查找下一个
```

### 模式替换

```python
:1,50s/abc/xyz/g #这个就是之前sed里的动作，含义一样，两段/里是正则表达式
#同样，()在这里仍旧表示原字符，这里的正则表达式是BRE，\(\)表示分组，不参与匹配，\1 \2和之前一样
```

# 文件通配符

## \* （星号）

匹配**任意长度**的字符串，包括空字符串

但有些字符不会匹配\*，必须真正地写一个对应的字符才能匹配，这就叫显示匹配，如下

```python
. #.在文件名的开头的时候，必须显示匹配，如
#.file ，这个文件名，就不能用*file匹配到，必须.*才能匹配到
#可以看到，.在文件通配符没有特殊作用

/ #/必须显示匹配
```

## ?（问号）

匹配任意单一字符

## []（方括号）

和正则表达式里的集合的含义一样

## ~（波浪号）

Bash特有

```python
~ #当前用户的主目录home
~kuan #用户kuan的主目录home
```

## .和..文件

之前我们说了，.不表示特殊作用，它就是个原字符

所以文件可以叫.，也可以叫..

但是，这两个名字已经被用了，在每个文件夹里面，真的有.文件夹和..文件夹

.文件夹指向当前文件夹，..文件夹指向上级目录

所以这个和文件通配符没有任何关系，这纯纯的目录存储干的

## 文件通配符处理过程

首先我们看到的命令，窗口，实际上是shell进程，shell和内核对接，然后shell会帮我们处理文件通配符，会把文件通配符替换成所有符合文件通配符的文件名，相当于把\*file替换成了1file, 2file……

这就意味着有些指令本来第一个是命令文件，第二个往后的输入文件，那么你本来想从stdin输入，结果你就填了个*file，shell一替换，好家伙，这么多文件，那指令又一看，懂了，第一个做命令文件，这样就出错了

如果不想被文件通配符解析，那么可以在参数加单引号包住，表示就长这样

还有就是shell里面，圆括号()，分号;是特殊字符，如果不想被乱用，那么就要在前面加个反斜杠\\，或者用单引号包住

# ls

- 没有参数时，列出当前目录下的所有文件和目录
- 参数是文件时，列出文件名
- 参数是目录时，列出该目录下的所有文件和目录

```python
ls -F #列出文件时，给出文件的类型，如果是目录，就在名字后面加/，如果是可执行文件，就在后面加*，如果是符号连接文件，就在后面加@，如果是普通文件，就没有标记
ls -l #列出文件时，使用长格式，例如

ls -l arg
输出：-rwxr-x--x 10 liang stud 519 Jul 5 15:02 arg
#第一个字符是文件类型
#- 普通文件 b 块设备文件(Block)
#d 目录文件(Dir) c 字符设备文件(Char)
#l 符号连接文件(Link) p 命名管道文件(Pipe)

#往后的每三个字符对应rwx读，写，执行的权限
#2-4字符: 文件所有者对文件的访问权限
#5-7字符: 同组用户对文件的访问权限
#8-10字符:其它用户对文件的访问权限

#第二项表示link到这个文件的目录项数

#第三项表示该文件拥有者的用户名，第四项表示该用户所属的组名

#第5项
	#普通文件表示文件大小，字节为单位
    #目录就是整个目录的大小，字节为单位，但这个大小不等于所有文件的大小之和
    #字符设备，块设备文件，表示主设备号和次设备号
    #管道文件，管道内的数据长度
    
#第六项，最后一次修改的时间

#第七列，文件名
    
ls -a #由于.开头的文件默认不ls出来，所以可以用-a全部打印出来，这样就可以打印.和..出来了
ls -A #除了不打印.和..，其他和-a一致

ls -s #列出文件占用的磁盘空间
```





# 实验1-正则表达式的过程

```python
wget https://quotsoft.net/air/data/beijing_all_20230203.csv

#这个是我找到的相关网站的html，上面那个直接就给了csv了，不符合题目要求
wget http://www.86pm25.com/city/beijing.html
```

![image-20230321112446584](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230321112446584.png)

![image-20230321112500258](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230321112500258.png)

![image-20230321232515294](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230321232515294.png)

可以看到第三项式pm2.5的浓度

![image-20230321232240041](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230321232240041.png)

也可以看到\<tr\>标记了我们要的数据的行

但\<tr\>标记不足以挑出这些行，还会包括

![image-20230321232925169](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230321232925169.png)

所以我们加多一点看看

![image-20230321233056545](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230321233056545.png)

这样就全挑出来了

![image-20230321232349729](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230321232349729.png)

```
cat beijing.html | grep '<tr><td>\|更新'|sed 's/<[^>]*>/#/g'|sed 's/[# ]\+/#/g'
```

```python
#shell脚本本身可以把stdout的字符串存到一个变量里，然后用这个变量的时候，直接加一个$就认为是变量了
timev=$(cat beijing.html | grep '更新'|sed 's/<[^>]*>/#/g'|sed 's/[# ]\+/#/g'|sed 's/\([0-9]\+\)/\1@/g'|sed 's/[^0-9@]\+//g') 
echo $timev

```

```python
timev=$(cat beijing.html | grep '更新'|sed 's/<[^>]*>/#/g'|sed 's/[^0-9]*\([0-9]\+\)[^0-9]*\([0-9]\+\)[^0-9]*\([0-9]\+\)[^0-9]*\([0-9]\+\)[^0-9]*/\1-\2-\3 \4:00:00/g')

cat beijing.html | grep '<tr><td>'|sed 's/<[^>]*>/#/g'|sed 's/[# ]\+/#/g'|sed 's/^#\([^#]\+\)#\([^#]\+\)#\([0-9]\+\).\{5\}#\([^#]\+\)#/#\1,\3/g' |sed 's/^#/'"$timev"',/g'
#变量在sed里面用是单引号加双引号'"$timev"'
#这里我们就完成了第一个实验

echo $timev
```

```python
cat beijing.html | grep '<tr><td>'|sed 's/<[^>]*>/#/g'|sed 's/[# ]\+/#/g'|sed 's/^#\([^#]\+\)#\([^#]\+\)#\([0-9]\+\)[^0-9#]\{5\}#\([^#]\+\)#/#\1,\3/g' |sed 's/^#/'"$timev"',/g'
#注意这一句是不匹配的，因为μg/m³里，3真的是一个数字，相当于匹配了ug/m到[^0-9#]，匹配了4个，结果最后一个匹配不上了，那么整句匹配不上了
```

截图

![image-20230321231444717](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230321231444717.png)

![image-20230321231421133](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230321231421133.png)

# 文件复制与删除

## cp：拷贝文件

有两种格式

```python
cp file1 file2
#把file1 复制到file2，如果file2不存在，则创建，如果存在，则覆盖

cp file1 file2 …… filen dir
#把file1到filen复制到dir里面

#如果两个参数以上，就是第二种格式，且目录必须存在
#如果两个参数，第二个参数是文件就复制到这个文件，如果是目录就复制到这个目录

cp -u file1 file2
#拷贝的时候，根据文件的时间戳，如果两个文件名相同，选择时间更新的那一个，这样可以保证备份的时候写反了，还能根据时间戳来防止新的版本被覆盖了
```

## mv

```python
mv file1 file2
mv dir1 dir2
#把file1移动到file2，可以用来文件和目录的重命名，如果后面的文件或者目录不存在，就是重命名，如果存在，那么就真的是移动

```

rm

```python
#删除文件
rm file1 file2 …… filen
#如果想要删除目录，那么需要递归地删除目录下的东西，那么就要用-r，这样就可以删除目录了
rm -r dir file
#-i表示删除每一个文件都要确认一遍
rm -i
#-f表示强迫删除，实际上只是删除的时候没有提示，不经过确认，不能删除的文件还是不能删除，总之就是能干干，不能干也别来问我。所以删除只读文件时也没有提示
rm -f
```

## 显示区分命令选项和处理对象

```python
rm -i -- -i
#--后面的表示都是处理对象，而不是命令选项，这样就可以删除名字叫做命令选项的文件
```

# 目录管理

## pwd

打印当前工作目录的绝对路径

## cd

改变当前工作目录

## mkdir

创建目录，会自动创建.和..

可以加选项-p，可以自动创建路径中不存在的目录

```python
mkdir database/2019/09/04/log
```

## rmdir

删除目录，但目录里面不可以有除.和..任何目录文件，比rm -r温和点

## cp：复制目录

```python
cp -r dir1 dir2
-u #和之前说的一样，增量拷贝
```



# xarg

会把stdin粘到后面xarg后面那个指令的最后，如

```
cat file1 | xarg grep 'echo'
#这个就会把前一个发过来的作为输入，直接粘到grep 'echo'的最后，如果file1 里的是
file1
file2
#那么就会往grep 'echo'做成
grep 'echo' file1 file2
#如果要粘的东西太多了，超过了128k
```

# tar

最早是用在磁带的信息传输上的命令

现在好像必须要带f指定文件了



# 程序获得信息的方式

## 配置文件

直接读文件，你想把配置放哪个文件就放哪个文件夹

像是bash的配置文件就是/etc/profile和~/.bash_profile，两个都会读，没有就按默认参数。然后由于/etc/profile是一个系统都有的，所以是系统级配置，所有用户都会读，而~/.bash_profile是用户的文件夹下的，所以是用户级配置，仅对改用户生效

## 环境变量

### shell和bash

![image-20230401212606948](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230401212606948.png)

在讲环境变量前，让我们先来把shell相关的东西讲明白吧

shell，即“壳”，是用来沟通用户和内核的一个程序，我们平时写的程序和它没有什么区别，对于操作系统都是用户态的进程

然后，GNU做了一个增强型的shell，作为linux的默认shell，我们用putty打开的就是一个远程连接的bash

当然我们可以换一个shell，不用bash进行交互，但那是后话了

然后说到用户交互，用户要和内核交互的，就是指令，我们可以跟shell说要执行啥，也可以叫shell读一个文件，然后把文件里面的东西当作指令执行

我们就可以写一些命令，然后通过shell跟内核沟通，执行，这些命令文件就叫脚本

例如脚本文件st.sh如下

```
echo "hello world"
exit
echo "hello world"
```

然后我们可以用以下指令执行它

```
source st.sh
```

```
sh st.sh
```

```
bash st.sh
```

那这三种方式有什么区别呢？

上面也说过了，shell就是个进程，和其他的一样，那么我们使用

```
sh
bash
```

实际上就是开了一个shell的进程，然后这个进程从后面的文件读取，把读取作为命令（shell实际上就做了把从用户读到的东西作为arg传给c程序，然后程序自己根据这些东西来执行，还有就是把文件通配符替换了。所以在shell里使用sh本质就是创了一个shell，然后新建的shell又读arg，把它当文件名来处理）来执行

所以source和其他两个本质的区别就是source是在当前的shell进程解释执行后面的文件，而sh和bash就另外开了一个子进程。而shell本身是和用户交互的，执行exit关闭了shell，在用户看来就是关闭了，退出了，所以如果使用source执行st.sh，那么就会直接退出，而如果使用sh或bash执行st.sh，那么就开了一个进程，然后把新开的进程关了，所以在用户看来就没有退出

那sh和bash有什么区别呢？sh跟bash的区别，实际上就是bash有没有开启posix模式的区别，用的shell都是bash

不过还有一种执行脚本文件的方法

```
./st.sh
```

没错，就是直接写这个文件的路径。当然一般这样做你会收到permission denied，这是因为在linux里，所有东西都是文件，而文件只有三种权限，读，写，执行，这里缺的就是执行权限，如果你使用

```
ls -l ./st.sh
```

![image-20230401233110667](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230401233110667.png)

你可以看到，执行权限x是没有的

插入说以下权限的查看方法

![image-20230402142347340](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230402142347340.png)

那么我们给它权限就好了，用chmod(change mode)

```
chmod 777 st.sh
```

其中每个数字都是八进制的数字，所以7表示111，就把rwx都给了

这样st.sh就可以执行了

那这个执行又是什么意思？

### linux文件分类和文件执行

实际上Linux里的文件分几类，最基础的两类就是普通文件和目录文件，我们使用ls -l时的第一个字母为-时就是普通文件，为d时就是目录文件。那不是说linux下的东西都是文件吗，为什么还要分类？我不知道，但分类后不同种类的文件从本质上来说是真的不同，操作系统提供的接口是不一样的，实现方案来说，很可能就是不同的标志位。然后普通文件又分为两种，二进制文件和ascii text文本文件，这两个操作系统提供的接口应该也是不同的，使用指令file可以看到输出不一样。然后二进制文件就是直接按linux的指令集做事，ascill text就得有一个解释器才能做事，举些例子

st.sh，里面写的就是一句文本

```
echo "hello world"
```

我们可以用各种东西解释，比如

```
vi st.sh
```

![image-20230402094157836](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230402094157836.png)

可以使用python来解释

```
python st.sh
```

可以用cat来解释

```
cat st.sh
```

可以直接用shell解释

```
./st.sh
```

```
sh st.sh
```

```
bash st.sh
```

这个解释的过程，我觉得就是，解释器是一个程序，我们要解释一个文本文件，就是把这个文本文件传参传到解释器里，解释器执行相应的操作

但每次执行指令都要指定解释器，太麻烦了，怎么办呢？

我们可以在文本文件的开头加一句

```
#!/usr/bin/vim
```

开头的 #!就是执行时，告诉别人，解释器就用后面的字符串，而#!这种格式，叫做shabang

那我们试试

先用

```
whereis vim
```

把你要用的解释器的路径找到

然后使用#!填进文件里

![image-20230402094606088](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230402094606088.png)

![image-20230402094528915](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230402094528915.png)

同样，我们可以指定cat

![image-20230402094853847](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230402094853847.png)

然后我们输出来输出去，无论是用od，vim，cat还是什么，都无法输出用来区分文件类别的信息。实际上

![image-20230402104213111](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230402104213111.png)

file就是根据这个条件取区分的

准确来说，在Linux的基础分类下的再分类是依靠文件本身的内容进行区分的，而文件的基础分类应该是操作系统提供的接口。然后普通的文件会在内容的开头加一些特殊的字节串，这样就能区分不同的文件了。这些特殊的字节串是一个规范，file会读开头的东西，如果可以解释，那么就会输出对应的类型。文件头举例如下

![image-20230402131557641](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230402131557641.png)

那么，只要我们按一定的字节用vi写文件，那么这个文件可以变成ELF文件，或者其他的可执行文件。我们试试

在vim打开一个文件，使用命令

```
:%!xxd
```

这个指令的作用是把当前的内容当字符，把所有的字符都换成对应的16进制的字符表示，注意是字符表示，也就意味着

```
ab
```

将会变成

```
6162
```

然后这时候文件真实存的就是这几个字符，6，1，6，2

然后把61改为63，再用

```
:%!xxd -r
```

这条指令将会把当前的所有字符当作16进制，转换为字节，那么

```
6362
```

就会从4个字符转换成两个字节，这两个字节的数值为63，62，对应的字符就是cb

那么我们就可以通过vim去写ELF的头

![image-20230402133759431](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230402133759431.png)

把这玩意写到文件里，然后用file的结果如下

![image-20230402120453599](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230402120453599.png)

windows下的exe的头也是特定的

![image-20230402120624932](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230402120624932.png)

同样，pdf之类的头也是固定的，我们可以自己造pdf文件

![image-20230402102248672](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230402102248672.png)

![image-20230402102300681](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230402102300681.png)

然后如果没有可识别的文件头，然后又都是可见的ascii字符，那就会被判断为文本文件，但如果有黑名单的字符，那就会被认为是data文件，即二进制存储数据的文件

可执行文件可以直接执行，而文本文件执行就需要解释器，本质上就是叫解释器做事

然后我们平时用的指令ls，cat，之类的，其实都是一个程序，那为什么我们写的程序./st.sh需要带相对路径或绝对路径，而ls，cat之类的不用呢？因为Linux的路径实际分为三种，第一种是绝对路径，以/开头，第二种是相对路径./或../，总之都得目录开头。而第三种，就是不用目录开头，直接文件，这个实际上应该是shell有一个环境变量$PATH，如果直接用文件开头，那么就会把PATH的若干个值作为目录的路径，接上文件，检测到了存在的文件路径，那么就会执行这个路径的文件，如果是可执行文件就直接执行，如果是文本文件就按所选的解释器执行。那么我们只要把st.sh放到PATH指向的路径，那么我们就可以直接st.sh执行了。像是下面我们就把ct，一个ELF可执行文件扔到了/usr/bin里，这样就可以像用ls一样用ct了。不过/usr/bin文件夹权限比较高，所以换到root去mv比较方便

![image-20230401231100761](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230401231100761.png)

### 环境变量

然后说了这么多，我们终于可以讲到环境变量了

环境变量就是shell帮你记录了一个字符串和另一个字符串的映射，像是

```
keep=abc
```

然后你要用这个变量的时候，就加一个$

```
echo $keep
```

那么shell就会把$keep换成映射到的字符串，abc

所以执行的就是

```
echo abc
```

不过上面设置的叫做普通变量，不是环境变量，环境变量才有c语言接口getenv()接口，普通变量一般是用来弄脚本的

使用set显示当前的所有环境变量，普通变量

使用env显示当前的所有环境变量

使用export 来声明一个环境变量

执行如下

![image-20230402140107480](linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20230402140107480.png)

然后需要注意的是，记住变量的映射的进程是shell，也就意味着shell关了，下一个打开的shell是不知道你定义过的变量的

临时用就直接这样定义就行了

那如果想要持久化地定义一个变量怎么办呢？

前面我们说过，脚本就是一个命令集，那如果我们把变量定义的语句写到一个文件里，打开shell的时候，就执行这个文件，那么在我们看来，这个变量就持久化了

而这个文件，应该叫这些文件，就叫.bashrc，.bash_profile，下面介绍这两个的区别

### Shell启动类型

简单来说，不同方式启动的shell，会读不同的文件来作为脚本执行

#### 登录Shell与非登录Shell

当用户登录Linux，操作系统会自动给用户分配一个Shell，这个Shell就是登录Shell。

我们在终端输入`bash`命令启动的Shell，以及执行脚本时根据*shebang*启动的Shell都属于非登录Shell。

简而言之，我们登录系统的第一个Shell是登录Shell，后面启动的Shell都是非登录Shell。但是，可以使用`--login`选项强制成为登录Shell。

登录Shell退出时会显示“*logout*”，而非登录Shell显示“*exit*”。

#### 交互Shell与非交互Shell

我们登录系统获得的Shell与输入`bash`命令启动的Shell，都会等待我们输入命令，并把输出内容显示在屏幕上，这就是交互Shell。交互Shell一般都有命令提示符，比如`[user@host ~]$ `。

如果我们调用Shell执行一个脚本，就不会等待我们输入命令，也不会出现命令提示符，并且在脚本执行完毕后自动退出，这就是非交互Shell。可以使用`-i`选项成为交互Shell，但Shell行为不会改变，仍然是非交互的。

交互Shell的`$-`变量包含字母`i`，而非交互Shell不包含。

#### 配置文件

不同启动类型的Bash读取不同的的配置文件。

##### 登录Shell

当Bash以登录Shell启动的时候，会首先读取并执行文件“**/etc/profile**”中的命令。像是putty连接

接着，Bash会依次查找文件“**~/.bash_profile**”，“**~/.bash_login**”，“**~/.profile**”，读取并执行找到的第一个文件中的命令。也就是说，如果“**~/.bash_profile**”存在，就不会执行“**~/.bash_login**”和“**~/.profile**”中的命令。

当交互登录Shell退出，或者非交互登录Shell执行`exit`命令后，Bash会读取并执行文件“**~/.bash_logout**”中的命令。当然，执行命令在真正退出前。

##### 交互非登录Shell

当Bash以交互非登录Shell启动时，像是在本地直接启动shell，会读取并执行文件“**~/.bashrc**”中的命令。一些发行版比如*Debian*系和*Arch Linux*系，会先读取并执行文件“**/etc/bash.bashrc**”的命令，但这不属于Bash规范。

##### 非交互Shell

当Bash以非交互Shell启动时，像是在shell里启动一个shell，会读取环境变量“**BASH_ENV**”，如果变量的值是一个文件，则读取并执行这个文件中的命令。查找这个文件时**不会**使用“**PATH**”路径。

## 命令行参数

## scanf，ifstream交互输入

# 命令行参数的风格

## =风格

param=value

```
dd if=sysdisk.img of=/dev/sdb
```

## -风格

-p或-param，减号加一个或多个字符

```
find src -name ’*.c’ -type f -exec dos2unix --keepdate {} \;
```

## 长短选项风格

长选项为多个字符，使用--开头，短选项为单个字符，使用-开头，同一个选项可以同时有多选项和短选项表示

```python
ls --classify --all --size --human-readable --width=80 /home/jiang #长选项
ls -Fashw80 /home/jiang #多个选项挤在一起
ls -F -a -s -h -w 80 /home/jiang #多个选项分开
ls -F -w80 /home/jiang -has #可以把选项放到后面
#用独立的命令行参数--显式地标识选项结束
#选项的处理统一由C语言标准动态链接库libc.so中库函数getopt_long()完成

```











