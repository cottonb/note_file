# 第一章——概述

## 再简单一点概述各个层次的作用

- 物理层，信息该用什么样的信号表示
- 数据链路层，在点对点连接中，成帧，顺便做一些差错控制和流量控制的添头服务
  - 介质访问子层，就是在多个主机连接同一条线的情况下，怎么处理冲突的问题
- 网络层，由于数据链路层是一个局域网，用来沟通不同的局域网的，所以要能路由
  - 还有ARP，DHCP，ICMP等帮助网络层管理，转化沟通其他层次的协议
- 传输控制层，做完可靠性保证等端到端的服务
- 会话层，管理每个连接所使用的资源，比如序列号，存储空间之类的
- 表示层，对数据进行压缩，编码等改表示的层次
- 应用层，就用户处理逻辑的层次

## 点到点和端到端的区分

![image-20230420172948809](%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0.assets/image-20230420172948809.png)

点到点强调没有中间节点，是直连

端到端可能会经历中间节点，但本质不在于中间节点，它的本质在于，某些功能和控制逻辑最好在通信的两个终端上实现，而不是在中间网络元素上。

所以端到端通常需要实现一些功能，功能如下

1. **可靠性**
2. **顺序传输**
3. **流量控制**
4. **拥塞控制**
5. **数据完整性和错误检测**
6. **安全性和隐私**
7. **应用级语义和状态管理**

所以点到点和端到端的概念差得很大，点到点描述的是状态，端到端则是一个设计原则，一般需要实现这些功能

另外，端到端虽然强调要把功能放到终端实现，但也不意味着中间的节点不会进行负载均衡，安全等功能，但也不意味着我们就可以把这些功能扔给中间节点做了，原则是原则

所以，数据链路层是点到点的，传输层（其实应该叫传输控制层，再怎么也应该缩写成控制层）完成了这些功能，所以是端到端的

那网络层呢？首先，网络层是一个承上启下的层，它统一了二层乱七八糟的协议给传输层，并给传输层提供一些基础功能，以便传输层能完成控制的功能

所以网络层是点到点吗？是端到端吗？其实都不纯粹，工作方式实际涉及到了点到点的工作方式，但我们更关心通信模式——广播，多播，任播，单播。但它又没有完成端到端的功能（本来也不该由它来做），只是给传输层提供功能，所以也没有实现端到端



## 2023/4/21概述

在讨论前，首先要建立的共识——无论是电话网，信令网，还是互联网，信息的传递都不过是某种二进制，或是其他形式，而我们规定，约定了信息格式，执行某个操作的过程，完成提供的服务，这三个约定，就是协议。所以可以说，有信息传输，就要有协议，信令也不例外。

而按照计算机的常识，做好分工，分层，高内聚低耦合，这样才能较好地完成一个庞大的工程。协议也是如此，我们当然可以用一套规定/协议，把信息传输过程中需要解决的问题都规定了，但如果未来需求变更了呢？你改一整套协议吗？很明显，变更的成本太高了。所以我们要做好协议的分层，每层协议就干一件事，对上层提供服务/接口，这样你换哪一层，都不至于大动干戈。

那如何分层呢？首先，传信息要从两台计算机开始。所以我们先在两台计算机间传输，那我们用什么介质呢？电线，光纤，红外线，电磁波？我们如何把物理特性表示为0，1呢？高电平为1，低电平为0？还是切换的时候表示1，不变表示0呢？还是相位，频率，幅度来表示呢？这些都是需要约定的，做好了这些约定，这个就是物理层的协议

这时候我们已经能在两台计算机传0，1信号了，但物理层并没有提供第三个信号，表示当前没有信号，也就是说，我们的电脑无论如何，其实一直都在接收0或1，那我们的电脑怎么知道有没有人发信号呢？这就是帧的意义，帧就是一段数据的意思，数据链路层对发送的数据进行处理包装，使得另一端可以识别出这是一段数据。然后数据链路层还需要保证两台计算机间传输没有出错，所以有校验。另外，如果对方已经处理不过来了，那么我们需要流量控制。这就是数据链路层的基本功能

但是如果我现在不是两台计算机了，很多台计算机都连在一条总线上，发消息就是广播，那这样会冲突，所以数据链路层需要解决冲突问题。但我们怎么发到我们想要发的计算机上呢？经典和用得最广泛的就是以太网协议，它是数据链路层的一个协议，实现了寻找主机的功能，它根据mac地址进行寻找

另外，数据链路层由于使用的都是广播，这样有很多问题，不如先分组，把一个局域网分成多个组，只能组内广播，这样就好很多了。如果靠物理连线分组，那这样太麻烦了，反复连线，拔线。那我们不如用软件实现虚拟局域网，这就是协议实现的vlan

到这里，我们就实现了用一条线或多条线连起来的网络，局域网。但很明显啊，如果别的局域网协议和你不同，那完蛋了，你们之间需要做很麻烦的转换，甚至不可能互通。这太傻逼了。所以我们需要有一个东西，统一起来，这就是网络层的作用。还有一点，就是局域网不可能做得很大，看广播就知道了，而网络层就可以把很多局域网沟通起来了。还有就是，网络层既然要沟通局域网，那么每个局域网的主机，就需要有一个统一，唯一的编号。说了这么多，这个网络层就是ip协议。为什么这一层只有这一个协议呢？实际上不能这么说，这一层还有ospf，rip等协议，但这些协议都是用来控制ip寻址的。之所以只有ip，就是因为网络层干的就是统一的工作，如果出现了多个，那不是还得再统一？

但ip层只做了是否传对了地方的检测，并没有做无差错检测，那出问题了怎么办？所以还要一层协议来进行差错控制，这就是传输层的TCP。其实传输层不是干这个的，传输层真正的名字叫传输控制层，重点在于控制，传输是控制的修饰词，这一层是干控制的，如果丢包了，是否要重发，如果出错了，是否要重发之类的，这就是传输控制。我们当然可以不检测，这就是UDP，那UDP有什么用？传输层还有很重要的一点，就是端到端，就是

![image-20230421131235725](%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0.assets/image-20230421131235725.png)

```
The end-to-end principle is a classic design principle in computer networking. In networks designed according to the principle, application-specific features reside in the communicating end nodes of the network, rather than in intermediary nodes, such as gateways and routers, that exist to establish the network. The end-to-end principle originated in the work by Paul Baran in the 1960s, which addressed the requirement of network reliability when the building blocks are inherently unreliable. It was first articulated explicitly in 1981 by Saltzer, Reed, and Clark.[1] was published in ACM's TOCS in an updated version in 1984.
```

进程在网络的特征位，实际上就是端口，准确来说是进程和这个特征位绑定。而点到点是

![image-20230421131624949](%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0.assets/image-20230421131624949.png)

点到点针对网络中的节点，即主机/路由等实体

端到端针对进程

到这里，我们整个网络就已经完成基本的传输任务了，再往后，就是应用层的协议了，你应用想用什么协议用什么协议

另外，提一下面向连接和无连接，虚电路和数据报的关系。首先，它们都是一种手段，或者说是承诺实现的一个功能。其次，面向连接和无连接在计网的osi里属于传输层的承诺，而虚电路和数据报是数据链路层的分组交换的两种实现方式。实际上它们可以看作同一种理念下近似的使用。面向连接和虚电路都是先建立连接，再发送包，无连接和数据报是无需建立连接，直接发送包。虚电路由于先连接，建立虚拟电路，再发送，所以转发的时候更快，且没有乱序的问题，面向连接就把先建立连接，保持连接（保持链路），没有乱序的功能承诺；数据报由于需用建立链路，所以发送更快，且路径不固定，更健壮，无连接就把无需建立连接直接发送的功能承诺。所以面向连接和无连接更像是对虚电路和数据报的特征的抽象，而不是对实现方案的抽象，也就是说，面向连接和无连接是描述功能的，不是描述实现的。而虚电路和数据报是一种实现，进而有了这些功能。



## 写完笔记概述

下面的东西可看可不看了，听我讲完这段话就差不多了

网络是什么？传递信息。什么形式传递？二进制信号。这些信息要不要有格式？肯定要，不然你怎么解释我们得到的信息，怎么告诉别人必须要告诉的信息？那这个格式是什么？这就是协议

协议就是规定了信息的格式，比如这几位就是这个报文的长度，那几位就是编号。那听起来好像学计算机网络只要记格式就好了，但这差远了。为什么呢？因为我们还有很多问题没有解决，下面一一列举

- 首先我们的网络最基础就要做到消息的传达，那你怎么找到对应的主机呢？怎么快速找到呢？全球这么多主机，每个路由器都要上百亿的映射表？
- 就算能找到，那我们的网络也不能保证报文在传递的过程中没有出错，那出错了怎么办？对方检查出来了叫我们重发？那报文丢了，对面也不知道，我们也不知道，谁重发？超时重传？那这个时间怎么定？太久网络的带宽浪费怎么办？再者，我们也没法保证报文按顺序到达，那这怎么办？
- 就算上面两个问题解决了，那你怎么保证某条线路不会因为负载过重而瘫痪？把流量分摊？那你怎么分摊？你有什么机器很方便做的算法吗？你怎么测得现在负载过重了呢？

这些问题都需要解决，那怎么解决呢？一下子要解决这么多问题，很头疼吧。所以我们提出了分层的概念，把计算机网络分成了7层，每一层都解决特定的问题

- 物理层，解决二进制编码的问题，二进制消息实体是什么的问题，介质带宽的问题
- 数据链路层，解决两个直接连接（用电缆或光纤，反正没有用路由转发）的主机或路由（其实路由就是一个主机）相互发消息的问题，解决一堆连在一根线上的主机相互发消息的问题，而这堆主机，就叫局域网
- 网络层，解决不同局域网的相互连接的问题，真正解决找到一个主机的问题，向传输层提供拥塞服务，并隐藏了数据链路层的不同，向上层提供统一的格式
- 传输层，解决端口问题，并能提供可靠传输，拥塞控制，流量控制的服务
- 应用层，程序员使用的层面，不记得了
- 还有几层不记得了

协议分层的好处就像我们写接口，某天发现有个函数不好用，我们就算改了它，接口都实现了，那也不用全局修改

每一个协议都有其对应的层

下面我们再来说说计算机网络的一些概念

- 面向连接和无连接

  - 面向连接就是用以前的接线员的概念，每次我想和对方通讯时，需要接线员为我接线，我的报文都跟着分配的线路走，这样的好处是报文都是顺序到达，而且不用花费大量空间去记录我要到哪里。坏处就是每次建立连接都需要消耗资源。到后面TCP协议时，面向连接的意思不再有预留空间，按固定线路走的意思，仅保留了面向连接的两个好处
  - 无连接就是报文里有我要找的主机所需要的各种消息，好处就是每次走的路线都可能改变，也可以改变，极大地提升了网络的健壮性，也可以走最短路径，还可以将流量分摊，发送也不需要建立连接。坏处就是每次发都需要带厚重的头

- 可靠和不可靠

  - 可靠就是发送的信息能正确到达目的地（信息出问题了，重发到达也是解决的方法）
  - 不可靠就是不保证信息一定正确到达目的地

- 分层的包的样子

  ![image-20220720111830145](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220720111830145.png)

  这是一个报文，帧是数据链路层传输的报文单位，帧的数据部分装着上层，网络层的报文；包是网络层的报文单位，包的数据部分装着上层，传输层的报文；段是传输层的报文单位，段的数据部分装着上层的报文

- 路由器和交换机

  - 交换机是局域网的东西，用来代替电缆，能起到更好的防冲突和提高带宽效率的东西
  - 路由器是连接局域网的东西，或者说没有路由器，局域网根本连不上网





## OSI协议介绍（少人用）（了解一下）

- 物理层——定义了

  - 用什么物理介质（电压还是光还是什么）表示0、1信号

  -  一个比特持续时间多长

  - 传输是否可以双方同时进行

  - 最初的链接如何建立，在双方会话结束后如何拆除

- 数据链路层

  - 把输入数据分割成数据帧并传输

  - 如果服务是可靠的，则要发确认帧来确保每个帧的传输

  - 流量控制

  - 广播网络——控制信道的占用

- 网络层——控制子网的操作

  - 转发

  - 把数据包从源发到目的地的路径决策，会建一个路由表
    -  有三种路由(路由就是route)：
    -  ——静态的
    -  ——开始链接时决定
    -  ——高度动态的

  - 拥塞控制，防止有人发一堆东西把信道占了

  - 服务质量（Q&S）
    -  具体指延迟，传输时间，抖动（每n秒发一个数据包要稳定，不然时快时慢就会卡，而这就是视频缓存的一样）
  - 异构网络互联
  - 如果在广播网络路由就很简单，不用干太多事

- 传输层——端到端的一层，端到端的可靠传输

  - 接收上层的数据，如果需要分割成更小的单元就分割，然后传到网络层，并要确保端到端的可靠传输

  - 确认向会话层提供的服务类型
    - 无错误地传输
    - 传输孤立的信息，不保证传播顺序
    - 向多地广播信息

  - 拥塞控制

- 会话层

  - 对话框控件，跟踪轮到谁来传输

  - 令牌管理，防止双方同时做相同的关键动作

  - 同步化，在丢包后能找到丢包的位置重新开始

- 表示层——传输信息的语法与语义，沟通不同数据表示
  - 用抽象的数据结构定义不同数据表示（相当于世界语沟通各国语言）

- 应用层——用户需要的各种协议
  - 比如传输协议、文件传输、电子邮件、网络新闻···

## TCP/IP协议介绍（重点）

- 网际层

  - 基于无连接的交换网络

  - 定义的数据包格式和协议，这个协议称为IP

  - 这层的工作就是尽力把IP数据包传到该到的地方，好处就是简化了路由。但还是要做路由和拥塞的工作

- 传输层

  有两种著名的协议：

  - TCP传输控制协议：

    - 可靠、面向链接的协议

    - 分割字节流给上层

    - 接收上层数据重新组装到输出

    - 流量控制——防止发送端发送的信息过多超过接收端处理能力

    - 拥塞控制

  - UDP协议：

    - 不可靠无连接的协议

    - 适用于即时传递比准确传递更重要的程序，如打电话，适用于不需要TCP排序或它的流量控制的程序

## OSI模型的核心概念

- 服务

-  接口

- 协议

## TCP/IP模型的批判

- 未区分服务，接口和协议

- 不是一般的模型

- 主机到网络的层不是真正的层

- 没有提到物理层和数据链路层

- 次要协议根深蒂固，难以取代

## 网络标准制定

- ITU（国际电信联盟）制定电信的标准
- ISO（国际标准组织）啥都制定过
- IEEE（电气和电子工程师学会）制定过局域网的标准
- 当前互联网的标准由IETF工程任务制定 

## 基础概念

- 时延
  - 发送时延
  
    一个设备或路由发送一个数据块所需要的时间

  - 传输时延
  
    信号通过传输介质需要的时间（光速不变，所以这个只与线路长度相关）
  
  - 处理时延
  
    路由检查数据，选路的时间
  
  - 排队时延
  
    在路由中排队的时间
  
- 传输方向
  - 单工：单向
  - 半双工：双向，但不能同时相互传
  - 双工：双向，可同时相互传
  
- 并行与串行
  - 并行：一次发多个比特，双方都要有这么多信号接口
  - 串行：一次发一个比特
  
- 异步传输
  - 双方收发的速度不同，收发时钟不同。输速率过高，双方速度差太多了，就会识别边界不准确，信息边界（常见的数据都是分成一块块，一个数据块，帧，分组）就会识别错，传输信号就会错。好处就是以字符为单位传输，字符间的间隔随意，靠识别符识别。省钱，不用搭那么多线
  
- 同步
  - 时钟要同步，这样分组分块就不会出问题了，费钱，要搭更多线

# 第二章 ：物理层

下面介绍一下物理层的相关概念和操作

## 数据，信号和码元

- 数据是传送信息本身，即我们想要传的东西，而信号是数据传输过程中的电气或电磁表现，即用电磁波表现的数据，或用光表现的数据

- 模拟数据：连续变化的数据

- 数字数据：离散的数据

- 码元：一个固定时间内的一个信号波形，这个波形能表示若干个比特的信息量。

  比如用这个波形的相位，幅度，频率来表示信息。

  > 听起来好像可以用不断提高采集率的方式表示无限比特的信息（波的幅度总可以不断分成不同的级别，相位也是这样），但这样我们的容错率就会大大降低，或者说我们的仪器会有识别的上限，超过这个上限就会误判，所以为了避免误判和降低技术难度，我们不会这样去干

## 带宽

- 信号谐波通过介质时，频率越高，能量损耗越严重，所以规定振幅损耗低于一定程度的频率称为带宽，即可通过的频率大小的范围。当然带宽还有bps的意思，靠上下文理解



基带传输：原始信号

通带传输：调制后的信号，比如把多个信道的信号搬到不同的频率防止相互干扰，这就叫通带传输

## 信道的极限速率C

- ### 奈奎斯特定理

  - 带宽为H，信号级数为V（即我们表示的码元一共用几个东西表示，如二进制只有0，1，但八进制就有0，1，2···7，），数据极限传输速率C（bps），没有噪声

    则            

    ## $$C=2Hlog_2V$$                

  - 奈奎斯特采样定理

    采样率大于等于介质带宽（或当前信号的最高频率）的2倍才能还原出信号，不然就会失真

    > - 我们的信号都是由傅里叶变换得到的，傅里叶变换的本质就是叠加，而叠加的一个状态（码元）所占的时间是由最高频率的周期信号决定的，（就像10000状态想变到10001状态，你最小位不变化，其他位再怎么变化也到不了那个状态），频率越高，占的时间就越短
    >
    > - 很明显，每个状态的时间占用的时间越短，单位时间所能发送的状态就越多
    > - 而奈奎斯特定理就告诉我们，波特率baud（单位时间发送的码元数，单位就是baud，表示每秒多少波特）最高为带宽的两倍（最高频率的波上下两个状态，所以是两倍（好像不是，我再查查）），即  2H
    > - 而一个码元所能代表的信号级数V，就相当于  $$log_2V$$个  比特bit，那我们用baud乘上每个码元所代表的比特数，那不就是比特率bps吗

- ### 香农定理

  - 在只有高斯白噪声的情况下，传输信号平均功率为S,高斯噪声功率为N，那么

    ## 

    **信噪比**记为为 $$(S/N)_{dB}$$,  (角标表示以分贝为单位表示）

    且

    ### $$(S/N)_{dB}=10 \times log_{10}(S/N)$$
    
    > $$C=Hlog_2(1+(S/N))$$中的$$S/N$$就是正常单位
    >
    > 只是我们回答信噪比是多少时要用分贝为单位

## 有线传输

- 磁介质
  - 其实磁带用快递送也叫信号传输介质，磁介质
- 双绞线
  - 就是两根线螺旋式地缠在一起，这样就不会向两根直的线像天线一样向外信号干扰，绞在一起可以相互抵消。有两种双绞线——UTP&STP，无屏蔽双绞线和屏蔽双绞线。绞得越紧传输越快
- 同轴电缆
  - 中间就是用铜传输，外面包几层屏蔽。传输速率带宽高，传输距离长，抗干扰能力强，贵
- 电线
  - 用电线和电表信号通讯。主要是不想布线时就用电线，没啥长处，还会受干扰
- 光纤
  - 会把三根光纤合在一起打包成光缆。中间的玻璃丝传输信号，细到只能传一路光信号的叫单模光纤，粗一点的能传多路光信号的叫多模光纤。接入设备还是用电信号，所以传输后还需光电转换
  - 好处：重量轻，高带宽，安全一点

## 无线传输

- 窄带通信
  - 用比较窄的带宽使得接收端能得到较好质量的信号
- 扩频通信（目前常用）（蓝牙，WIFI都是这种）
  - 用之后提到的码分复用的方式将信号扩展到一个很大的频段，然后一堆人能同时用这个频段且不发生干扰
- 无线电通信
  - VLF,LF,MF这些低频的信号，传输距离在1000km
  - HF高频信号靠电离层反射传输，传输距离在100km~500km
  - 无线电频谱分配
    - 有些频段使用需要审批，防止干扰某些部门的信号
    - 不需要申请的频段叫ISM，但要求使用扩频通信，功率也要在一定范围
- 微波传输
  - 没有光纤时，就靠这个长距离传输
  - 直线传播，两个接收器必须必须对准，而且由于地球是圆的，所以传输距离一般80km。会散射，会有干扰，也会受天气影响
- 红外通信
  - 电视遥控器用的就是这个
  - 短距离，无法穿透墙壁，不会影响别的设备
- 光波通信
  - 用的不是光缆，而是空气，直接射激光，接收器对准后就能接收。有雾，热气都会产生干扰
- 卫星通信
  - 相当于天空中有一个微波中继器
  - 收到一个频段的信号后，放大它，然后用另一个频段（下行波束）的信号传出去
  - 下行波束有传出去范围广的，也有窄的
  - 寿命一般十年，费用昂贵
  - 卫星越高，覆盖整个地球需要的卫星就越少，但延迟就越高
  - 同步卫星在地上会用VSATs技术，就地上一堆天线锅，一个天线锅传到卫星后传到一个中心大天线锅，再传给要传的天线锅（没有能力直接通过同步卫星传就只能这样将就了）。很明显这延迟很高
  - 中轨道卫星：导航用到
  - 低轨道卫星：原来有个Iridium铱星计划，就是建立一个低轨道卫星通信网络，能有效抵抗灾害破坏，但受到互联网的快速发展破产了（当然军方收购了还在用）。后面还有全球星计划，就地上用中继站凑合一下省点钱

## 编码方式和同步问题

首先，不同步就意味着数据会识别出错，比如第n位是1，我跳到下一位，读到下一位了，那出事了。但也不意味着异步就不能用了，可以在上层去做检测，比如每隔一段数据就会带一个特殊的编码，我一看，就知道应该同步到这里了，就可以调回来了。同步和异步主要看你的上层的要求，同步并不是物理层的责任，倒像是下层和上层互相踢皮球了

- 基带传输：就用介质最高频率做1，最低做0

  - NRZ
    - 用高电平，低电平表示1，0
    - 但电平级数太少了，根据纳克斯特定理很容易到瓶颈
    - 但会发送很多连续的1或0，要识别有几个1，0，就必须要加时钟线同步，但这样有太贵了
  - NRZI
    - 用于解决上面的问题，用信号的上升下降的那部分表示1，不动的地方表示0
    - 但这样还是没有解决0连续的问题，所以限制0最多3个连续，通过4B/5B编码（把4位编成5位）就能让0最多3连续，但浪费了20%的带宽
  - 曼切斯特编码
    - 用下降沿表示1，上升沿表示0，用时钟信号和编码异或后产生
    - 这样每次跳变就是时钟信号的跳变，这样就不用同步信号来加以识别时钟了
    - 但这样需要时钟信号以两倍的传输速度的频率，这就意味着需要两倍的带宽

- 上面几种编码如下图（e为二级编码，我也不知道是啥）

  - ![image-20220327092423495](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220327092423495.png)

  - 平衡信号

    把0,1平衡是我们解决连续信号造成的时钟问题的另一种方式，4B/5B也是其中一种

    - 8B/10B编码，根据当前0，1的数量编码使得0，1比较平衡
    - 当然还有其他的编码方式

- 通带传输：就用介质一部分频率做1做0
  - 二进制信号（方波）

  - 幅移调制（AM）：根据信号的幅度表示1，0

  - 频移调制（FM）：根据频率

  - 相移调制（PM）：根据相位

  - 当然还可以幅度，频率，相位调制结合，这样就能提高带宽，但技术也复杂

    如下面的星座图，有三种相位和幅值结合所表示的信息

    下面三者仅每个码元所能表示的比特数不同

    QPSK只能表示2位比特，QAM-16能表示4个比特，QAM-64能表示6个比特

    ![image-20220326112438835](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220326112438835.png)

    点与x正半轴的夹角为相位偏移，点到原点的距离为幅度大小

    我们当然希望越密越好，这样我们码元所能携带的比特就越多，但太密我们又容易识别错误

## 高带宽频道复用

- 即一个频道怎么分给多个用户用

- FDM（频分复用）：把不同用户搬到不同的频率，每个用户带宽相同，这样每个用户就占着不同的频率段就不会相互打扰了

  - 两个相邻的信号之间会有一个保护带
  - ![image-20220327093418567](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220327093418567.png)

- TDM（时分复用）：就把时间均分个不用用户，每个用户交替使用

  - 同步时分复用：

    每个用户占用的时间段固定，顺序固定，就像1，2，3，1，2，3···这样发回来就按时钟发回来分用就能很容易找到对应用户

  - 异步时分复用：

    频道空闲就能用，这样发送的信息必须携带用户信息加以区分

- CDMA（码分复用）：给每个用户分配片码，发送的信息用片码处理后发给所有用户，用户再用片码处理得到的结果为1表示接收到1，结果为-1表示接收到0，结果为0表示没有接收到东西。码分复用将发送的信息变长了n倍，但也扩展了n倍频段，和其他方法相比并没有太大的效率上的差别，都是使得n个用户能同时使用的一种方法

  - 方法如下

    ![image-20220326152709492](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220326152709492.png)

- WDM（波分复用）：光纤传输时给每个用户分配不同的波长，折射进去后再折射出来就能分开了

  > 实际上波分复用就是频分复用，因为光速=波长*频率，波长就是频率

  - ![image-20220327093332490](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220327093332490.png)

## 电话网

由于突变的在短时间内的代价太高，事物的发展总要经过一个过渡的阶段，这个阶段就是电话网，用电话的本地回路来暂时替代网线，给不愿意换线的用户也可以使用网络。

- 背景

  电话在那时已经发展成了

  - 用户到电话交换局的本地回路，这个回路就是电话线，带宽约1MHZ，但为了语音服务，把带宽限在了300HZ~4000HZ，并且发送的是模拟信号
  - 电话交换局之间已经换上了光纤，可以直接发送数字信号

- 问题：

  - 高频衰减严重
  - 延迟畸变，不同频率到达时间不同
  - 噪音

下面是解决方案

### 调制解调器

- 调制解调器

  - 工作过程

    在发送，接收端加一个Modem调制解调器，发送接收时先把信号调制，把电脑发送的数字信号调制为模拟信号，发送到电话交换局后再编解码为数字信号在干线（光纤）上传送，传送到另一端的电话交换局接受这个数字信号，把数字信号解调，转为模拟信号，再通过本地回路发往目标用户，在目标用户家里用调制解调器解调，再把模拟信号转换为数字信号传给电脑（ISP是网络服务提供商，给了ISP，ISP再给用户）

    - <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220327090515136.png" alt="image-20220327090515136" style="zoom:50%;" />

  - 但速率还是很慢，前面说过了，电话线的带宽限死在了4000HZ，那根据奈奎斯特定理，波特率也就8000Bd，每个符号能表示8比特，那顶天也就64kbps
  - 但其实很多都限制在了33kbps，为什么呢？因为根据香农定理，信噪比越高，极限传输速率越高，我们两边都接本地回路，那两端都引入了噪声，那不就上不去了吗？所以我们只有一边本地回路，另一边直接接交换局的光纤的数字信号，那速率就能提升到56kbps（国际标准把一个比特用于控制了）

### ADSL

- ADSL，数字用户线（非对称数字用户线）

  之前不是说了吗，电话线带宽1MHZ，这比限制下的4000HZ要高得多，那如果能解开限制，那不就解决问题了吗？

  我们用一个分离器NID代替原来的滤波器

  - <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220327085222402.png" alt="image-20220327085222402" style="zoom: 80%;" />

  NID用上了全部带宽

  把1.1MHZ分为256个信道，每个宽4312.5HZ，信道0用于通话，信道1~5空闲，防止语音信号和数据信号相互干扰，剩下的250个信道用于网络的用户数据传输（如下图）

  - <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220327085406427.png" alt="image-20220327085406427" style="zoom: 80%;" />

  上行即上传数据，下行即下载数据，可以看出二者分配的信道是不对称的，这就是ADSL的A的含义（非对称）。因为用户一般只需要下载数据，很少上传数据

  和传输距离有关。速率大幅提升

  - <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220327091008076.png" alt="image-20220327091008076" style="zoom:50%;" />
  - 不过也已经过时了，用得比较少了

## 电话局的中继线复用问题

- 时分多路复用

  - T1载波的协议

    用于发送多路语音信号

    每125微秒发一个帧，每个帧长193比特，如下图

    <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220327101809400.png" alt="image-20220327101809400" style="zoom: 80%;" />

    > 这样看不就是24个信道轮流占用带宽吗

    第一个比特是帧码用于控制，每个信道的八个比特最后一个作为信令，其他七个传输数据
    
    125微秒193个比特，那传输速率就达到了1.544Mbps

## 交换

- <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220327103902425.png" alt="image-20220327103902425" style="zoom:67%;" />

- 电路交换：给你一条路独占，所以要建立链接（物理通路的连接），有建立连接的时间，也不能变更路线，所以发送数据的顺序不会乱，带宽也不变。按时间收费

- 包交换：发到路由先存着，选一个队列排队等着（路由帮你选，不同队列到不同的节点），前面的人用完了就到你发，所以能变更路线，所以一变线路，发送数据顺序可能会乱，带宽可能会变。还有可能对数据进行编码。按消息量收费

  - 发的消息块大的叫报文交换message switching，小的叫分组交换packet switching
  - 因为没有建立连接所以每次存储后转发都有发送延迟，排队等待时间
  - packet就是把message切割成一小块一小块**（是多线程吗）**

- 时序图

  - <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220327104109737.png" alt="image-20220327104109737" style="zoom: 80%;" />

  - <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220327104205773.png" alt="image-20220327104205773" style="zoom: 67%;" />

  - 竖着的方向是时间轴，横着的方向仅表示有这样一条传递通路，并不表示通路的长度，信息的多少
  - 从图中可以看出，有A,B,C,D四个节点。信号传输的方块都是斜着的平行四边形，而不是矩形，这是因为每一个信号发出到达下一个节点都需要时间，所以方块会向下斜一点，斜一点的时间就是传输时延
  - 从电路交换的图来看，电路交换先是呼叫对方，发送呼叫信号，经历了BC两个节点的传输（每个节点都要寻找能走的中继线，这时其实就已经在建立连接了，所以看到中间浪费了很长时间），给到了D（能给到说明连接建立完成），而D又经历了很长（只是相对而言）的时间才把接受呼叫的信息发回去，然后A和D就能源源不断地发数据了
  - 从报文交换和分组交换的图来看，二者都不需要建立连接的过程，直接就把报文或分组给下一个节点了
  - 报文交换中我们可以看到相邻两个报文之间是有时延的，这个时延就是排队的时延
  - 分组交换就是把报文分成更小份，这样的好处是什么呢？
    在报文交换时，在第一个比特传到节点时，节点就可以准备发送了，但实际上却是接收完了再发送，为什么呢？因为发送数据是一段一段发的，这样才不会需要为每一个比特加上一段比特来识别这个比特要发往那个节点或用户，只需要在包的开头加就行了。
    但我们还是想提高时间利用率，那我们就照接收就发送这个思路改进一下就好了。不能一个一个比特地发，那我们分小段点发不就好了嘛。从图中可以看出在第二个分组发到一半的时候，第一个分组就从B节点发出了（从两个第一分组的距离可以看出排队时延还是很长的），那这样其他节点的空闲时间就利用上了，时间就缩短了。从图上也能看出缩短得很明显

- 电路交换和包交换的比较

  - ![image-20220327111743947](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220327111743947.png)

  

## 物理接口

- 不想说了，没啥好写的

# 第三章：数据链路层

数据链路层做的就可完成相邻的两个机器可靠效率传输。由于相邻，所以不用考虑传输顺序问题

这一层也有面向连接，无连接，可靠（会传一个信息叫ACK,acknowledge）和不可靠的概念（不可靠不是说整个网络就不可靠了，放到其他层去帮它解决了）

所以数据链路层面向连接可靠服务会先建立连接，然后发送，然后靠返回的信息确保发送成功，但如果返回信息出问题收不到或没收到，那就要等一等，超过一定的时间就认为出问题重发，尝试若干次后就不尝试了。而接收端也可能因为返回信息出问题一直收到同一个数据段，所以每个数据段都要有序号去区分。

下面是数据链路层需要完成的服务

## 成帧（把物理层的流打包给网络层）

上层给packet，打包为帧frame，要做的就是在packet前面加一个header，后面加一个trailer(差错控制串)

### 不同的成帧方法

#### 字符计数法

- 帧的开头是个计数器，记录这个帧有多少个字符（这个计数器只是用来处理的，不是接收端想要的数据本身）


> 但这样有个巨大的问题，一旦计数器的二进制信号错了，那后面所有的信息的计数器位置都错了，那后面的信息肯定全错了

#### 填充法

我们使用特殊的序列，作为前后的边界，把这个边界填充进去，那就可以包装完了，而且就算比特错了，最多也就坏两帧，不会像计数法那样错完了

叫这个边界为界定符

下面是两种分类，实际上一个是转义序列保证帧内没有界定符，一个是从比特层次增删，保证帧内不会出现界定符

实际上二者的界定符都是一个字节大小，字节为单位还是深入人心的

##### 字符填充法（字符=char=byte）（所以你叫它字节填充法也没毛病）

- 就是在首尾用特殊字符flag表示首尾


- 但这样传送的数据段里面有flag怎么办？再用一个转义字符Esc表示后面那个字符不是flag。那数据段里有Esc怎么办？那再用一个Esc就好了


- 那发送信号错了怎么办？没事，由于一个帧是由前后flag包着，再坏也只是坏一个帧，坏不到下一个帧


> 问题就是有比较多要转义的数据段开销比较大

##### 比特填充法

规定前后填充的界定符是01111110，两个0，六个1

那帧里面出现六个1怎么办？我们让它能出现就好了，方法如下

- 数据里出现连续的5个1，即011111，那就在后面加一个0，识别是也是这样，出现连续5个1，就把后面的0认为是flag来分割为帧，把这个0丢掉就是原来的数据了


- 这样和字符填充法一样，坏也是坏两个帧，而且这样数据段就有超过5个1，可以识别出来这个地方出问题了

发的时候，先保证帧里面没有界定符，再前后套上界定符，接收时去掉界定符，再把帧里面添加的0去掉，就得到原来的数据了


> 这个方法问题在于要同步传输

#### 物理层编码违例法

- 就像4B/5B编码不能出现连续的0或连续的几个“1”，那么我们就用连续的“0”或“1”，用违例来作为flag


> 只能用于少数适用这种编码的地方

## 差错控制

对于可靠服务，就像这章开头说的，要有计时重发timer（这就是ARQ机制），也要有序列号

要做的就是检查是否丢帧，数据段是否出错

> （burst of error 的长度n指的是这么长n数据段有若干错误）

### 汉明距离

- 要检查d个错误，码表的最短汉明距离要为d+1

- 要纠错d个错误，码表的最短汉明距离要为2d+1

- 数据段比特数为m，检查码比特数r

  要纠错1个错误，则m+r+1<=$$2^r$$

### 检错码

在误码率低的情况下，出错了重传就好了，不用像纠错码一样纠错都耗费大量时间和空间

#### 奇偶校验码

- n-1位信息元，一位校验元

- 如果是奇校验，那么校验元为“0”表示信息中有奇数个“1”

  如果是偶校验，那么校验元为“0”表示信息中有偶数个“1”
  
- 偶校验就是各位数接连异或，奇校验还要在偶校验的结果上异或一个“1”

#### 校验和（checksum）

就是把数据的每一位数字加起来得到一个数字叫校验和，两边就看看校验和对不对

#### 循环冗余码-CRC（多项式码-polynomial code）

> 可以纠错，只是这里不做

- 要发送的信息**M**长m位，双方约定一个校验的二进制串叫**G(x)**，长**r**位，（最高位和最低为不能为0）。阶数为位数减一，所以G(x)的阶数为 r-1

- 操作步骤

  - 在M末尾加 r-1个“0”，变成 $$M'$$

  - $$M'$$模2除（本质上就是异或）G(x)，得到余数R，将R作为FCS（帧检验序列）填入到第一步填“0”的地方，得到一个处理好的帧$$M_0$$

  - 接受方接收了$$M_0$$，然后用$$M_0$$模2除G(x)，没有余数说明这个帧传输没有问题。有余数那就把这个帧丢掉

- 生成FCS例子

  ![image-20220326101347492](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220326101347492.png)

### 纠错码

在无码率高的情况下纠错码效率更高

#### 汉明码

一般使用的汉明码都是偶校验

![image-20220326091715211](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220326091715211.png)

![image-20220326091733509](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220326091733509.png)

![image-20220326091838936](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220326091838936.png)



## 流量控制

有基于反馈的流量控制（即接收端说不行了，要溢出来了，那发送端就慢一点），也有基于速率的的流量控制（就是百度网盘限你速的方法）

后面的协议为了实现流量控制就是让对面应答ACK是否收到，发送窗口和接收也是为了这个



## performance——行程计算

## 基本数据链路层协议

仅用于理解数据链路层

前三个是单工协议，后三个是双工滑动窗口协议

下面都是用c语言来写的

### protocol.h 头文件

- 定义的数据结构

  - ![image-20220328170536556](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220328170536556.png)

    > 可以看出网络层的数据packet成帧我们直接用 struct 的形式就可以完成了
    >
    > ```c
    > typedef enum{data,ack,nak} frame_kind;
    > //枚举类型就是生成一种结构，这种结构生成的变量从这种结构给的几个数字中选一个定义
    > //例子如下
    > frame_kind kind=data;
    > //就是让kind=0
    > //枚举类型就看起来舒服一点，并限定了这个类型的范围，在表示类型kind时比较好用而已
    > 
    > typedef struct{
    >     unsigned char data[MAX_PKT];
    > }packet;
    > //这里其实就把网络层的包给定义出来了，并且之前还把包的最大比特数MAX_PKT给出了
    > 
    > typedef struct{
    >     frame_kind kind;//告诉别人这个帧是data,还是ack,还是nak
    >     seq_nr seq;
    >     seq_nr ack;
    >     packet info;
    > }frame;
    > //这里其实就把packet打包成帧frame了
    > ```
    >
    > 

- 定义的函数

  - ![image-20220328170553363](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220328170553363.png)

    > 这里可以看出 inc(k)只是一个宏，并且执行的是  k++  的工作，并且超过上界 MAX_SEQ 归零
    >
    > MAX_SEQ在后文中给出，这里只是一个 **protocol.h** 头文件

### 乌托邦，理想协议

不会出错，不用流量控制

- ![image-20220328174053324](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220328174053324.png)

> 从网络层拿到packet给buffer，然后成帧（其实就是干了s.info=buffer，其他啥也没干，我觉得不算成帧），然后传给接收者
>
> 接收者挂起等待，等到了就从物理层获取，再传给网络层

### 无错误，停等协议

- stop-wait——停等协议：发一帧就等对面说可以发再发，这样时间利用率比较低

- ![image-20220328174302128](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220328174302128.png)

> 就乌托邦的基础上在发送方sender加一个等待wait_for_event()
>
> 在接收端receiver加一个发回ACK，就是给物理层to_physical_layer()，（其实就是把一个没初始化过的s发了回去，让wait_for_event() 停下来，跟ACK没啥关系）

### 有错误，停等协议

而这个协议其实就实现了**ARQ机制——自动重发请求机制**

首先有下面四种情况

- ![image-20220328084649599](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220328084649599.png)

> 正常，数据错误，数据丢失，ACK丢失

于是有下面的具体协议

> 错误的检验，校验由硬件去处理

- ![image-20220328174823604](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220328174823604.png)

  > 可以看到MAX_SEQ被宏定义为1，即序列号只有0和1
  >
  > 还可以看到前面定义了一个枚举类型event_type，和前面不同的是这个枚举类型里面多了几种情况，有正常到达，错误，超时。每个协议假设的情况都不一样，所以不把event_type归入protocol.h头文件的原因就是这个
  >
  > 
  >
  > 如果非frame_arrival就说明出错或超时了，就继续循环，重发这个帧
  >
  > frame_arrival了（frame_arrival只是wait_for_event()发现物理层收到s了），那还要看看是不是当前帧到达对面了（可能你发了a，但延迟很高没收到ACK，那你就重发a’，然后a的ACK到了，你就发下一帧b，然后a'的ACK也到了，那如果你的ACK没有序号，那你的b不就没接收到b的ACK就发下一个帧c过去了吗），就要对发回的s.ack和next_frame_to_send比对

  ![image-20220328175543543](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220328175543543.png)

  <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220328175523841.png" alt="image-20220328175523841"  />

> frame_arrival了还要检查是否是当前需要的帧（如果你接收没问题但发回去的ACK出问题了，对面又重发了一个，你不去识别是否为当前需要的帧就会把这个帧当新帧来用）
>
> s.ack=1-frame_expected;    这个语句干的就是把当前序列号给s.ack（**如果接收到了要的序列号的帧，那前面frame_expected就会反转，这个语句就是把frame_expected再反转一遍给s.ack，没接收到这个帧s.ack就会因为frame_expected没反转而传回去而出错**），然后to_physical_layer(&s)发回去

### 滑动窗口协议

#### slide window——滑动窗口协议

滑动窗口就是发多个帧再等对面回应，而不是一个帧，如下图

- 发送端——发送窗口

  ![image-20220329080234795](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329080234795.png)

- 接收端——接收窗口

  ![image-20220329080304030](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329080304030.png)

> 发送和接收端的窗口都可以是任意长度，这和协议定义相关
>
> 窗口只是为了让人容易理解而出现的模型，协议的实现中并不会实现具体的窗口，而是实现窗口的功能
>
> 发送窗口可以发送在窗口内的未发送的任意号帧，接收窗口可以接收窗口内的未接收任意号帧
>
> **接收窗口收到一个帧，就把这个帧给网络层，并向右移动一帧**
>
> **发送窗口收到一个ACK，就从网络层拿一个新帧，并向右移动一帧**
>
> 以上几点只是滑动窗口的定义，并不代表着能解决问题，具体协议里面解决问题

#### 捎带应答

滑动窗口协议就是全双工，可同时双方发送

但你让对面发ACK还是占全双工的信道资源

所以有捎带应答

- 我们不是要发回ACK吗，那我们发ACK占用的时间就可以用于回发

  就是让ACK等一会，和对方发回来的帧一起回来不就好了吗

  这个就是捎带应答

- 但这样又带来了ACK要等多久的问题，等太久了发不回ACK还会发送端会重发

  所以在一定时间内没有数据包来就得单独发ACK

于是讨论具体的滑动窗口协议

### 1位滑动窗口协议

这一看就觉得很像上面第三个停等协议，但差别还是挺大的

上面的停等协议只是单工的，而一位滑动窗口协议是全双工的

停等协议有发送方，接收方，一位滑动窗口协议互为接收方发送方

具体协议如下

- ![image-20220329084512252](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329084512252.png)

  > ```c
  > //首先滑动窗口协议是全双工协议，所以一个协议要既能发送也能接收
  > //即既要有发送窗口，也要有接收窗口，双方互为发送接收端
  > //所以这个协议中的
  > next_frame_to_send;
  > //发送端下一个要发送的帧的序号。表示发送窗口准备发送或已发送正等待ack的帧的序号
  > frame_expected;
  > //接收端所期待的帧的序号。表示接收窗口等待接收的帧的序号
  > buffer[];
  > //从网络层拿到的数据包的副本
  > if(r.seq==frame_expected);
  > //接收窗口，比对是否是自己需要的帧
  > if(r.ack==next_frame_to_send);
  > //发送窗口，比对返回的ACK是否正确
  > 
  > /*注意，只有接收到了对的帧，接收窗口才向后移一位；接收到了对的ack，发送窗口才向后移一位，并从网络层拿新的副本给buffer，而s.info每次循环都会取一遍buffer，所以只有接收到了对的ack，才能更新s.info即发送新的帧*/
  > 
  > s.seq = next_frame_to_send;
  > //这一句没什么好说的，下一个要发的序号给要发的帧而已
  > s.ack = 1-frame_expected;
  > //这一句就有来头了，首先，在循环外面，s.seq和s.ack的初始化无论初始化为0或1都无所谓，这一点后面来讲
  > //而在循环里面，这一句的意思是把接收窗口后移前的序号给s.ack（只有0和1两种可能，所以反转就是复原），很直白的嘛，我们的ack返回的就是你给我的序号数seq，那现在我接收到的序号seq和我期待的expected一致，expected++了，那我的ack肯定要用expected复原后传给你了
  > 
  > //现在来说为什么初始化无所谓的原因
  > //设发送端为a，接收端为b，当a.seq！=expected时，b.ack=(!expected)，所以b.ack==a.seq；当a.seq==expected时，expected++，b.ack==a.seq
  > //可以看出彼此的ack都会等于对面的seq，而每次循环seq=next_frame_to_send，都会强制seq变为next，而next在接收不到对的ack时又不会变，就会传多一次让对面的ack等于seq，这样next就会变了，而这时就都对了，所以初始化无所谓，或者说这里的初始化是为了防止开始时多传一次
  > //由上面的机制可以看出，ack不对的时候，一定是对面根本没收到或扔了我们的帧，返回了个旧帧回来，那我们重传一次就解决问题了
  > 
  > ```

但这个协议还是有点问题

如果双方同时发送，或过早超时，那就会出现如下右边的状况

- ![image-20220329173421111](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220329173421111.png)
- 可以看到每个包都被重复发了两边才拿到自己的ack，才开始发下一个包

### 回退N协议（GBN)

一帧滑动窗口带宽利用率如下

![image-20220330082603451](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220330082603451.png)

那如果我的发送窗口宽度为w，那在理想状态下（不堵塞）那利用率就可以提升到 w/(1+2BR/l)

所以GBN就是这个想法，发送窗口不停地发，如果收到一个ACK坏了，不对，丢了，那我们就回到那个ACK对应的帧那里，从那里开始重发（所以刚才发的在那个坏帧后面的帧白发了），如下图

![image-20220330083604544](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220330083604544.png)

所以当w过大时，你错一个帧就可能把w个帧都丢掉了，所以利用率并不会像上面公式那么好，信道误码率高了GBN反而利用率低

同时，当w过大，而序列号过小，那在延迟较高的情况下，你都发了两个序列号那么长了，发送窗口的头尾重叠了，发送窗口最早的ACK才来，那你怎么判断这个ACK是哪一个的呢？所以我们要限制窗口长度，记序列号比特数为n，发送窗口宽度为s，接收窗口宽度为r，$$s+r<=2^n$$（这个在后面的选择重传也受这个公式的限制的）

如果发送窗口加接收窗口长度大于序列号，如果接收窗口发回的ack全部丢失，那么发送窗口重发，而此时接收窗口已经和发送窗口重叠了，就会导致重发的东西当作新的东西交给网络层导致出错

而接收窗口宽度为1，所以当接收窗口接收到n号帧，那n前面的帧肯定接收到了

帧序号落在接收窗口之外，会发回一个NAK

于是有如下协议

- ![image-20220330084122151](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220330084122151.png)

  ![image-20220330084149413](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220330084149413.png)

  ![image-20220330084220099](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220330084220099.png)

### 选择重传协议（SR）

前面GBN发送窗口宽度大于等于1，接收窗口宽度等于1，很明显，如果前面没接收，那后面就是白发，那我们只要让接收窗口宽度大于等于1，收到在接收窗口的帧先缓存（当然这样电脑开销就大点，可以先判断是否按顺序到达了，按顺序到达就直接交到网络层就行，不用缓存了），接收窗口最前面的帧到了，就把这个帧发给网络层，接收窗口往后移，同时挑选没接收到的帧序号发回对应ACK，那不就解决问题了吗

再加一个ACK time，用来等数据包，等不到就直接发ACK



然后接收有问题就发个NAK，发一次就够了，NAK丢了对面也会重发。你发多个NAK对面还得发几个帧，然后你又丢掉，更慢了

如果发送窗口加接收窗口长度大于序列号，如果接收窗口发回的ack全部丢失，那么发送窗口重发，而此时接收窗口已经和发送窗口重叠了，就会导致重发的东西当作新的东西交给网络层导致出错

于是有以下协议

- ![image-20220406082247012](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220406082247012.png)

  ![image-20220406082324046](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220406082324046.png)

  ![image-20220406082356032](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220406082356032.png)

  ![image-20220406082411173](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220406082411173.png)

## 协议性能讨论（performance）

效率就是（在发送的时间/（在发送的时间+被阻塞的时间））

$$t_p$$为一个比特路上传播的时间，$$t_f$$为发送一个帧的时间

停等协议的效率就是$$\frac{t_f}{t_f+2t_p} $$，很明显在等发过去和ack过来

$$a=t_p/t_f$$，那停等协议的效率就是$$1/(1+2a)$$，所以a很小时，即距离很短，协议效率就很高

而在GBN中，如果“发送整个窗口的时间”>“第一个帧开始发送到其ack回来的时间”，那么就成了流水线，那协议效率就能到100%

而SR协议主要是为了解决GBN重传浪费的问题，所以在出错率很低的情况下并不能提升太多效率，反而可能由于发送，接收窗口的宽度受限于序列号（GBN接收窗口长1，而sr协议大于1，所以发送窗口相对会小），发送窗口比GBN小，效率反而降低

## 具体数据链路层协议

### PPP(Point to Point Protocol)（曾经用得极为广泛）

首先，如英文名，point to point protocol，点对点协议，这就意味着它是一对一连接的

什么意思？这个协议是早期用在电话线的，电话线大伙都会拉一条，然后连到对方的设备或者电话局

然后我们想要用电话线连接，而电话线本身不会像今天的子网一样，什么交换机，什么广播，什么大伙共用一个信道

你家的线就你和连接的另外一端独占了，自然不需要什么mac地址之类的（顺带一提，mac地址就是电子产品出厂是的id，只是以太网用了这个id作为地址，其实还是有很多其他的二层协议用了mac，但它们都不如以太网流行罢了，所以看起来二层就是以太网协议）

支持多种第三层协议（倒不如说多种三层协议收纳了它）（但也不能这么说，帧包着三层的数据，如果二层协议本身没有区别三层协议的字段，那确实不知道是什么协议），支持同步，异步，还可以和以太网，ADSL技术一起使用

ADSL关注的是怎么样让电话线可以上网，PPP关注的是两个设备怎么在沟通，从这里看出物理层就是提供物质基础，而数据链路层提供沟通方案，再往后网络层统一并为传输层打下基础，传输层完成网络的各种功能，应用层再在能正常沟通的基础上做自己想做的事情

由于ppp点到点，所以不像mac需要有冲突避免和寻址的功能，只要完成上面说的成帧（封装），差错控制，流量控制的基本功能就行，像是身份验证什么的，还有很多功能，我不想写了

以下是PPP的帧格式

![image-20220411075531465](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220411075531465.png)

protocol默认为2字节，checksum默认为2字节

可以看出，前后6个1，比特填充法成帧

然后是地址和控制字段，这两个都是固定的，看起来挺傻逼的，但是可以

- 兼容性：PPP基于HDLC，HDLC里的这两个字段是有意义的
- 灵活性（扩展性）
- 简化实现：基于HDLC的硬件或软件可以简单处理和部署

然后协议字段应该是2字节，我不知道为什么上图说1或2

然后我们可以看到payload没有一个长度指明，其实是因为我们从后往前看就能得到payload的末尾，不过MTU一般都是1500字节

然后一般的校验码都是2字节，扩展版本是4字节，这并不由某个字段指明，而是连接双方协定的（比较操蛋）

# 第四章：介质访问控制子层

前面我们数据链路层讨论的都是点对点地传输，那如果现在我们在一个广播信道，大家一起用的信道，那每个人什么时候能占用呢？（广播网络想干的就是时分复用，最好还是动态时分复用）

这时候就要有一个部件来控制了，这个就是数据链路层的子层，介质访问控制子层

下面是静态的分配的效率

![image-20220411091709457](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220411091709457.png)

![image-20220411091925956](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220411091925956.png)

可以看出用户越多，排队时间期望就越高，更何况日常网络和物理层大量数据传输不同，峰值和均值差值可能极大，峰值时更是拥堵

而我们现在就想做到动态的复用，没人用和有人用时资源都能得到充分利用

我们评价多路访问协议主要有两个指标

- 延迟
- 吞吐量，其实就是信道利用率

## 动态分配的几个假设

- **流量独立**

  彼此的帧产生无关系，且一段时间产生的帧数的期望恒定（一般用泊松模型模拟网络的突发性）。产生一帧就要等这帧发出去才能产生下一帧

  一般令帧的长度固定，只为了分析性能的时候好分析

- **单信道**

  所有站都通过一个信道接收发送数据

- **冲突可观察**

  就是我在发的时候，还收到了别的信号，这时候就检测到冲突了

  如果两个帧同时发送，称为冲突，所有的站都要能检测到冲突的发生，冲突的帧要再次发送。除了冲突，没有其他错误

  （无线网络很难检测，因为我发的时候信号强度远大于接收到的信号强度，一般都是超时作为检测）

  所以，如果我和对面同时发，但发完的时候，传输延迟太长，发完对面的信息还没过来，我不知道冲突了，这时候就会冲突检测失败，信号就乱了

- **时间连续或分槽**

  时间是连续的，每个时刻都可以发送帧

  或是分槽的，帧只能在时间槽的起点发送若干个帧

- **载波侦听或不听**

  载波侦听就是发送前看看信道是否被使用

  不听就只能盲目传送，判断该次传输是否成功

  （无线网络很难侦听）

下面我们为实现动态分配开始讨论多路访问协议

值得注意的是没有多路访问协议能保证可靠传输（第三章讨论的都是点对点的传输），总会有问题，所以要由更高层或数据链路层的其他部分去提供可靠性

下面我们说的协议更类似一种方法，而以太网是用了这些方法的具体的协议，当然现在已经很少用这些方法了，因为早期都是大伙用一条线，现在交换机每个设备都有自己专用的线路

## 多路访问协议（MAC，multiple access control)

mac地址是 media access control address，不是这里的mac

### ALOHA

#### 纯ALOHA

它的思想很简单，需要发的时候就发，发生冲突时能发现，冲突损坏后隔一段随机时间（防止双方再次冲突）再次发送

共享一个信道会冲突的系统称为**竞争系统**

下面是一个纯ALOHA的发送图

![image-20220412070912832](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220412070912832.png)

两个帧有重叠部分即称为同时发送

可以看出两个帧有一个比特在时间上重叠了都会发生冲突，这效率就很低了

##### 计算吞吐量

前面说吞吐量和带宽差不多，这里就显现出差别了，信道会因为冲突而不能发送数据，吞吐量就是算上冲突后信道的速率，带宽就是信道的极限速率

帧时：传输一个固定长度的帧所需要的时间

那一个帧什么时候会冲突呢？如下图

![image-20220412072924989](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220412072924989.png)

在$$[t_0,t_0+t],[t_0+2t,t_0+3t]$$这两个时间段产生一个帧就会冲突（刚好不冲突的情况在概率理论上视为0）

假设一个帧时内帧数期望为G，生成k帧的概率服从泊松分布

![image-20220412074643982](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220412074643982.png)

那两个时间段都产生0个帧的时候就不冲突，此时概率为$$e^{-2G}$$

则吞吐量

$$S=GP_0$$

$$S=Ge^{-2G}$$

吞吐量和负载的关系，极限时的坐标（0.5，0.184）

![image-20220412075333315](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220412075333315.png)

#### 分槽ALOHA

前面不是说什么时候想发就发吗？但这样很有可能重叠一个帧就得重发，效率太低了，于是就有了时间分槽，发送帧只能在时间槽开始时间发送，这样就不会因为一点点重叠而重发了

##### 计算吞吐量

纯ALOHA要两个时间段都不能有帧产生，现在分槽ALOHA只要一个槽内只有一个帧产生就行，此时概率为$$e^{-G}$$

那吞吐量为

$$S=Ge^{-G}$$

得到明显提升，如图，极限时坐标（1.0，0.368）

![image-20220412080140687](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220412080140687.png)

### 载波侦听多路访问协议

分槽ALOHA的效率还是不如人意，不过1/e

为什么会这样呢？因为大家都不管信道当前是否有数据，不管其他人是否发数据

那我们加一个侦听，不就能提高效率了吗？

下面介绍几个载波侦听协议

#### 坚持和非坚持CSMA（载波侦听，CSMA，carrier sense multiple access)

##### 1-坚持载波侦听

第一个侦听协议称为1-坚持载波侦听

工作原理很简单，就是要发送数据时先看看信道是否空闲，空闲就发，忙就等到它空闲。冲突的话就等一段随机时间再按上面的流程重发

1-坚持的意思是信道空闲时传送概率为1

很明显，大家都在等信道空闲的时候，信道一空闲就很容易发生冲突

而且传播延迟有很大影响。站a刚发，侦听还没传回去，站b就觉得空闲，也发了，那就会发生冲突。这里说的发生冲突的概率就和取决于信道上的帧数（我也还没弄清楚什么意思），或信道的**带宽延迟积**（bandwidth-delay product)，带宽延迟积越高，协议性能越差

当然这样性能也比之前好很多了

#### 非坚持CSMA

上面的协议不是一直侦听，一空闲就发吗？现在我不想一直侦听了，一侦听信道忙，那就等待一段随机时间再重复上述过程

性能比1-坚持CSMA更好，但延迟也更高

#### p-坚持CSMA

这里用于时间分槽的信道

发送前先侦听，空闲了就以p概率发送帧，以1-p概率推迟到下一个时间槽重复上述过程，忙就等到下一个时间槽重复上述过程。冲突时等一个随机时间再重复上述过程

下面是已讨论的协议的性能

![image-20220413083714948](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220413083714948.png)

#### 带冲突检测的CSMA（CSMA/CD）

前面发生冲突时仍会发送未发送完的帧，就很浪费，带冲突检测的CSMA就不会继续发，过一段随机时间后再尝试发

所以大家都在等信道空闲，信道一空闲就会一起发，冲突发生，然后随机时间后再次尝试，过程如下图

![image-20220413090053889](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220413090053889.png)

那一个站要多久才能检测到冲突，结束发送呢？或者说要多久没冲突信息回来才能认为这个帧可以用这个信道呢？考虑最极端的情况下，就快发到要发的站了就冲突，等冲突信号回来，已经过去了两个最长传播延迟。所以发送的帧的发送延迟不能小于两个最长传播延迟，不然就会误判，冲突了都不知道

### 无冲突协议

#### 位图协议

要发的先预约，然后按预约的站去发送，如下图

![image-20220413091140225](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220413091140225.png)

#### 令牌传递

所有站连成一个环，然后传递一个令牌（token ring），拿到令牌的就可以发送，不想发就把令牌传下去，和位图协议很像，但区别在于没有先后之分

如下图

![image-20220413120245419](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220413120245419.png)

注意，我们不需要物理连成环，只要按这个顺序在总线上传递令牌就行

#### 二进制倒计数

位图协议有个问题，一个站就占预约位置一比特，那上千个站的时候开销就很大了，令牌传递也有这个问题

所以我们用二进制数来代表站，比如站a的地址为1001，站b的地址为1010

然后，为了避免冲突，规定地址大的优先发。也就是说在多个站竞争时，地址最大的占用信道。

提炼这条规则后得到的规则是从高位到低位取每个竞争站的一位地址，全或运算在一起，若结果为1，则抽出来的那一位不为1的竞争站退出竞争，直到只剩一个站

这个协议的信道利用率为$$d/(d+log_2N)$$，设计得好，使得发送方的地址是帧的第一个字段，利用率还可以到100%

### 有限竞争协议

轻负载（竞争站点少）的时候，竞争的方法能有较低的延迟和可以接受的利用率，而重负载的时候，更少竞争的方法利用率更高（这时候延迟已经不能降低了）

所以如果我们能把竞争和非竞争的优势结合起来，那就太棒了

所以出现了有限竞争协议，轻负载和重负载用不同协议，动态分配

很明显，如果不同的站按不同的情况分配不同的占用信道的概率，也就是非对称协议，是可以提高信道利用率的

但我们先讨论一下之前按同样概率，对称协议的利用率的情况

有k个站，每个站在一个时间槽里发送的概率为p，则这个槽发送成功的概率为$$kp(1-p)^{k-1}$$，解出当$$p=1/k$$时，发送成功的概率最高，

为$$(\frac{k-1}{k})^{k-1}$$，如下图

![image-20220413125904060](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220413125904060.png)

可以看出当竞争信道的站少了，发送成功的概率就高

所以我们对所有站进行分组（组之间可以有重叠），0号组的站竞争0号时间槽，有站赢了就给它发，如果空闲或冲突，那就轮到1号组的站竞争1号时间槽，以此类推

每个组的数量并没有限制，只是数量多了冲突就很可能发生，信道利用率下降，数量少了延迟就会高（组多了，轮到后面就久）

所以我们要有能动态分配每个组的数量的方法，负载低时每个组就多点，负载高时每个组就少点，甚至一个站

#### 自适应树遍历协议

这个协议就是解决动态分配任务的方法

用树来解决，叶子节点就是站

![image-20220416165122135](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220416165122135.png)

非叶子节点可以看作子树拥有的站的集合

下面用递归算法说明

```c
//基础想法——1
int main(void){
    while(1){
        竞争(节点 1)；
    }
    return 0;
}

void 竞争(节点 a){//让节点a下的站竞争当前时间槽
    if(无冲突，即竞争成功或空闲)
        return;
    else{
        竞争(节点a的左子树);
        竞争(节点a的右子树)；
    }    
}
```

一开始先是大的分组，节点1；若冲突了就分成了小一半的分组，节点2，节点3，如此以往，就能实现动态分配分组，并且二分的方法帮我们跳过了很多大量空闲的等待的情况

但这样效率还是有点不满意，若负载很高的时候，节点1几乎必冲突，那不就是一个大分组浪费了我们的时间吗？我们直接从小分组，即深度高的节点开始不就好了吗？但这样在负载低的时候延迟又会高。

所以我们动态调整起始节点的深度不就好了吗？

现在来讨论节点深度多深合适。节点1的深度为0，节点2，3的深度为1。假设节点a深度为i，总站数为Q，则我们可以轻松得到节点a拥有的站为$$2^{-i}Q$$。假设想竞争的站的数量为q，且均匀地分布在叶子层，则每个节点竞争的站的数目为$$2^{-i}q$$。然后我们想每个节点竞争的站的期望为1，则 $$2^{-i}q=1$$ ，解得 $$i=log_2q$$ ，则我们从 $$i$$ 层的节点作为起始节点就好了

用递归算法如下

```c
//优化算法——2
int main(void){
    第i层节点的集合=起始节点计算();
    while(1){
        for(节点 a: 第i层节点的集合){
            竞争(节点 a);
        }
    }
    return 0;
}

//竞争() 同1算法
```

当然还可以有很多优化

如节点1冲突了，然后节点2空闲，那么节点3不用检测，直接进入节点3的左子树节点6，和右子树节点7，因为节点1冲突了，那肯定有两个及以上的站在竞争，然后节点2空闲，说明肯定在节点3，那你检测节点3，那很可能冲突，直接跳过就好，然后后面的节点同理

用递归算法描述如下

```c
//众多优化算法中的一种——3
//随便看看就行

//main() 同2算法，竞争()换一下参数就行

bool 竞争(节点 a,bool 左子树空闲){
    if(左子树空闲){
        bool 当前左子树空闲=竞争(节点a的左子树，false);
        竞争（节点a的右子树，当前左子树空闲);
    }
    if(空闲)
        return true;
    else if(竞争成功)
        return false;
    else{//冲突
         bool 当前左子树空闲=竞争(节点a的左子树，false);
         竞争（节点a的右子树，当前左子树空闲);
        return false;
    }
}
```

### 无线局域网协议

前面我们都是在有线的前提下讨论，现在我们来讨论无线的情况

无线局域网的每个站都是无线传播的，可以看作每个站都有一个圆形（实际上肯定不是）范围，该范围内的其他站才能和它相互传送帧，且传送帧不是单向传送，而是广播传送，所有圆形范围内的站都能收到，所以很容易冲突

前面说无线一般很难侦听冲突，因为站在发送信号的时候对方发来了接收信号，但发送信号是接收信号的上百万倍，而我们的冲突检测的方法是多个信号叠加会增大幅值，加一个越界就报警的装置就行，但这里发送信号和接收信号差得太大，基本上做不到检测，做到了也要付出极大的代价，那这时你发送时就没法接收了，就是冲突了你也不能检测出来

另外无线还有问题就是侦听问题，有线侦听看看信道有没有信号就好了，无线侦听看的是圆形范围内的站是否在发送信号。

这就有很多问题，比如a站和c站都想给b站发帧，它两一听，彼此都不在对方侦听范围之内，都觉得没人发给b站，就都发了，那这到了b站，b站一收就发现冲突了，那不就白侦听了吗？（如下图a）称为隐藏终端问题

又比如b站发给a站，然后c站想发给d站，c站一听b站在发，就觉得信道占用，就不发给d站，这不纯nt吗？（如下图b）称为暴露终端问题

![image-20220416222232828](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220416222232828.png)

于是有以下协议

#### 冲突避免多路访问协议（MACA，multiple access with collision avoidance)

这个协议的思路是双方和周边说一声自己要说话了，要听了，叫自己周边的人静一静去避免冲突

a站想向b站发帧，那先发一个短帧(30字节，包含接下来要发的帧的长度)，叫RTS（request to send），b站收到了再回一个CTS（clear to send，也包含了数据长度，从RTS中复制来的）应答，a站收到CTS就开始发送

那在a站圆形范围的站，收到RTS就知道有站要发了，要接收CTS了，那就要沉默，不能发任何信号，等足够长的时间让a站能接收到CTS，过了这个时间想怎么发怎么发，a站发送信号远大于接收信号，无视你们发送的任何信号

在b站圆形范围的站，收到CTS帧就知道有站要接收帧了，那它们就要等这个帧的传送时间（根据CTS的数据长度推算）之后才能发送帧

如下图

![image-20220416230230107](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220416230230107.png)

当然这样还是没法避免所有冲突，c站，e站可能同时发RTS给a站，这时候a站就能冲突检测出来（只检测接收信号还是能检测出来冲突的），那a站就不会发送CST，c,e站收不到CST，那就过一个随机时间再向a站发出请求

## 以太网

IEEE制定了很多标准，802是一组标准的名字，负责局域网和广域网的标准，有以下这些子标准

802.3（以太网），802.11（无线局域网），802.16（无线城域网）

“以太网”和“IEEE 802.3”两个协议几乎一致，就差了一点点，所以后面会交替使用二者

填充的作用就是防止发太快冲突误判

### 经典以太网物理层

用电缆连着连着所有的计算机，每段电缆都有最大长度限制，超过这个限制信号无法传播（粗的电缆500米，细的185米），且每段电缆都有连接计算机数目上限（粗的100个，细的30个）。

所以建更大的局域网时，用中继器（将信号接收，放大，重发）将多条电缆连接

信息发送用曼切斯特编码

但两个接收端距离不能超过2.5千米，任意两个接收端之间中继器不能超过4个（为保证协议正常工作）。

### 经典以太网MAC子层协议

半双工

帧格式如下

首先，前导码的长度在以太网协议里面不算帧长，在802.11 wifi里就算，比较傻逼，然后有效帧长最短64字节

![image-20220420082041712](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220420082041712.png)

![image-20230827131733343](%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0.assets/image-20230827131733343.png)

前导码：前7个字节，每个字节是10101010，这个就是曼切斯特编码的10MHz的方波，用来时钟同步的。最后一个字节和前面一样，只是最后两位为11，用来作为起始定界符SoF（start of frame），告诉帧开始了（实际上就是填充法，里面会保证没有界定符SoF，而界定符前面的7个字节会被认为是前导码）

地址就是mac地址，所以是48位，6字节

mac地址第一位用于区分单播组播，0即单播，1即组播，则没有设备的mac开头是1。而全1的地址表示广播

~~目标地址：第一位bit是0，那这个地址就是一个接收端的地址；为1，那么这个地址就是一组接收端的组地址，组内所有的站都能接收到，叫组播。全1的地址是给所有站发，叫广播~~

~~源地址：一台设备的编号，唯一。前三个字节（组织唯一标识符，OUI，organizationally unique identifier）由IEEE分配，标识了网络设备制造商。后三个字节由制造这台设备的制造商分配~~

（网络层协议）类型/长度：表示哪个取决于是以太网帧还是IEEE802.3帧。一个机器可能会用多种网络层协议，类型告诉机器用哪个网络层协议处理。长度就是帧长度，这样当然不能确定用哪个协议处理，但这个由逻辑链路控制协议处理。

数据：在范围内的长度都行

填充：防止过短冲突检测出错（也可以用过短来区分垃圾数据和有效帧）。有效帧至少64字节（不算前导码，从目标地址开始到校验和结束，共18个肯定要填的字节），所以填充最多为46字节

校验和：就是CRC的校验码，仅检错。仅校验有效帧部分

### 二进制指数后退的CSMA/CD

第一次冲突后，每个站随机等待0或1个时间槽，第二次冲突，每个站随机等待0，1，2，3个时间槽……第i次冲突，每个站随机等待0~$$2^i-1$$个时间槽。第10次冲突后不再增加等待范围，第16次冲突后放弃努力，返回失败报告。恢复工作由高层协议完成

### 以太网性能

用二进制指数退避的算法分析性能太复杂了，我们还是按之前的方法来分析

**下面的计算连极限都算错了，先别看了**

设每个站想发帧时抢夺时间槽的概率为p，此时有k个站想发帧，则抢成功（只有一个站竞争）的概率为A

> $$A=kp(1-p)^{k-1}$$ 								(1)

当$$k\rightarrow\infty，A\rightarrow1/e$$

抢成功的概率为A，那要抢几个时间槽才能抢成功呢？竞争 j 个时间槽竞争成功的概率为

> $$jA(1-A)^{j-1}$$

则竞争时间槽数的期望为

> $$\sum^\infty_{j=0}jA(1-A)^{j-1}=\frac{1}{A}$$					(2)

之前说过，为了检测冲突，发下一个帧的时间必须大于一个帧到达目的地的最大时间$$\tau$$的两倍，即$$2\tau$$

所以每个时间槽的间隔时间为$$2\tau$$，所以平均竞争时间 w 为 $$2\tau/A$$，所以w最多为$$2e\tau$$

设传送一帧平均要P秒，此时的信道效率为

> 信道效率=$$\frac{P}{P+2\tau/A}$$ 								(3)

设帧长度F，网络带宽B，电缆长度L，信号传播速度c

则$$P=F/B$$，$$\tau=L/c$$，并以最低概率$$A=1/e$$（无限个站竞争）计算，则信道效率为

> 信道效率=$$\frac{1}{1+2BLe/(cF)}$$ 						（4）

所以可以看到，当带宽或距离增大时，效率就会下降，但我们的需求就是要增大它两，我们能做的就只剩下增长帧长度了，效率如下图

![image-20220426151743233](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220426151743233.png)

但帧越长，越容易出错，所以这也是需要我们权衡的地方

### 交换式以太网

之前不是用一个电缆连起来吗？这样电缆一断或松动就出老多问题。所以我们换种连接方式

我们用一个集线器把所有站连起来，或者通过交换机传递

![image-20220420092709290](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220420092709290.png)

集线器的线就是电线，就是电话的双绞线，但线长不能大于100米（高品质可以200米），这样哪里坏了也很容易检测出来

但集线器并不能提高带宽，集线器的带宽有上限，可以看作若干条线进，一条线出，那这样在站多了或者服务器增长，很快会饱和

解决办法就是交换机，交换机干的是把帧传到想去的端口，而不是集中到一起才发。那多个站都要发怎么办？集线器中所有站位于同一个冲突域，所以要用CSMA/CD解决冲突，但交换机是全双工的，每个端口都有自己独立的冲突域，不会冲突，那就不需要CSMA/CD解决（即全双工不需要使用CSMA/CD，这个是给半双工使用的）

但如果两个站发的帧要去同一个地方，还是会冲突 的，所以这两个帧要缓冲排队

而且这样还有利于安全。大多数LAN接口都支持混杂模式，即把帧发给每一台计算机，这样练到集线器上的计算机都能看到其他所有计算机的信息，但交换机精准传送，不会轻易地泄露出去。当然，要安全还是对流量进行加密

![image-20220420101305287](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220420101305287.png)

当然交换机也可以连集线器，但随着交换机的成本的下降，集线器快消失了

### 快速（高速）以太网（百兆）（100BASE-T以太网）

随着交换机的火热，原来10Mbps的以太网备受压力，所以制定了快速以太网，在保留原来工作方式的前提下，让它运行得更快，这就是802.3u，准确的来说这个不是一个新标准，而是原来802.3的一个补充（也加强了它的向后兼容性）。大家都叫它快速以太网，所以我们也这么叫

那怎么加快呢？很简单，其他不变，只是把一个比特的时间从100ns降到10ns，然后把电缆的最大长度降低到十分之一，以便检测冲突。

支持全双工，半双工

然而由于现实双绞线已经布置了很多了，所以快速以太网系统使用集线器和交换机，而不允许使用带插入式分接头合伙BNC连接器的多支路电缆

那还有很多线可以选择，选择哪些线作为传输呢？3类双绞线分布广泛，几乎每个西方国家的办公室都有至少4组，能低成本使用快速以太网，但缺点是不能在100米长时承载100Mbps的信号；而5类双绞线就很容易100Mbps走100米，光纤可以走得更远，所以有以下三种方案

![image-20220425080735822](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220425080735822.png)

3类UTP有25MHz的速度，只比标准以太网快25%（曼切斯特编码两个时钟周期属实难提升），那怎么提高到这个速度呢？用4对双绞线，一对去集线器，一对来自集线器，剩下两对动态切换传输方向，那这样为了得到高速就需要很复杂的编码。4对双绞线就意味着你办公室的电话线就没线用了

5类UTP比3类简单多了，很快代替了3类。因为5类可以处理125MHz的时钟，所以简单多了。每个站只用了两对双绞线，一对发到集线器，一对接收集线器。这里不用二进制编码（NRZ），也不用曼切斯特，它用4B/5B编码，这样125MHz就能发100Mbps的数据

最后光纤方案，用两根多模光纤，两个方向用一根，实现全双工

提高速率后，最小帧长和最大电缆长度的关系也要改变。要么最小帧长提高，要么2500米的电缆长度降低

### 千兆以太网

其他不变，就是把速率提升了10倍

支持全双工和半双工，全双工常用于交换机，半双工（有冲突检测）用于集线器

但由于传输速率太快了，冲突检测（冲突检测就意味着多个站共享信道，竞争信道，点到点交换就不需要考虑下面的问题了）的话线缆长度得降100倍，也就是25米，这太不实用了。所以我们加入两个特性。

- 第一个，载波扩充（carrier extension），用硬件在普通帧后加填充位，加到512字节，并由接收方的硬件删除。当然这样线路效率就大幅下降了。
- 第二个，帧突发（frame bursting），让发送方一次发多个帧就好了，若仍小于512字节，仍会填充字节。这个方案就很好用了



同上，线缆一样有多种

![image-20220425083553523](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220425083553523.png)

1000Base-SX(短波)，1000Base-LX(长波)，只是波长不同

编码方式用8B/10B，使得0和1的数目平衡，这样就能直接用NRZ，只浪费了25%，而不像曼切斯特浪费100%

人们肯定是不想换线去提升网速的，那我们就要在原先的5类UTP的基础上改进。四对双绞线都要用上，每对都可同时在两个方向传输，用数字信号处理技术区分信号。还有很多改变，不想写了

1Gbps很快，没有流量控制就寄了。要暂停一段时间就发一个PAUSE暂停控制帧，暂停时间是最小帧时的整数倍。千兆以太网，时间单位为512ns，允许最大暂停时间为33.6ms

后面还扩展了巨型帧，允许帧长超过1500字节，高达9KB，这个没有得到标准认可，所以也不能和早期以太网兼容，但很多厂商支持这个扩展，因为这样能处理得更快

### 万兆以太网

802委员会的人无聊找事干做的标准

主要用于数据中心和交换局内部。长距离连接用光纤，短距离铜缆光纤都行

只支持全双工，CSMA/CD不是设计的一部分

有以下几种线缆

![image-20220425085239016](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220425085239016.png)

0.85微米用于中距离，1.3微米和1.5微米（扩展）用于长距离。用64B/66B，这样开销就更少了

铜缆10GBase-CX4用四队同轴电缆，每对用8B/10B，3.125G符号/秒运行，提供10Gbps数据率

10GBase-T用电缆，虽然说用6a类UTP，但也可以用于5类电缆。四对双绞线都用上了，每对两个方向上2500Mbps速率发，这样要有800符号/秒的速率，每个符号有16个电压等级。用低密度奇偶校验码保护，再进一步纠错编码

### 无线局域网

主要标准是802.11

#### 802.11体系结构和协议栈

分布式系统：客户端（电脑或手机）接入网络，即和接入点AP（access point）关联，AP再接入到分布式系统的有线网络连接，如下图

![image-20220425091538729](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220425091538729.png)

自组织网络：计算机之间互相连接，互相传帧。这里没有接入点，所以可以理解为连不上网，所以没有那么受欢迎。如下图

![image-20220425091721519](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220425091721519.png)

来看看协议栈吧，就是802.11的协议的组成

![image-20220425162837314](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220425162837314.png)

MAC层决定信道分配，在上一层就是逻辑链路层（LLC，logical link control）子层，作用是把不同的802.11的协议（可以看到物理层有多种802.11协议）的不同隐藏起来，给网络层一个统一的接口

#### 802.11物理层

不想写了

#### 802.11MAC子层协议

##### 物理侦听

像之前说的，无线几乎是半双工的，不能同时发送和接收，且冲突检测几乎不可行

所以协议设计都是冲突避免的方式设计的，叫带有冲突避免的CSMA（CSMA/CA，CSMA with collision avoidance），侦听信道，忙时指数后退，发生冲突，即发出的帧超时未收到回复，指数后退，再重新发送，直到重传最大次数。发送帧时，要随机后退，然后开始，这样就避免信道一闲就一堆人抢，冲突又浪费掉了。如图

![image-20220425164812471](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220425164812471.png)

> 物理侦听

这种分配的模式称为分布式协调功能（DCF，distributed coordination function)，意思是每个站都独立行事，没有中央调控。还有一个对应的模式，叫点协调功能（PCF，point coordination function)，即AP控制自己覆盖范围的活动

##### 虚拟侦听

和之前的问题一样，隐藏终端和暴露终端问题依然存在，和之前的想法一样，我们发和收时都告诉自己覆盖范围内的站自己要发/收了，叫它们静一静。那接收到这个信号的站就要保存这个信息，估算要安静多久，这个就是网络分配向量（NAV，network allocation vector）。而之前说的RTS，CTS就是其中的一种机制。

但这里的RTS，CTS和之前的MACA里的RTS，CTS还不同，因为MACA里不需要返回ACK，而这里要，所以接收到RTS的站不能等收到CTS后就随便发，因为不能干扰了ACK的接收，这就意味着暴露终端的问题不能解决

A站发送RTS，B站收到RTS回发一个CTS，A站收到CTS开始发帧并启动计时器，收到RTS，CTS的站估算要等多久，记录在自己的NAV上，这些站接收到ACK后就结束等待。如图

![image-20220425170653747](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220425170653747.png)

> 虚拟侦听

RTS/CTS机制听起来很好用，但真不行。首先当帧很短时没用，其次降低了操作速度，其次不能解决暴露终端的问题（别的站在发不意味着你不能发，但这个机制下你就不能发）

物理侦听和虚拟侦听是802.11的核心，但还有几个相关的机制，下面我们讲一下

##### 可靠性

无线环境嘈杂且不可靠，很容易受干扰，那怎么办?

策略一，降低传输速率，这样可以用更健壮的调制解调计数

策略二，发送短帧，即帧越短，帧出错的机率就越低。802.11可以把帧拆成更小的单元——段（fragment），每段都有自己的校验和，长度不定，由AP调配。每个段都有编号，用停等协议进行确认。可以发的时候一次发多个段，由于停等，段与段之间是ACK。

##### 节电能力

用信标帧（beacon frames）机制节电。信标帧由AP定期广播，和覆盖范围内的站通告AP的存在，并传递一些系统参数，如AP的表示，下一帧多久以后到，和安全设置

客户端发给AP的帧有个电源管理位，告诉AP自己进入**省电模式**（power-save mode）了。这个模式下，用户可以不听了，AP缓冲所有发给用户的流量。用户在信标帧来时醒，并通过信标帧得知是否有为他缓冲的流量，如果有，那么客户端发给AP一个poll信息，叫AP把缓存的流量吐出来，接收了缓存的流量后，客户端再回去打盹，直到下一个信标帧发送过来时苏醒

还有另外的省电机制，叫**自动省电交付**（APSD，automatic power save delivery），其他都和省电模式一样，就是不再是信标帧发送时醒过来，而是客户端需要的时候（想发或想收的时候）发一个帧给AP才将缓存的帧给客户端，这样一来就能安心睡了。

##### 服务质量

在我们想保证一个流量的正常需要，不受其他流量挤占而让一个流量优先于其他流量时，怎么办？

方法的标准就叫802.11e，扩展了CSMA/CA。一个帧发出后，需要保持一段特定时间 “m” 的空闲，已检查信道不在被用，然后任何站才能发帧，而我们优先的方法就在于让不同帧的 “m” 的时间不同，如图

![image-20220425213153294](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220425213153294.png)

不加优先级的正常的帧之间的间隔称为DCF帧间隔（DFC帧间隔也被称为DIFS，DCF interFrame spacing）（图中的第三阶的间隔），任何站都可以在DIFS结束那个时间点竞争，冲突就二进制指数后退就行

最短的间隔称为短帧间间隔（SIFS，short interFrame spacing）（图中第一阶），这个时间点用来发ACK，RTS，CTS等控制帧序列，或一系列的段

两个仲裁帧间空间（AIFS，arbitration interFrame space）（图中的第二阶AIFS1，第四阶AIFS4），AIFS1结束时我们就可以发优先级高的帧，AIFS4结束时我们发的是优先级低的帧

最后一个时间间隔是扩展帧间间隔（EIFS，extended interFrame spacing），仅用于一个站接收到坏帧或未知帧的报告问题。一个站收到这些东西可能不知道怎么处理，所以我们等一段时间后，把它们放到最后，防止站处理它们影响了正常的对话



然后服务质量还有**TXOP**或者**传输机会**的概念

CSMA/CA允许一次发一帧（无线信道检测冲突只能靠发回来的ACK），但这样低速站发回ACK给高速站就比高速站想要的速率慢得多，这样就拖累了高速站

所以我们用传输机会的概念，每个站得到等量的通话时间，而不是相同数量的帧，这样就能把速率大幅提升（虽然低速站因为一半的时间分给了高速站，速率只有原来的一半，但高速站也能到原来的一半，比原来的吞吐量高多了）

就比如一个A站6Mbps，B站，C站都是54Mbps

- 如果是大家轮流，一人发一帧，设B，C站发一帧的时间为t，那么A站发一帧的时间就是9t，那么A站占总发送时间（9t /11t)，速率为（6\*（9/11））Mbps，而B，C站速率就为（54\*（1/11））Mbps
- 如果是大家各占一段时间，则A站速率为（6\*（1/3））Mbps，B，C站速率为（54\*（1/3））Mbps



#### 802.11帧结构

定义了三种帧，数据帧，控制帧，管理帧，每种帧都有一个头，包含了MAC子层的相关字段

下面我们只讨论数据帧

![image-20220425221520381](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220425221520381.png)

> 第一行是帧的整体结构，单位是字节，第二行是对帧头的具体呈现，单位是比特

**帧控制字段的子字段如下**

协议版本：表明该帧的协议版本是哪个

类型字段：数据帧，控制帧，管理帧

子类型：RTS，CTS

去往，来自DS：发送到AP或来自AP

更多段：表明发送方还发了很多段，记得接收

重传：表明该帧是以前某帧的重传

电源管理：表明发送方进入节能模式

更多数据：表明后面还有很多帧要发给接收方

受保护的：表明帧体已被加密

顺序：表明希望接收方高层严格按照顺序处理帧序列

**持续时间**：告诉别人本帧和其确认帧回占用信道多长时间

**地址**：可以看到有三个地址字段，发往AP或从AP接收的帧有3个地址，第一个是接收方地址，第二个是发送方地址，第三个是网络接入点的地址（可以理解为路由器的地址）（和AP不同，AP是只是中继，只是个热点，把数据传来传去而已，没有地址，网络接入点是真正提供网络的地方）

**序号**：和第三章的序号是同样的意义

**数据**：真正记录数据的字段叫有效载荷，最长2321字节，有效载荷前面的部分字节给逻辑链路层（LLC）处理，这样就能多个协议同时使用了

**帧校验序列**：CRC



## 数据链路层交换

如果我们有多个局域网，那如果我们能把多个局域网连在一起不是更方便？

事实上，我们用网桥（bridge）来连接局域网，而我们之前说的以太网交换机是网桥的现代名称，我们交替使用两个名字

### 网桥的使用/交换机交换算法

下面我们列举三个要用网桥的理由

- 第一，许多大学和公司都有自己的LAN，不同部门用不同的LAN，那么迟早要用网桥相互沟通
- 第二，一栋楼组件一个LAN，然后再通过网桥或光纤链路将LAN连起来更实惠
- 第三，单个LAN的负载可能会过大，那么我们就把它分为多个LAN，用网桥连接就行。当然，连接到网桥上的站越多，平均分得的流量越少

网桥连接两个局域网时，为保证每个局域网全速运行，关键是不往不需要去的节点发送流量，即有些节点出错了，一直发垃圾流量，这些流量不经过过滤将会堵住整个网络，而网桥就是防火门

为了获得以上好处，网桥应该是透明的，即什么都不用做，即插即用，拔了也不会对网络整体有影响

那怎么做到网桥透明呢？需要两种算法：**后向学习算法**，用来阻止不需要发送的流量（后面的介绍看起来不是用来阻止的，而是用来构建起端口和站的转发映射的），**生成树算法**，用来打破随便连接形成的环路

#### 学习网桥

两个局域网连接有两种拓扑结构

![image-20220426072551472](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220426072551472.png)

左侧就是直接将两个局域网的总线连在一起（多点电缆结构），右侧就是端口连接的都是站或集线器（点到点线缆和交换机结构）

所有连在网桥同一端口的站属于同一冲突域，不同端口不同冲突域

当网桥接收帧的时候，网桥根据帧的目标地址决定转发或丢弃该帧。如果该帧的目标地址就是从它要去的端口传来的，那就丢弃，如果不是，那就转发到它要去的端口

那怎么做到这一点呢？简单的方法就是建一个大哈希表，列出了每个站隶属的输出端口。那第一次接入网络的时候，怎么建立哈希表呢？用**泛洪算法**（flooding algorithm）：对于每个发向未知地址的帧，网桥至少知道了输入端口和该帧的源地址的映射关系，然后网桥把它发到所有端口（除了它输入的端口），这样随着时间推移，网桥将会建立起哈希表，不再泛洪

**后向学习算法**

正如上面说的，进来一个帧，就知道发该帧的站和端口的关系

那打开，关闭，移动网桥，站的时候，网络的拓扑结构就会发生变化，怎么办？如果一个帧的源地址被网桥接收，那么网桥就会更新该地址的帧最近到达的时间。网桥有个进程，每隔几分钟就会清除一遍几分钟以前的端口和站的对应关系，这样不论网络结构怎么变，几分钟后总能恢复正常。当然这也意味着如果一个站静止了几分钟，那任何发给它的流量都会泛洪，直到它发下一帧为止

总结一下转发流程就是

![image-20220426081522083](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220426081522083.png)

所以网桥在看到MAC地址时就知道该发往哪个端口了，那就算帧还没发完，网桥都可以开始转发了，这种转发方式称为直通式交换（cut-through switching）或虫孔路由（wormhole routing），而根据地址判断转发这一步通常由硬件处理。这里带来的一个问题是两个端口的速率需要匹配，不然一个发很快另一个发不过来就完了，这样就需要存储转发过程了



下面我们来看看网桥的协议栈

![image-20220426082304675](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220426082304675.png)

好吧，没什么要讲的

#### 生成树网桥

为提高可靠性，网桥之间可以使用冗余链路，即用两条线路连接两个网桥，如图

![image-20220426084337878](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220426084337878.png)

那这带来一个问题，如果A站发了一个未记录的帧，那就会泛洪，而冗余链路又带来了回路，泛洪就在这个回路来来回回，那就寄了

那我们只要把形成回路的路径看作不能通过的就好了

那哪些路径应该被看作可以通过的，哪些不可以呢？

这就用到了生成树算法了

我们知道，树是没有回路的，那如果我们能从一个站开始，生成一颗树，把各个站连接在一起，那这样不就没有回路了嘛

我们使用的算法是分布式的，每个网桥周期性地广播配置信息给它的网桥邻居，同时处理其他网桥的信息

首先全体网桥需要确定哪个网桥作为树的根。每个网桥都有网卡制造商预先给它设置好的MAC地址，独一无二，而网桥标识符就是基于MAC地址的。全体网桥选择最低标识符（是指MAC地址那串数字最小吗）的网桥作为根，经过足够的信息交换，最终全体网桥同意它作为根

然后从根开始构造最短路径树（最短就是指跳跃次数最少），若一个网桥从根到这个网桥的最短路径有多条，那么选标识符更低的那一条

构建起最短路径时，网桥会记录自己到根的距离和到根的最短路径，然后关闭不属于最短路径的端口

之后就算建立起了生成树，网络正常运行过程种该算法依旧要执行，以检测拓扑结构的变化，及时更新



### 中继器(repeater)，集线器(hub)，网桥(bridge)，交换机(switch)，路由器(router)和网关

![image-20220427083632797](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220427083632797.png)

不同的层次处理数据不同

中继器和集线器都是物理层的器件

中继器只是将接收的电信号放大后发出去而已

集线器只是将接入的线连到同一根线上，冲突检测什么的和把线都连在一起一模一样

网桥和交换机都是数据链路层的器件，甚至可以说是同一个东西

网桥最初设计是为了连接不同种类的局域网，但重整帧格式，计算新的校验和，最大帧长不同，不同网络有不同的安全性和服务质量，这些问题都无法很好解决，所以把连接不同网络交到下一层去处理，由路由器去连接不同类型的网络

网桥比集线器更好，因为网桥有端口的概念，每个端口能连接不同的速度甚至不同的网络，冲突减少。但这样带来一个问题，一个1000M的以太网向10M以太网倾泻比特流，那转发不过来，缓存已经满了的时候，那么后面的帧就会被丢弃掉。即使所有的端口速度都相同，这个问题依旧存在，因为可能多个端口向一个端口发

交换机只是现代网桥的另一个称呼。此外，现代交换机都使用点到点链接，不像以前把计算机全连到一根线上，再把这根线连到网桥上（以前端口数比较少）

路由器和之前的不一样，它接收的东西已经没有帧头了，它通过数据包的数据包头去找线路，并且实现找快的线路和线路负荷均衡

传输网关就是将不同的协议的计算机连接起来

应用网关就是将数据的格式和内容转换为另一种格式

“网关”就是指高层次的转发进程

或者说上面的东西都是发一些东西，只是有一部分没有转发的功能

### 虚拟局域网

用虚拟局域网的原因

- 广播风暴：广播帧会发给每一个用户，这样CPU就会浪费大量的资源在抛弃这些帧。更麻烦的是，如果网络接口崩溃或错误配置后，就会产生无休止的广播帧流，整个LAN的缓存都会满了，所有连入的设备都会忙于处理这些无关的帧
- 安全问题：病毒攻击交换机使得交换机瘫痪而把流量全部广播出去，这样就能知道你发了什么了
- 最主要的就是我们想管理接入局域网的设备，能把它们分组，而不用顾及它们是不是接在同一个LAN上面

什么叫虚拟局域网呢？简单来说我们转发的依据不是发了就转，不是按现实的端口分组去转，而是按人们的分组，用软件的逻辑去分组，只转发给自己组的站，**即便这些站处于不同端口，这样就算连在同一个交换机上，处于同一个局域网下，看起来也构建起来了多个局域网**

首先这是在交换机下完成的，是交换机不给你转发了，也就意味着我发一个东西给和我在同一物理局域网下的不同vlan的主机，交换机不帮你转发了，那你就看起来跨局域网了，必须借助网络层的路由器帮你转了

#### IEEE 802.1Q标准

那我们想实现VLAN，那我们就要在帧里面加一个字段，让网桥知道这个帧属于哪个VLAN，但以太网已经没有空闲字段留给VLAN了

但令人惊讶的是，**委员会决定改了以太网的帧头，并制定了IEEE 802.1Q**，那就会出现很多问题

- 以太网卡怎么办？
- 如果不换这些网卡，谁生成新的字段？
- 哪些已经到达最大长度的帧怎么办？

这些问题解决的关键在于使用VLAN字段的只有交换机和网桥

**那么我们只要在第一个感知到要加VLAN字段的支持VLAN交换机加入这个字段，在出了支持VLAN交换机就把这个字段删除就好了**（MPLS，多协议标签交换也是这样做的，就加速了中间支持这个协议的网络即可），最大长度也改为支持VLAN的交换机最大长度为1522字节，原来的交换机还是只支持1518字节就好了

所以插了标签后需要重新计算FCS

![image-20230827171354539](%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0.assets/image-20230827171354539.png)

![image-20230827171536129](%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0.assets/image-20230827171536129.png)

并且这个标签虽然是2字节，但只有12位是vid，即虚拟局域网的id

值得注意的是802.1Q的**分组的单位是端口**，也就是说用集线器连起来的一组计算机只能是同一组的，每个都用点对点连接的LAN就没有这个问题。网桥可以用更高层的协议来分组，这个要根据它带的IP数据包，或PPP帧去制定。当然其他方法也行，但没有802.1Q的支持

然后vlan的vid并不是主机知道，而是**只有交换机知道vid**，并且vlan是人为划分的，所以也是需要人为配置的

vlan提供的是服务，并不是新型局域网

#### 802.1Q帧结构

![image-20220428101703542](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220428101703542.png)

# 第五章——网络层

## 一些杂七杂八要注意的

全1的ip地址是广播地址，但是是局域网内广播，我感觉就是在数据链路层的广播mac上套层皮

## 网络层的整体想法

我们在数据链路层已经实现了局域网了，但这还不算真正的网络，因为每个局域网的协议并不统一，有些是Eth，有些是802.11，还有很多很多。但无论如何我们都想让所有局域网都能相互通信，那不同的协议的协议之间通信只有两个想法了：

1. 每两个协议之间商量好怎么相互转化，协议头怎么改，最大数据是多少，但这样还是会出现数据部分不够分，无法转换的问题。而且每两个协议之间都得有转化的协议，这太麻烦了。
2. 所以我们有了这个想法，每个协议都转成同一个协议，再由这个协议转成各种协议。但这样不还是要转吗？那我们就再升级一下想法，咱们不转了，用分层的思想，直接把转协议头变成把数据打包成一个统一的协议，装在我们原来的协议里面，传给高层的时候，底层自然会解包得到我们的统一的协议，然后高层就能处理统一的协议了，不用想着怎么进行协议转化了，这个协议，就叫IP（internet protocol)，这个就是网络层的协议，目的就是为了统一这些不同的协议，让高层能只对一个协议进行处理，让下层透明

那统一协议，最大数据长度的问题怎么解决？所以我们需要有分片的能力，把数据段分成小片，这样就能发了

那我们现在统一协议了，把各个局域网连在一起了，那怎么找到别人，和别人通信呢？不能通信的话，肯定不叫连在一起吧。那说明IP层还得肩负起给每个人取名字，而且不能重名，而且还要在茫茫人海中快速地找到他的能力，然后把自己肚子里装的货（高层要传输的数据）交给他。

那么取名字，这就是IP地址，现在有IPv4和IPv6种IP地址，为什么呢？因为IPv4的地址开始弄得太小了，现在不够全球人用，而且当初设计时的有些毛病，所以升级成了IPv6，但IPv4因为用户太庞大了，所以一时半会消除不了（你编程都不愿意处理IPv6）

那快速找到呢？这就是路由算法，我们要找到一个人，就去到他所在的路由，我们后面会介绍泛洪算法，DV算法，链路状态算法，但你会发现，和你在离散学的感觉一样，这些算法在网络规模太大的情况下，找到最短路径的代价都会极为高昂，所以我们又有了分层路由的想法，就把路由器之间的连接弄成一堆一堆，几个一堆又可以凑成一层，一堆之内用路由算法的代价不会太高。就像你在现实中要去一个地方，你肯定是先最短路径去这个地方的省，再在省内用最短路径去哪个地方的市，到了那个市再用最短路径去那个县，在县内再用最短路径到你找的地方，那这样每次你用最短路径时的规模都很小，那代价就很小，这就是分层路由的想法

但做完这些后还是有些问题。我们的网络无论如何都做不到百分百没有错误，也不能保证连接不会哪天就被人挖断或者炸烂了，那我们又不可能说像数据链路层有个错误检测（检测得到的信息也是不可靠的，可能会传不到的），所以网络层的都是无连接不可靠的，尽力而为给你传送到的

那我们如果有些必须要确保送达的信息（如路由器之间交换拓扑结构的包，后面的链路状态路由算法会提到），那就必须有超时重传的技术。那问题是网络层不像数据链路层就一条信道，网路层有很多路由，有很多路径选择，数据包在跳（hop）的时候还得在路由器里面排队，那这延时就难以保证了，那天有个包排了贼鸡巴久才发到目的地，结果发现发送端早就认为超时了重传了，重传的包走的路径还和之前不同（路由算法都是动态的），走得更快，早就到目的地了，那接收端怎么区别两个包？所以这种包要有ID，我们用源路由器的名字和ID组成一个标识对，这样就能知道某个路由器发来的包是否重复了。ID的空间足够长，能保证在一段时间内（包传送的目的地的时间），包的数量不会马上用完ID导致ID从头开始用，导致ID重复，接收端不能辨认是否是同一个包就行。而且为了解决包在路由器停机，网络逗留，包错误等等问题，我们还需要给每个包加上生命期，超过生命期了说明这个包的来源，对应的路由器炸了

但除了ID的问题，重传还有个问题，那就是拥塞。你的包在排队，排了很久，你就会超时重传，那每个人都超时重传，那么排队的包就会更多，那就还得超时重传，那网络里就有大量重复的包，吞吐率急剧下降。那当路由器的内存用光了，排不了队了怎么办？那只能扔包了，那扔包了久更多人超时重传了，最后可能整个网络都瘫掉了。所以我们需要拥塞控制，就是让每个人别乱鸡巴发，准备拥塞了就叫各位慢一点，这样就可以避免拥塞了

那还有一些和IP关系不大的问题，就是网络应该是面向连接的还是无连接的。面向连接的网络叫虚电路网络，虚电路就是虚假的电路，和电话一样要先打给接线员（现在都是机器来做了），让他接线，建立连接才能通信，而建立连接，本质上就是路由器内部留个记录，让虚电路的包都根据记录转发就好了。无连接的网络叫数据报网络，每个数据包都要有详细的地址，路由器自己根据地址进行转发。

所以二者的优劣也看得很清楚了

- 面向连接开始要先进行连接，这会消耗资源，释放连接，也会消耗资源，如果你频繁地连接，那就会浪费非常多的资源。但好处就是一旦连接建立，那我们就不需要详细地址了，只要做一些简单的标记是哪条虚电路就好了。还有一点好处就是因为只有一条线路（虚电路），所以发送的数据必然是按顺序到达的，这样也能减少我们处理的麻烦。但这样的坏处也很明显，一旦中间的路由器崩溃，那么所有经过这个路由器的虚电路都会中断

- 无连接不需要连接，但报头就会长很多，且由于线路不固定，可以动态地选择路径，既可以更快，又可以避免中间一个路由器寄了就出大问题的情况。但多条路径的选择就会带来顺序的问题

- 下面是二者的对比

  ![image-20220708094129281](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220708094129281.png)









## 路由算法

### 路由算法应有的特点

- 正确
- 简洁
- 健壮
- 稳定，即不要一见别的线路空闲一点就跑别的线路，这样路由器就忙于切换，忙于计算，就震荡了
- 公平
- 最优，和公平在一定程度上矛盾

### 静态路由（非自适应算法）

- 人去设置路由表，对路由器输入一个文件还是什么方式设置就行，所以这样工作的时候是不能转换线路的，线路断了只能选择不发

### 动态路由（自适应算法）

- 路由器自己构建路由表，基本只由拓扑结构引起变化，但线路的流量的多少基本不考虑，因为考虑后会设计得很复杂，还可能会产生震荡等问题

那怎么建立路由表呢？

首先，不能有回路，其次每个路由是分布式系统，所以每个路由根据自己知道的拓扑结构建立一个生成树，这样就能得到路由表了，但由于是分布式，所以自己知道的拓扑结构很可能已经改变了，所以要周期性更新

下面我们介绍一些自适应算法

#### 泛洪转发算法（Flooding）

- 就之前的泛洪算法，这样就会有很多副本到达目的地
- 所以我们用一些方法去减少这些副本
  - 在数据包里加一个跳计数器，每跳一次计数器减一次，计数为0就扔掉。计数开始设为应该要跳的次数
  - 数据包加一个序号，每个路由记录最大的序号，比最大序号小的就抛弃
  - 数据库，记录了数据的版本，旧版本就抛弃
- 这种算法的好处就是简单，而且非常健壮，所有线路都会被尝试，这样就不用管拓扑结构了，肯定能找到最短路径。问题就是代价很高，环状的拓扑更难受，只适用于特定的网络

#### Distance Vector Routing（DV算法）

- 每个路由器有个表格，记录了已知的到达的邻居的最短线路

- 路由器会和邻居交换信息来更新表格
  - 周期性地交换距离，地点信息
  - 更新表格的时候也要发送信息
  - 获得信息后，如果有更好的路径就要更新表，没有就刷新表
  - 长时间没有刷新的表就要删除
  
- 所以这个算法并没有得知整个网络的拓扑结构，只是根据邻居发来的东西更新而已

- 但这样网络不能做得很大，不仅仅因为做大了每个路由的表会很大，而且有**无限计数**的问题，即有一个站a坏了，最近的站去a的距离变无限大，但其他站还保存着以前有限大的距离，那最近的站就会把其他站有限大的距离承接过来，其他站就会再把最近的站又承接过来，下一次循环最近的站又存其他站承接距离，其他站又承接最近的站，反复循环，不仅占用资源，而且不能收敛，所以我们设置无限大就是16，这就导致我们网络不能做得很大

- 无限计数的问题在于承接距离的时候承接路径出现了环路，循环继承的问题，所以我们有路径相连算法，把路径也传给别人，这样就能处理环路的问题了，不过这样协议就会复杂很多

- ![image-20220525114922823](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220525114922823.png)

  用这个图解释DV算法。我们看J，J邻居为A,I,H,K，每个一段时间就会发一个ECHO来试探一下和邻居的延迟，并以此更新自己的路由表，并且每隔一段时间就会把自己的路由表发给邻居。路由表记录了能到的所有的点的最短路径长度，并记录了走这条路径要发往的邻居。当自己收到路由表时，看看自己到这个邻居的延迟加上这个路由表到的点的延迟是否小于当前路由表到这个点的延迟，小于就更新自己的路由表。更新路由表就发给邻居。

  所以上面的图前4列就是收到的4个邻居的路由表，而第5列的新路由表表现的形式很烂，表达的意思应该是一个ECHO队列，最上面的是最新收到的邻居的ECHO的延迟

#### 链路状态路由算法（Link State Routing）

- 简单来说就是所有路由器把自己的邻居的开销泛洪到整个网络，这样就能构建起整个网络拓扑，就能用迪杰斯特拉算法得最短路径

  我们给每个泛洪的链路状态数据包加个序号，收到这个包时看看序号是否大于我们收到最大的序号，不大于就扔掉，大于就收下，并往非接收端口转发，并且每个包都有一个TTL，即跳转计数，每跳一次减一次，减到0就扔包

- 多个路由在同一个局域网上的时候邻居数急剧增加，这样对咱们没啥好处，所以我们把局域网虚拟化为一个虚拟节点，选一个路由兼任这个虚拟节点的任务，这样邻居数就会和原来差不多了

## 拥塞控制

当拥塞的时候性能严重下降，为什么呢？因为拥塞我就以为发送出现问题了，就会重发，人人都重发，就会越来越堵，而且之前发的数据就成垃圾了，那就寄了

还有就是路由缓冲队列过短就会无法接收大量用户的信息，过长就会排队过久产生拥塞

还有拥塞控制算法要简单，不然cpu忙于计算就不能转发了

拥塞控制和流量控制完全不同，拥塞控制是全局的，不是仅仅扔包的操作，流量控制就是把非接收窗口的包扔掉，是两个计算机间的。简单来说拥塞控制是防止线路炸了，流量控制是防止接收方炸了

### 拥塞控制方法

![image-20220708162055944](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220708162055944.png)

有这么几种方法

### 提高网络能力

寄，没啥用

### 流量感知

感知其实不难，只要评估一下负载即可，但想想下面的情况，现在全选择a路，然后a路负载过重，因而切换到没人用的b路，然后b路又负载过重了，又切回a路，那这不就震荡了吗？但当我们不考虑负载，只考虑带宽和延迟的情况下，这种问题就不会发生（带宽和延迟又不会因为你选了我的线路而变化）。还有一种解决方案是让负载变得没那么快，这样就可以慢慢迁移了。所以现在的方案都是不根据负载评价，根据其他条件慢慢调节，所以说流量感知慢的原因

### 准入控制

这个广泛用于虚电路网络，若建立一个虚电路会拥塞（我们会预先估计一条虚电路可能会占用多少带宽，这也是为什么说虚电路比数据包要好预防拥塞的原因），那我就不给你建。而且你50M的网想用1000M的速度，短暂地用可以，但久了我就要打压你，限你的流，这个就涉及到后面服务质量的流量整型（比如漏桶和令牌桶）

### 流量调节

当前最通用的方法，数据报和虚电路都能用。就是在准备拥塞的时候，叫大家少发点，那谁减少呢？这就是规则制定的问题了。那怎么知道拥塞了呢？看输出线路使用率，队列长度或丢包数就好了，一般是用平均值判断，平均值计算还可以调控更看重前面的平均还是后面的平均，即

$$d=ad+(1-a)s$$

d是delay，是预计延迟，a是加权因子，可以调节a来控制更看重前面还是更看重现在测得的值，s是当前队列长度。这就是指数加权移动平均，这样就能平滑流量的波动

当然这个算法还是分布式算法，处于拥塞就让用户知道拥塞了，叫他们慢一点，还是拥塞就继续叫他们发慢点

下面是几种流量调节的方法

#### choke packets（抑制包）

如果发的包a到了拥塞输出路，那我们就把这个包a的源地址发回一个抑制包b，叫它慢点，同时包a加一个标记（头部中的一位），表示已经发回抑制包了，防止产生更多抑制包

#### ECN（explicit congestion notification)（显示拥塞通知）

准备拥塞时，给转发的包加标签（头部的一位），去告诉目的主机要拥塞了，那么目的主机发回应答包时顺便告诉发送方，别鸡巴发了，去避免拥塞，源主机，目的主机，路由器都要支持这个协议，且都要计算。这样就不用像抑制包方法那样要产生新的包

#### 逐跳后压

上面两种方法都有延迟，那延迟很大的情况下，很可能还没减慢就已经拥塞了，所以我们可以让抑制包（有抑制标志的包）在每个路由器都告诉路由器拥塞了，让路由器去缓存当前包，防止继续发送导致下游负担加重，这样抑制包没到发送端前，网络拥塞都能得到缓解。当然从这里就可以看出这样上游的路由器压力极大，所以应用不是很广泛

### 负载脱落（隐式控制）

要拥塞了就扔包，计算机收不到包就认为拥塞（现在网络噪音极少造成丢包），我们的网络处理极端情况的能力是肯定不够的

#### 两种扔包方法

- wine 扔旧的分组，一般的业务扔旧的还要重发，所以这个只适用于语音实时通信的业务
- milk 扔新的分组，一般的业务
- 要保留重要的数据和路由算法的数据，比如视频变化不大，我们发了一帧重要的后发的都是极小的帧，那第一帧很重要，那这个就要排在队列前面保存

#### RED（random early detection）（随机早期检测）

在拥塞前随机扔包，隐式地强制主机慢下来

## 服务质量

考虑的质量

- 可靠性
- 延迟
- 抖动，就是两个包的到达的间隔，可能有两个包间隔20ms，后面就变成了500ms了，所以要缓冲
- 带宽

### 流量整形

简单来说就是你随机传一个大包回让网络很难受，所以咱们和运行商商量好不就好了吗，大家都按约定好的走，这样就能好很多了，所以要有流量监管，你越界了就给你扔了，这样网络的流量就会趋于平滑，不会嘣地一下一个突发

整形算法

- 漏桶

  就按稳定速度发送，有个桶去缓存你没发完的数据。但是这样网络空闲的利用不充分

- 令牌桶

  你发数据按网络最大速度消耗令牌，但令牌到达速率是你购买服务的速度。所以你桶越大，能以最大速度发得越久。注意发的时候令牌还在发

### 分组调度

就是在路由器排队谁排在前面的问题

有以下几个因素

- 带宽
- 缓存空间
- 简洁

算法

- FIFO，先进先出
- RED，即将满负荷时随机扔包
- FQ（fair queueing），有不同的公平方法，比如轮流发，那这样包大的就占便宜了，当然还可以改进一下公平，比如你上次发的包大，那下次就不从你这取之类的。一个巧妙的办法是用结束时间去实现，一个包从一个时间到达，这个称为开始时间，那么包肯定还有发送这个包所需要消耗的时间，开始时间加上消耗时间就是结束时间，然后我们根据结束时间排序，结束时间小的排在前面，这样只要前面有排队的，越大的包就得等越久，小的很多时候也能先发，这样就不会占用其他小的时间了
- WFQ（weight fair queueing），加权公平，即原来的消耗时间除以权重，并且结束时间=（加权公平队列里上一个发送的结束时间和自己到达的时间最大的那一个）+消耗时间/权重
- PQ，优先队列，数据有优先级

## 网络互联：网络层的目的

要解决网络差异性问题，比如提供服务不一样，如无连接和有链接；帧的字节数不同，帧地址不同；有些支持广播，组播（组播要在组内才接收，广播都接收），单播；顺序问题；服务质量；协议参数不同，如超时时间不同；收费标准不同

不同网络互联有两种选择

- 弄个转换设备，把A转B，A转C，B转A，B转C，C转A，C转B，一眼转的种类太多了，一般不用

- 在数据链路层上面再加一层，网络层，不同网络发上去后都是同样的传输，这样就不用多种转换了。简单来说就是都转成同一个标准，这个标准就是IP层，这样在上面接收包的传输协议就不用管网络层不同的协议的问题，不用因为网络层换个协议就寄了

- 如图

  ![image-20220708185950979](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220708185950979.png)

### 隧道技术

IPv4和IPv6不是不能互通吗？那我们就别想着把二者相互转换了，在发送和接收的两端都用IPv6协议的时候，中间如果遇到IPv4，那就直接把IPv6数据包整个包放到IPv4的数据段里，这样外面就包了一层IPv4，这样就能在IPv4的协议里传播了，出去的时候再把IPv4的皮去掉就好了



## 分片

MTU：最大传输单元，大了就要分割

Fragmentation：分片，就把MTU切片

### 透明分片

进入网络的时候分片，出了这个网络又还原，但这样太复杂了，网关（路由器）压力大，且这些分片都要到同一个网关，太难用了

### 非透明分片

进入网络需要分片就分片，分片后不用再组装，继续发就行，好处是简单，略微缺点是分片多了头部信息就多，不过对于现在网络问题不大

还有个问题就是小分片丢了，相关的分片到了也没用了，也没法响应，只能等重发

分片头部分三个部分，第一个为包序列号，第二个为分片第一个数据在原包的位置，第三个为是否为最终分片，这样我们组装的时候，根据第二个信息看看有没有缝就知道到没到齐了

所以在源端主机数据包把控好的数据包的大小就不用分片了

所以有Path MTU discovery（路径MTU发现）技术，给包加一个标志，叫路由别分片，那路由遇到大包，又不给分片，那就会返回错误信息，告诉你最大包的尺寸是多少，然后你分片后再尝试，直至发送成功，这样你就知道该分片分成多大了

### 分片规则

- 首先分片的话，分片的最大长度（其实就是数据链路层协议的MTU）要小于要求的IP包的最大长度（包括IP头）（没给MTU但给了其他限制IP包最大长度也可以），其次分片长度要注意，IP的数据部分（不是头部就是数据部分，option也是头部），数据部分在分片后要为8的倍数（不是整体是8的倍数）（除非这个数据部分是最后一个分片），
- 然后分片的偏移量（序号）（在IP头的Fragment offset里）是这个分片数据部分第一个块（8字节一个块）的序号

## 网络层：IP（重点）

制定IP协议的10个原则（可以看RFC1958文档）

- 能工作
- 简单
- 能做明确选择
- 模块开发
- 分层体系结构
- 避免静态参数，这样就不用改代码来改参数
- ……

IP设计的思路是尽力而为，而不是完美运行，能传就传，不能传就扔

### IPv4（internet protocol version 4）

![image-20220719161036537](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220719161036537.png)

那我们就解释一下各个字段吧

- Version，版本，介绍是ipv4还是ipv6
- IHL，头部长度，因为IPv4的头必须为4字节的整数倍，所以IHL的单位是4字节，由于有20个字节的固定头，所以IHL数值最小为5，而IHL是4位，最大表示15，所以IPv4的头最长为60，所以选项最多为40个字节
- 服务域，前6比特作为服务类型，后2位作为显式拥塞控制
- Total Length，包括头部和数据的长度，单位是字节
- Identification，ID，标识，用来识别分片是否属于同一分组，分片不会修改ID
- DF，1b，不允许分片标识
- MF，1b，还有更多分片碎片的标志
- Fragment offset，13b，分片在原分组的序号（1表示八字节）
- TTL，生存时间，8b，用来限制数据包长时间游荡，实际上是转发一次计数器减一（并不是真正的计秒数），减到0就扔掉，并返回错误信息给源端
- Protocol field，承载的上层协议标识
- The Header checksum，对头部的校验，所以数据段的信息是没有校验的，要给高层自己校验。并且每一跳要重新计算校验码，因为TTL减一了，这个有很快的算法，因为只减一，改一点就行
- 源地址和目的地址
- 最后的40个字节就是操作选项，但很少用就是了，这40个字节的第一个字节就是用来区分额外操作的

  - 安全——这不没用的东西吗？我用你强调吗？
  - 严格路由路径，规定一定要跟下面的路径走
  - 宽松路由路径
  - 记录路由路径
  - 时间戳，出了记录路由路径还要记录时间
  - 但上面记录路由相关的都很没用，因为只有40个字节，操作本身占了部分字节了，路由地址又占4个字节，那最多记录9个路由，时间戳记录时间还得再多4个字节，那最多记录4个路由，那这有个逼用啊，太鸡巴少了


### IP Address

#### IPv4 地址

有五类地址，前三种计算机都能用和接收，后两类就是广播，组播，单独传输用的

特殊的地址

- 还没有配置地址，刚刚进网络的时候主机地址为全0，网络中几个报文交换后就会给你分配地址的

- 在本地网络时地址，前面的部分是0，很少用

- 全是1，在本地网络向全部设备广播，路由器不会转发这玩意

- 向远端的网络广播，即你想从一个局域网往另一个局域网广播的地址，所以前面是网络地址，后面全是1

- 127.0.0.1，就是本地地址，用来自己传输给自己用的。计算机不是路由器也有路由表的，好像指向路由器，用下面的指令查看

  ![image-20220523092958649](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220523092958649.png)

### 网络前缀

一个IP地址就指定了一个主机或者路由了，那还有个前缀干啥？

我们前面不是说了分层路由了吗？那怎么实现这一点？路由是一堆一堆的，那如果我想先找到某堆路由，那我靠什么找？给每堆路由再加个名字？拜托，这样不就又浪费了一堆空间了吗？

那我们这样来想行吗？我们分配地址的时候一连串地分配，并且是按2的幂次去分配，长度是2的幂次，起始和终止也是2的幂次，比如你想要178个地址，那我就给你分配256个地址，那倒数8位就是这256个地址拿到的堆内地址名字，前面的24位就是这一堆路由器的堆地址名，这样我们不就能很方便地找到了某一堆路由器了吗？

![image-20220708215345045](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220708215345045.png)

这样我们就把IP地址分两部分，前面部分是网络号，后面是主机号

表示这两部分有两种方法，一个是前缀表示法，就用一个数字表示网络号多长，一个是掩码表示法，掩码前半部分是全1，后半部分是全0，用掩码和地址做与运算，就能得到网络号，所以我们一般转换为掩码，而非前缀

#### 子网划分

就像我们去把整体划分为一堆堆路由器干的事情一样，我们把主机号部分字节挪给网络号，这样就能对剩下的主机号进行子网划分，再划分为一堆堆的。

即假如网络号长24，主机号长8，IP为192.168.1.0，那我规定LAN1的地址为192.168.1.0（/25），LAN2的地址为192.168.1.128（/26），LAN3的地址为192.168.1.192（/26），这样由于主机号全0和全1都不能用，所以LAN1能用的是2^7-2，LAN2能用的是2^6-2，LAN能用的是2^6-2

下面是从一个地址分配一堆地址的例子

![IMG_20220526_102945](%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/IMG_20220526_102945.jpg)

#### CIDR——无类域间路由

咱们的IP地址不是很长嘛，所以IP很多，那我一个路由器，要去找到某个IP地址，那不就得记在路由内存里吗？那这么多IP地址，我怎么装得下来？

那按之前的分层路由的思想，那我要找一个路由，去路由对应的堆先，那堆的地址总少一点了吧？

对，少一点了，但也没少多少。那我们就再按这个思想去走，咱们堆地址，或者说网络号，前面也总有部分相同的吧？那如果有几堆路由器，这几堆的网络号前面的部分相同，这几堆又正好能接在同一个转发路由器上，那我就接在同一个转发路由器上，别人给我这几堆路由器发东西，就先按前面相同的部分找到转发路由器，转发路由器再比对堆地址找到发给哪一堆，堆里再根据主机号找到对应主机，这不就是分层路由的思想吗？那我几个转发路由器，每个转发路由器的地址都是几堆IP地址前面相同的部分，而我这几个转发路由器前面部分地址又有相同的，那不就又可以合并了吗？这样递归，每个路由器的地址数量不就大大减小了吗？

这时候，IP地址的每一位或每几位就可以看作一棵二叉树的分支，分层路由分几次后，很快就能找到目的主机，而每个节点（路由）下面只记录了连在他下面的路由或主机，这样路由表就大大减小了

这个技术，就是CIDR技术，如下图

![IMG_20220523_091802](%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/IMG_20220523_091802.jpg)

那你肯定又会说了，我原本想发给地址A的，结果路由器发给了地址B，而且地址B里根本没有地址A，那不就完全找不到了吗？那这里提出最长匹配前缀原则：转发的时候先和掩码长比较，对了就转发。

因为掩码短所能指代的路由就多，先比较掩码短的，如果目的IP在掩码长的那个方向，我们可能只比较了掩码短的就转发了，掩码长的根本没有比较 。而掩码长的端口之所以能独立出来而不合并到掩码短的端口，就是因为这两个方向是不一样的，掩码长的端口的所包含的地址和掩码短所指代的大片地址不同，所以掩码长的比对正确，说明肯定在掩码长那边，不对的时候再看看掩码短的，这样就能转发正确了

缺省路由：0.0.0.0/0，不知道发哪就发这

#### 分类和特殊寻址

在介绍了CIDR之后，为了体现CIDR的优越性，我们介绍一下之前的分层路由的方案

之前的分层路由被称为分类寻址，如下

![image-20220709073830150](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220709073830150.png)

五类地址就是用不同的头来区分，每个类别的网络号长度和主机长度规定不一样。可以看到这样规定死的网络号，导致需要的地址数不能按需分配，还浪费了几位空间的区分头，比子网划分、CIDR傻逼多了

现在没主机认可这种分类方法了

#### 几个特殊的IP地址

![image-20220709080426080](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220709080426080.png)

全0地址指本机或当前网络，当一个主机刚进入网络时还没给它分配地址时的地址

前面部分是0，表示在本地网络找对应主机号的主机，这个用于不知道本地网络的网络号时找本地主机的情况，但你可以看到，你必须知道本地网络号有多少位，即掩码是多少

全1地址用于本地局域网广播

前面是网络号，后面全1的地址，原本打算发送到远端的网络去广播，但因为安全问题，被路由器禁了

127.x.y.z的形式用于本地回环测试，这个包并没有被放到线路上，只是像其他接收的数据包发给接收数据包的进程，这样就能进行本地的测试了

### NAT——网络地址翻译

前面不是说了吗，IPv4只有32位，算算才40亿个地址，全球的人一起用，肯定不够，那怎么办？

一个想法是IP地址是动态分配的，主机不活跃的时候就收回分配给它的IP地址，但很多企业的PC是要持续打开的，个人用户也希望一整天都在线，那这个办法行不通

彻底的解决办法就是IPv6，IP地址128位，几乎不可能消耗完了。但过渡是一个长期的过程，我们还需要解决IPv4地址不够的问题

所以有了NAT（network address translation）（网络地址转换），让一个机器得到一个IP，再对连接这个机器的主机分配内网地址

NAT就是把内网地址转换为外网地址的技术，简单来说就是外网地址都是一个NAT箱的地址，NAT箱有它自己的IP地址，NAT箱有很多端口，你的路由接上这个箱就会得到一个端口号，你在局域网的地址在外网是不存在的，最后都会被NAT箱转换为它自己的IP地址和对应端口信息，从而使IPv4能够使用。当然NAT不止会地址翻译，还会附带一些信息，让别人能发回来。当然改了地址，校验码也要改。NAT如下图

![image-20220710083120640](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220710083120640.png)

当然既然你能区分，那必然需要空间去容纳区分的信息，那这个空间在哪里？IP协议已经没有空间了，那么这个空间只能来自高层协议，传输层。网络层实现的是点到点的连接，也就是说网络层只能把一个数据包从一台电脑传到另一台电脑，网络层并没有关于这个包是属于哪个进程的标志，那主机怎么知道要给哪个进程呢？这就引出了端口和传输层的概念，一个进程占着某些端口，对方发过来的信息标注自己要给哪个端口不就好了吗？所以NAT实际上是用了传输层的端口的空间来区分，这样打破了分层的理念，也就是说上层对下层不透明了，现在上层的某个位置必须为端口号，否则NAT彻底失效了，这就是一个很失败的设计了

另外，NAT的工作原理是根据你发过来的内网地址和端口号做一个映射到NAT的IP地址和一个映射端口号，等别人发回东西的时候，再根据发回的映射端口号再映射回原来的端口号和内网地址。那问题是这个映射其实并不是通过一个函数直接得到的（你自己想想怎么有这么精妙的函数，能把IP地址和端口号这么长的空间压缩成端口号那么大的空间，还能保证没有两个映射端口号不同的，这根本违背了数据存储的基础，即一定大小的空间只能存储一定大小的数据），而是把内网IP和端口号存储起来，用映射端口号做一个索引找到内网IP和端口号而已。这就带来一个很大的问题，原来是无连接的网络，现在我居然要预留空间去为你存储连接的信息，这不就像面向连接了吗？而且这样NAT一炸，内网就全炸了，这不就是虚电路网络的脆弱性吗？

另外，NAT要存储了原来的信息，发送，然后再接收，再映射，这就意味着你要存储了才能接收映射，也就是内网主机发送了东西才能从别人那里接收（或者说主机主动与别人建立TCP/IP连接，让连接信息稳定地存储在NAT中才能接收），这就意味着如果连接没有从内网的主机发起建立，外网的主机是根本找不到内网的主机的



还有动态翻译和静态翻译





### IPv6

我们受苦于IPv4地址空间太小了，所以IPv6要解决一下问题

- 地址扩大，这样就没NAT的问题
- 还有一些没那么重要了

#### 头部字段

让我们先来解释一下IPv6的头吧

![image-20220710084807626](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220710084807626.png)

- 版本就是指IPv6的6，是IP的版本

- 区分服务用来区分数据包的各种传递需求，最后两位用于显示拥塞指示

- 流标签（flow label），可能要发送一组数据包，有一些特别的需求，比如延迟要求严格，那么路由器就要提供相应的服务，如预留带宽。所以流标签就是某一条流的标识，区分不同的流，以便路由器接收到一个包知道是这个流的，能进行处理。实际上这条流还是用数据报的形式传输的，但处理起来又像虚电路的处理方式，所以是两种传输模型相结合的一种尝试

  当然区分流不止通过流标签，还根据源地址和目标地址，所以就算流标签相同，路由器也能进行区分。当然流标签选取还是随机最好

- 有效载荷长度（payload length），这个看起来挺像IPv4的总长度（total length）字段，但总长度包括IPv4的头长度的整个报文的长度，而有效载荷长度不包括开头的40个字节，只包括40个字节以后的字节数

- （看到上面这一条你可能会疑惑头长度去哪了，其实IPv6的头长度固定了，只有40个字节。那你肯定会问，那扩展头怎么办？别急，下面讲）

- 下一个头（next header），这个设计挺好的，不是定义了下一个头的长度，而是指明了下一个头是哪一种头，这样每个头的长度，格式都只要协议规定好就行。如果 当前头是最后一个IP头（是指包括IPv6头和扩展头在内的最后一个头吗），那么最后再接一个头，指明用哪个协议处理（这样原来IPv4的协议段也去掉了）。当前协议已经定义了6个扩展头

- 跳数限制，就是原来的ttl，但原来的名字让人以为是计时的，但其实只是计跳数的，所以改个名字

- 源地址，目标地址，长16字节，128位，多到地球上的每平方米都能有几万亿个地址，这样几乎不可能用完

- 最后讲一下和IPv4相比，IPv6删除精简了啥

  - 删除了头长度，因为IPv6的必需头长度是固定的，而扩展头长度是协议定义，我们用下一个头这种链表的形式去得到整个头，而不用长度限制的方法得到整个头
  - 删除了分片相关的字段，IPv6认为让路由器分段会出现大量的资源消耗，让主机把段分好即可。所以IPv6在传输过程中如果因为尺寸传输不了，路由器会发回一个报错信息，主机会调整包的长度，进行分片后再发，太长就再分。
  - 删除了协议字段，实际上是把这个字段放到最后一个扩展头去了
  - 删除了头校验和，IPv6认为校验在当下网络质量很好的情况下，是一件极为浪费资源的事情，况且传输层也有校验和，所以就删掉了

#### IPv6地址表示

16个字节太长了，给人看都看不过来，所以有下面的表示方法

一个字节之前用十进制表示，现在用十六进制表示，之前一个字节用一个“.”分割，现在两个字节一个“：”分割成一个组

然后是简化规则

- “0123”可以写为“123”，前面的0可以省略

- 连续的一个组或多个组为全0，那么他们可以用一对“：：”表示（这只能用一次吧）

- IPv4可以写为“：：”加原来的IPv4的地址，如：

  “：：192.31.20.46”

## 网络层的辅助控制协议

包括ICMP，ARP，DHCP

下面我们一个个介绍

### ICMP（internet control message protocol）

如果路由器处理数据包发生意外了，该传回怎样的信息？

这个格式，就是ICMP协议。定义了路由器向源端报告有关事件的协议

这个协议的报文被装在IP包的数据段里

有以下常见消息

![image-20220711083531676](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220711083531676.png)

- DESTINATION UNREACHABLE（目的地不可达）。可能是找不到，也可能设置了DF位不能分片，而包又过大的时候发回，源端自然会处理或分片
- TIME EXCEEDED（超时），hop count（TTL）耗尽。本意是告诉源端有包进入路由循环了，或者ttl设置得太小了。但在1987年，被巧妙地用于确定主机到目的地路径上的IP地址，这个工具叫做traceroute。简单来说就是ttl从1，2，3...从小开始增加，这样每一跳的路由器都会发回超时通知，这样就能知道主机到目的路径的每个IP地址了
- PARAMETER PROBLEM（参数问题），表示主机发送的IP包有问题，可能有几个字段错了
- SOURCE QUENCH（源抑制），进入拥塞时返回chock package的信息来拥塞控制，虽然现在很少用了
- REDIRECT（重定向），当路由器发现一个数据包被错误地路由时（可能路由器发癫转错了之类的），那么就发回重定向消息，尽可能地把错误信息告诉源端主机，让主机重新发送
- ECHO（回显）和ECHOREPLY（回显应答），主机收到ECHO时，就发回ECHOREPLY，这样就能让别人知道自己是否活着，也能用这个方法知道别人是否活着。在cmd里就是ping某个域名得到是否存在对应的主机
- TIMESTAMP REQUEST（请求时间戳）和TIMESTAMP REPLY（应答时间戳）。用来测量网络性能
- ROUTER ADVERTISEMENT（路由器通告）和ROUTER SOLICITATION（路由器恳求），让主机能找到附近路由器的报文

### ARP协议——地址解析协议

网络中的每个主机都有IP地址，对吧，但在局域网里，就像我们之前说的一样，我们找一个主机并没有用到IP地址，而是MAC地址，或者说数据链路层的地址。那我们应该要做一个IP到MAC的映射，得到对应的MAC

那我们下面说说解析的方法

现在主机1发了一个包a，那这个包肯定先在局域网内传播，那我们在发包a之前，先发一个广播包，问局域网内有无这个IP地址，有自然有主机应答，发回对应的MAC地址；

没有的话，那么我们自然想发到路由器上（这个路由器的叫做默认网关或缺省网关（default gateway），地址为该局域网的地址中的最低地址，即除去主机号全零的地址，默认网关的地址应该是对应网络的网络号号和主机号为1的IP地址，如分配给这个网络的地址从192.32.65.0/24开始，那么默认网关的地址应该为192.32.65.1/24），那么我们就会广播请求198.31.65.1的MAC地址，如果路由器连接着以太网交换机，那么我们的请求就会从交换机转到路由器，路由器就会回发一个报文告诉我们MAC地址，然后我们就按这个MAC地址去发我们想要发的包就好了

一个包到了局域网也是一样，路由器先广播请求对应IP地址的MAC地址，得到对应MAC地址后按这个MAC地址转发到对应主机

当然每次都要请求就很麻烦，所以我们主机就可以缓存一个发送到目的主机的MAC地址（定时，超时就扔了），下次要发的时候直接发对应的包，包里带有MAC地址，可以在以太网里直接转；以太网交换机的向后学习算法也缓存了一个MAC地址到另一个MAC地址应该转发的端口，这样就能直接转到对应的主机或路由器了。

我们还可以在配置自己的IP后，发自己IP的ARP包，这样就能知道分配IP有没有错误（可能是手动配置的问题），导致两个重复IP出现。

注意，路由器不同端口网络IP不一定相同，如下图，连在同一个端口下的局域网才是同个网络IP

![image-20220712114256275](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220712114256275.png)

### Prox ARP——ARP代理

那如果一个主机没有配置缺省网关，它广播了ARP包后收不到回复也不知道发到缺省网关怎么办（这种情况很傻缺，所以这个技术也很少用）？

那我们就提出了ProxARP，ARP代理技术，即主机广播一个IP地址找MAC地址时，如果没有答复，那么路由器就假装自己就是主机要找的MAC地址，传回自己的MAC地址，这样主机下次发带MAC地址的包时，实际上是路由器直接转发。

当然这样也带来安全问题，如ARP欺骗

### DHCP——动态主机配置协议

前面ARP协议已经假定了每个主机已经设置好了自己所占的IP。那如果都是手动配置的话，那既浪费时间，也容易出错，也可能造成资源浪费

所以我们有了DHCP，动态主机配置协议，用一个DHCP服务器去给你配置，你向它请求IP，它给你分配IP。

所以得到IP的过程如下。你刚启动计算机时，计算机只有MAC地址，那么要请求DHCP服务器得到IP，那我们像ARP干的那样，先在局域网里广播一个DHCP DISCOVER报文，DHCP服务器直接连到局域网，那就可以直接收到，如果没有直接连到局域网，那么路由器配置成能找到DHCP服务器的状态，并把接收到的DHCP包中继给DHCP服务器。DHCP服务器收到了，就缓存了这个主机的MAC地址和分配的IP地址，再回复一个DHCP OFFER包，带着空闲的IP地址的包给主机，完成分配

很明显，一个主机不能永久地占用分配的IP，所以每个IP都有租赁时间，超时前要再次向DHCP服务器请求续订，续订失败就不能用这个IP地址了

## 标签交换和MPLS

讲到现在为止，我们所说的网络层也好，路由器也好，其转发的模式都是无连接的模式，那如果我们想弄个面向连接的模式，但又要足够灵活，怎么办？（反正就是有人想弄）

那就出现了MPLS（multiProtocol label switching，多协议标签交换）。这个技术的设计理念就是让路由器实现快速转发。我们在数据链路层和网络层中间加一个MPLS头，MPLS头里有个标签，能让路由器直接查MPLS表然后转发（原来的转发操作要在表中按最长匹配原则去找差不多每个项，看看哪个项匹配，而MPLS标签就像时转发表的下标，索引，像数组给了下标就直接能得到结果，这样就快很多了，而这个交换操作，就叫“标签交换”），就类似于虚电路的留一个缓存空间建立虚电路。然后MPLS转发要用专门的标签路由器（因为大多数路由器和主机都不理解MPLS），这些路由器组成一个叫MPLS网络，进入这个网络的路由器叫标签边缘路由器，会为IP包加入标签，在MPLS网络中就按这个标签转发，出了这个网络就删除标签，这样就完成了快速转发

当然我们可以看到用加一个MPLS头的方式实际上是用了分层的思想，但数据链路层和网络层之间不应该再有其他层了，说明真正的协议并不总是符合理想的分层协议模型。当然这样带来的好处是MPLS层独立于这两层——我们只是在一个包的网络层的头的前面加了一个头，这就意味着MPLS协议可以支持多种网络层协议，这也是MPLS，多协议标签交换中“多协议”的含义

## 自治系统和内外网关协议

我们的网络不是一天建成的，也不是一个公司建成的。不同时代有不同的标准，不同的想法，不同公司有不同的标准（比如延迟的定义，路径代价的定义），有不同的想法，面临着不同的问题，甚至说同一套标准，但因为两个网络分工，收费等等问题，都可能分成两个网络，所以网络是一堆一堆建立起来的，每一堆都只遵循着自己的那堆的协议，路由算法，报文结构各不相同，而一堆的独立网络，就叫**AS（autonomous system，自治系统）**。在AS内部使用的路由算法，称为域内路由算法。

AS内部使用的协议，称为域内路由协议，也称**内部网关协议（interior gateway protocol，IGP）**，而两个AS之间的路由问题，则要通过域间路由协议和**外部网关协议（external gateway protocol，EGP）**解决。

当前比较流行的就几个协议。使用最多的内部网关协议有**RIP**和**OSPF**。使用最多的外部网关协议是**BGP**

下面是上面提到的几个概念的图

![image-20220712170852270](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220712170852270.png)

### RIP（路由信息协议）

RIP（routing information protocol）

RIP使用的路由算法是DV算法，每个路由器都要维护与其他所有路由的最短距离的表，所以要和自己邻居路由器交换自己的最短距离路由表，而距离用跳数表示，所以RIP算法优先选择跳数少的路径。

由于DV算法无限计数的问题，跳数最多允许15跳，这就导致使用RIP的AS无法做得很大。且坏消息传得慢

还有**RIP是应用层协议，使用UDP传输数据**，即RIP的路由器交换维护最短距离表的信息是在UDP的包里的

### OSPF（开放最短路径优先协议）

OSPF（open shortest path first）

**直接使用ip的数据段承载信息**，是网络层的协议

OSPF使用的路由算法是链路状态路由算法。OSPF的O的意思就是开放的路由算法，即发布在公开的文献上的路由算法。而链路状态路由算法是开放的，而链路状态路由算法中，路由器之间交换信息都是以泛洪的形式去交换的，并且交换的信息是自己和自己邻居的距离。然后交换信息的距离使用的可以是延迟之类的，所以OSPF的SPF是最短路径优先的意思

用链路状态路由算法就能解决DV算法的各种毛病

OSPF是网络层协议，即路由器交换的信息的包里，信息是存在IP包里的，IP头部的协议字段为89

如果遇到多条同样代价的路径，那么就会把数据平均分到这几条路

很明显，迪杰斯特拉算法用于一个很大的图复杂度就会急剧上升，更何况链路状态发的方式都是泛洪法，这样网络大了就会网络风暴。所以我们为了把OSPF做大，我们还要把整个AS分成几个区域。而区域要连接在一起，我们的做法便是一个区域作为主干（骨干）区域，连接着各个区域，还链接着其他AS。

所以

- 连接两个区域的路由器叫区域边界路由器
- 骨干区域的路由器叫骨干路由器
- 其他区域的非边界路由器叫内部路由器。
- 连接其他AS的路由器叫AS边界路由器
- 区域边界路由器要知道连接的两个区域的拓扑结构。其他的不用，只用知道自己区域的拓扑结构即可

### BGP（边界网关协议）

很明显，我们分层的目的就是为了减小路径选择的资源消耗，如果我们在域间还想着找一个最好的路由器来转发我们的包，那这势必大大增加了我们计算的复杂度

那BGP就不想着找最好的路径了，BGP的想法就是让每个AS选出一个或多个AS边界路由器，不同AS之间的AS边界路由器相互交换信息，这样就能知道要到不同AS，要走哪几个AS的哪个AS边界路由器比较好了

BGP采用的到不同的AS的路由方法是路径向量路由选择协议（就是之前说的解决DV算法的另一个改良算法，这样就不会循环继承最短距离，无限计数了）

**BGP是基于TCP的，也就是说BGP报文存于TCP的数据部分**

BGP刚运行的时候会和别人交换整个路由表（基于DV改良还是得交换整个路由表），但后续只要更新表里有变化的部分就行了

当然EGP要考虑的不止这些问题，比如国家机密信息总不能传到别人的AS里让别人转发吧，别人看了怎么办？还有帮别人转发不就是占用自己的资源吗，哪有这种这么好心帮别人转发的。所以AS之间有这么几种关系

- TR，中转，即我向你提供中转服务，你给我交钱
- CU，客户，即我购买你的中转服务，我是你的客户
- PE，对等，即我们两个之间都要相互发消息的，那我们干嘛要给别人钱去中转，咱们允许彼此相互发不就好了吗？注意，咱们两个对等不是说你可以让我帮你中转，而是说你发给我的我接收，我发给你的你接收，发给别人的都不会进行中转操作（你自己想想不收钱就干这事，这事又和自己没关系，这不是蠢吗？）。所以如下图，AS2的包不能通过AS3中转到AS4，即便AS2和AS3是PE，AS3和AS4是PE

![image-20220712215737651](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220712215737651.png)

### 三者对比

![image-20230830175739060](%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0.assets/image-20230830175739060.png)

## internet组播

那我们还是有些时候想发给一组主机发送包的，这就是组播

IP本身有组播的功能，IPv4的D类地址（224.0.0.0~239.255.255.255，只能这个范围）有各种组播的地址，IPv6也保留了一些给组播

### IGMP

但上面的功能只能用于本地网络的组播，如果我们想发给多个网络的成员，我们当然可以多个单播，但数据是可以复制的，送到终点再分发能明显降低网络负荷

我们就需要一个路由协议，这个协议就叫IGMP（internet group management protocol）

需要注意的是，主机组播时仅发送一份数据，只有数据在传送路径出现分岔时才将分组复制后继续转发。

![image-20230830180901804](%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0.assets/image-20230830180901804.png)

服务器用IGMP告诉路由器要接收组播包了，然后路由器接收组播包后进行转发，如果要转发到多个地方了，那就复制对应份数，然后转发。实际上我们想要避免环路，我们就采用生成树的方式，源主机生成一个组播树

另外，组播就是以组为单位，所以你要加入一个组，就得用IGMP向这个组的组播地址发送申请，申请给到本地的组播路由器，然后转给其他组播路由器

然后组播路由器防止有些组员退出组了，还占着名额，本地的组播路由器就得定期的问一下这些主机还在这个组吗。如果几次没有回应，就认为退出组了，并告诉其他组播路由器，更新组的关系

## 移动IP

笔记本电脑可能绑定了一个IP，但当然这并不意味着它在某个网络的IP都是这个IP，而是说它希望别人找它的时候，都用这个IP找。那这有个问题，我们的IP都是分层和用前缀去找的，你IP移动的话，到一个地方，一个地方的路由器就得重新改写路由表，前缀啥的，CIDR啥的都得重新来，那一堆人的IP移动，那路由器不就全寄了吗？

本质上还是我们不希望路由表去改变，本来加减路由就已经耗费我们大量精力去找最短路径了，你还要来一个时刻都可能会改变拓扑的情况，那这样肯定解决不了问题

所以我们就不改变拓扑了，我们用代理的方式解决。之前有ARP代理，就是假装我是跟你直连的，实际上是别人代为传达的。那现在也是这样，假装我是没有移动IP的，但其实我还是代为传达的

移动主机2，2现在不在原来的IP所在地，所以外地的本地网络先给2分配个外地的地址，称为转交地址，2再把转交地址告诉家乡代理服务器，以便家乡代理找到它，给它转发。主机1发送包给2，2不在家，所以发给的主机是家乡代理服务器，家乡代理把这个包再包一层IP（就是隧道技术，因为改写IP头是一件既麻烦又有问题的事情），发给2，2再解开外面包的那一层，得到1给它发的东西，然后再根据这个东西的发送地址直接发送回去就行，不用走家乡代理了（走家乡代理是因为别人找不到你，现在你都能直接发回去了，还走什么家乡代理），直接发，用的是家乡地址。

如果1还是靠家乡转发，那这样三角路由太蠢了，做到下面这样最好

1一收到2转交地址的包，知道现在2的转交地址了（这个应该要ip拓展或者高层去解决），那下次1就不用走代理了，直接往转交地址，用隧道技术发给2就行了，不用走家乡代理了

整个过程如下图

![image-20220713075530182](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220713075530182.png)

# 第六章——传输层

## 23/8/30 订正

首先，传输层全称是传输控制层，应该叫控制层才准确，不知道为什么叫传输层

传输控制层干的就是控制传输，完成一些传输基本功能，比如不能有错，丢包了要重新发之类的，这种把处理的任务放到端点的思想就叫端对端

## 传输层的设计理念

我们已经在网络层实现连接各种网络，并且找到对应主机了，但现在还有个问题，就是我们主机上还有很多进程，进程可能还有很多线程，我们怎么区分哪些包该给那个进程/线程呢？这就引入了端口的概念，一个包交给主机后，主机再将它交给对应端口即可。那我们需要有一层协议，去实现端口的概念，这一层就是传输层，它最基础的就是实现端口这个概念

传输层还有设计的目的还有一点就是隐藏网络层的各种网络，提供给程序员一个统一的操作方式，让程序员只用考虑选择一个服务类型，然后传输就行，至于路由器炸没炸，线路选择了哪一个，包传没传到，这些程序员都不用关心

TCP，UDP就是传输层的两个协议，TCP是面向连接，可靠的协议，UDP是无连接的，不可靠的协议。那这里有个问题了，TCP是面向连接的，但整个网络层是无连接的，那这怎么解决？实际上TCP的面向连接是指保证了数据包的有序到达（会对数据包进行处理，就像我们在数据链路层里处理的一样），保证了数据包一定到达（超时重传），会建立连接，而这个连接，就是记录了当前数据包的序号，处理超时的功能；释放连接，就是释放这些功能所占据的内存空间和CPU周期

下面我们就来讨论一下传输层需要考虑的技术

## 端口保留

服务器向别人提供服务，那别人肯定得知道你的端口号是多少，所以有两类端口号

- 服务器端用的端口号，又分为两类

  - 熟知端口号，数值0~1023，IANA（互联网地址指派机构）留给了最重要的一些应用程序（没了这玩意连网都上不了），下图举了一些例子

    ![image-20220716211322725](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220716211322725.png)

    ![image-20220716211951341](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220716211951341.png)

  - 登记端口号，数值1024~49151，并不是最重要的程序用的，要跟IANA登记，防止重复

- 客户端使用的端口号，数值为49152~65535，仅在客户端进程运行时才动态选择，所以也叫短暂端口号（你看DNS的客户端每次的端口号都不一样）

## 面向连接的实现

我们先来讨论一下怎么在无连接的网络中实现面向连接吧

### 连接建立

那我们还是用之前的想法吧，我想和别人连接，那我就先请求连接，然后让别人响应连接，以表示自己已经连接，连接建立完成

但这样传输层和网络层一样有以下问题

如果一个网络非常拥塞，可能一个包得排很久，才到达目的主机。那发送端可能认为超时了，又发一个包，那就有可能有多个包会到达目的主机，那我们怎么辨别两个包呢？那连接建立，两个包无法辨别，就会建立两个连接了，这不是我们想要的

那我们肯定想先用网络层的解决方法，每个包加一个源地址和ID，还有生命期就好了，那这带来一个问题，路由器之间是一直连着的，那我们传输层可不想一直连着，正是因为不想一直连着，我们才会讨论连接建立，连接释放的问题。那这个方案带来一个很大的问题，那就是我们连接可能很快释放，那在网络逗留的那个包在释放后就来了怎么办？我们又新建一个连接吗？那这个方案不行

那发现上面方案的问题了吗？如果我们每个连接的ID都不一样，那我们在释放后都可以辨别出包是否重复。那这个方案就是我和其他主机的ID是递增的方式。那这还是有问题，每个主机都要无限期地维护和其他主机的连接ID，你要记住当前最大的ID是多少，那这最大的问题是我主机炸了，我忘了最大ID是多少，那我就没法和别人建立连接了，那这不是很可笑吗？

那这个方案的问题在哪？是忘记对吧，那我们有办法让两个主机同步当前连接序号不就没问题了吗？所以我们的解决方案是，我们向对方请求连接，那我们先要和对方说好这次连接的ID是多少，然后对方一看我们发来的ID，和自己历史记录里的ID不一样，那说明要么这次的连接请求是网络里逗留重复的包，要么我们或对方可能重启了忘记了序号，总之对方无论ID是否相同，都会发回自己记录的ID，这样我们收到后，我们发现不同，就能更正同步ID，下一次连接就对了，发现一样，那我们就建立连接，并发回确认，让对方知道我们建立了连接，对方也建立起连接

所以综上所述，原来我们建立连接只用两次握手，请求和答复，现在我们为了同步连接的序号，我们多加一次握手，让对方能发回序号，从而我方能进行同步。所以建立连接是三次握手

---

回去看书，书里的问题还是没有解决

---

### 两种断开连接的方法

- 暴力断开

  一端直接断开，那另一端还没发完的东西就会被丢掉

- 优雅断开

  一端断开，只认为是自己不发了，连接所占用的资源还在（不然你还是没接收对方没发完的东西），两端都断开了才真正释放连接的资源。但这有个很大的问题，a告诉b，a没东西发了，叫b断开，那a不确定这个包丢没丢，就得等b的回复，b收到断开的消息，就得回复a，但b也不知道a是否收到了，b断开的话就收不到a的消息的，那也会等a的答复再断开，最后你会发现，二者都无法保证最后一条回复是否到达，都得靠下一条回复去保证，那这样永无止境了。所以不能靠ACK断开
  
  那这样的问题在哪？因为双方都想双方都确认后才断开，但双方确认又不能保证。所以我们只要不用确认对方已经确认断开即可，即对方发完最后一个包，我肯定要发回ACK，对方收到这个ACK就可以断开，没收到就会再发一次这个包，那我发了这个ACK后一段时间没收到包，那说明对方已经断开了，那我也可以断开了
  
  （当然也有TCP想用一段时间没有包来表示断开（无论对方想不想断开），所以这样需要在没有包的时候每隔一段时间就发一个包，问问对面还在连接吗。但很多人反对这个方式，因为它有额外的开销，也有可能终止一个正常的连接）

### 连接释放

我们使用的是优雅断开

我们请求断开，对方收到后回复收到，然后我们等待对方发最后一个包，收到后然后发回最后一个包的确认，并且等待一段时间（防止确认没发到对方又发最后一个包我们已经断开的问题），对方收到确认后，就可以断开连接了，而我们等待一段时间后没有消息就可以认为对方已经释放连接，可以安心断开连接了

很多人说是四次握手，其实是把对方发的最后一个包也算进来了，真正干事的就三次握手

## 差错控制

传输层也要实现差错控制，使用某个可靠的检错算法（能检查出足够多的错误保证报文是可靠的），当然还需要ARQ机制

讲到这里，我们已经讲过三个检错了，数据链路层的检错，网络层的检错，传输层的检错，这会不会重复多余呢？

其实每个层负责的部分是不同的

- 数据链路层负责的是一条线路上的正确，检查出错误后在这条线路上重传，但是你学的时候就知道，CRC，checksum本身是不可靠的，不能检查出所有错误，况且数据链路层检错的是线路上的帧，这个帧在路由器转发处理的时候是否出错它没保证，所以它把检错的责任交到了上层
- 网络层的检错是针对IP头的检错，防止传错等问题，为的是包在路由器之间的传输途径是正确的，包里面的内容它是一点没管，而且它的检错算法也是不可靠的，很可能会传错之类的，也要上层去做检错
- 所以传输层还需要对传输层的东西进行一个可靠的检错

那前两层的检错到底有什么意义？既然都是传输层去保证不出错，前两层做检错不就是浪费资源吗？

- 数据链路层检错虽然不能检查出所有的错误，但能检查出大部分的错误，如果一个报文从源端到目的端一路上都没人发现有错误，那得到目的端的传输层去处理或重传，那这浪费了很多的时间。如果我们有数据链路层就截下来了，那我们就不用浪费这么多资源了（这和路由器消耗的资源相比谁多我不知道）
- 网络层的检错确实有些多余，主要是在网络层出错的几率已经非常小了，网络层也不能保证检错可靠，检错又浪费资源，所以IPv6就把检错扔了

## 可变的缓冲区

因为发送出错了就要重传，所以要把传输层的段缓存，且是在发送方缓存。

那有个问题，你不想数据链路层一样只处理两个点之间的连接，在传输层你有时和很多人连接，有时又不连，那就要把缓存区动态分配，不然有时又不够，有时又多余。所以缓存区的发送窗口长度要动态变化。那这样我们发送的信息中除了原来的ack，seq啥的还要加入缓存区剩余buf长度，发送给发送端，来影响发送端的发送窗口长度，当buf长度没了，就不能发，申请到了新的缓存或原来的缓存释放了就又有buf长度了

## 流量控制

听起来好像在传输层又把数据链路层干的事情又干了一遍，其实不然，数据链路层处理的是点对点的主机，而传输层处理的是两个需要经过多个路由器转发才能沟通的主机，你发给目的主机，发的包可能走了非常多跳不同的路，那在数据链路层看来，它只看得到两个点，一条线路上是否需要流量控制，那这么多条路合在一起，到了目的主机，那目的主机就叫苦不迭了，缓冲区时刻在变，数据链路层的固定的窗口肯定出事，处理不过来

（还有个说法是数据链路层实现的是点到点的流量控制，传输层实现的是端到端（经过若干转发）的流量控制）

所以我们需要一个传输层的流量控制手段，那之前的ACK的方案行不通了，因为我们的缓冲区不固定了，那怎么办？那我们把剩余缓冲区长度发回去不就好了吗？这样别人就能调节自己的发送窗口的长度，控制发送速率了

而传输层的发送窗口，除了接收方计算机的流量控制，后面我们还会讲到拥塞控制

## 多路复用

多个程序可以用同一个传输层协议，多个网络连接给一个程序应用使用，网络连接可以理解为有网络的路由器

## 拥塞控制

网络层有拥塞控制，为什么传输层也有拥塞控制？

因为网络层的拥塞控制是提供给传输层的一个服务，而传输层的拥塞控制是用网络层提供的服务去实现拥塞控制。也就是说一个只提供了避免拥塞的手段，一个用提供的手段去真正做到避免拥塞

这也是为什么我们再网络层讲了拥塞却没讲怎么使用的原因

拥塞发生的地方就是路由器那里，可以用丢包率来判断是否拥塞（这个其实是网络层干的事，网络层提供拥塞服务，传输层根据网络层的反馈，进行发送速率的调整，实现拥塞控制）

现在网络只用传输层真正做了拥塞控制，所以现在网络严重依赖传输层拥塞控制

#### 拥塞控制的实现

我们用发送窗口去限制速率来实现拥塞控制即可（这真是个天才的设计，既实现了拥塞控制，又不用改动以前的设计就能实现）

我们发送窗口的大小受对方缓冲区和拥塞信号控制，选二者最小的那个长度作为发送窗口的长度

#### Max-Min Fairness最大最小公平

我们还是想要传输分配的带宽既公平，又高效

高效就是尽量地用完带宽，还要一发生变化就要能快速地收敛，公平就是平均

那平均好像就不能高效了，所以我们提出了最大最小公平，既需要的带宽低于分配平均值的流量必须满足，满足完这些流量后，再做平均，分给哪些大于平均值的流量

方法有了，但我们怎么实现平均分和叫对应主机发慢点呢？总不能我一直测着，统计，然后发回一个包告诉主机该发多少吧？这样太浪费资源了。所以后面我们提出了AIMD，这个算法能抖动到平衡点，而使用AIMD思想的拥塞控制的方法，就是慢启动

#### 增加速率的速率的方式——AIMD

线性增加或乘性增加，但这样都用一个方法就永远到不了公平点，只能在效率线附近抖动

所以我们有AIMD算法

即加性增加，乘性减少，这样就能抖动到效率公平点，如图

![image-20220716165756432](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220716165756432.png)

#### 慢启动

有了最大最小公平思想和AIMD思想，我们提出了一个实现最大最小公平的算法，就是慢启动

因为AIMD就是加性增加，乘性减少，则我们遇到拥塞信号时，我们就减少到原来的1/2，然后再加性增加

慢启动算法时如何是实现最大最小公平的呢？很明显，乘性减少对带宽占得多的流量影响更大，所以拥塞时，占得多的流量就会下降更多，这时由于加性增加，所有流量都是以同样速度增加的，所以小于平均值的流量就会先到达它所需要的带宽不在增加，而大于平均值的流量就会继续均分剩余带宽，从而实现最大最小公平

但我们还会发现，我们一直用加性增加的话，一开始我们想要到达拥塞的时间可能非常长，所以我们刚启动协议时或拥塞后是以指数速度增长的，即发出一个包，然后每收到一个确认，就发出两个包，如图

![image-20220716172236350](%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0.assets/image-20220716172236350.png)

但这样不就乘性增加了吗？所以我们需要设置一个阈值，到达这个阈值就加性增加，然后阈值等于当前的发送速度，若是遇到拥塞，则速度回到初始值，阈值减半，然后乘性增加，之后一直重复上述过程，如图（丢包可以认为是隐式拥塞控制）

![image-20220716171236216](%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0.assets/image-20220716171236216.png)

但其实我们一拥塞就让速度回到初始值挺蠢的，减少一半都可能会让线路上的流量大大减少，我们回到初始值，这样可能需要一定时间后，线路上的带宽才能得到有效利用

所以我们又有

#### 快速恢复

其他的都不变，就是拥塞后速度变为拥塞前的一半，然后加性增加（因为拥塞前的一半就到达阈值了），如图

![image-20220716171633896](%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0.assets/image-20220716171633896.png)

#### 慢启动和拥塞控制阶段的具体原理

![image-20220716172236350](%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0.assets/image-20220716172236350.png)

慢启动即每个ack都增加一个cwnd，然后每个rtt周期都发完，这就意味着必定增加自己长度，也就是说拥塞窗口长度翻倍。当然，如果一个rtt周期内到了阈值，这个周期内的剩余ack不会增加导致超过阈值，然后下个rtt周期则转到拥塞控制阶段的规则

![image-20231003160637343](%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0.assets/image-20231003160637343.png)

拥塞控制阶段一个rtt周期内如果收到了ack，那cwnd就加一。所以如果对面的接收窗口满了，我们这边不能发了，对面也不回ack，那无ack拥塞窗口自然不会增加

## 传输层的两个协议

前面讲了这么多概念和算法，现在终于可以讲讲TCP和UDP这两个协议了

## UDP

协议特点

- 无流量控制，无拥塞控制，无重传机制（这一切都需要用户进程去实现）（差错检查可选择做，只是错了不会重传）
- 和IP没有服务质量提升，只是增加了端口号，增加了多路复用，是心啊了一个端口号给多个进程复用的功能
- 支持广播和组播
- 块传输，数据有边界，不像字节流

#### 头部

由于UDP只想比IP多实现一个端口的概念，所以UDP的头部非常简单，如下图

![image-20220716202906911](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220716202906911.png)

- UDP长度，包括头部和数据的长度，所以最小长度为8（头部长度），由于IP包的总长度的限制，最大长度为65515（65535-20）

- UDP checksum，全0时表示没有校验，语音服务就不用校验。IP的checksum只计算头部，但UDP全要校验（自己的头，自己的数据，和一个概念性的IP伪头一起检验），伪头的校验主要是为了防止有些错误转发的包。当然UDP去校验IP层的东西违反了协议分层的原则

  校验的步骤就是16位当作一个二进制数进行校验和相加，奇数位的话就在计算时后面补零（数据本身不填充0的）

  ![image-20220716203919426](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220716203919426.png)

#### 常见的UDP应用

- DNS
- DHCP
- RIP



## TCP协议

协议特点
- 全双工
- 端到端，这就意味着不能广播或组播
- 字节流，这个主要是由Linux的文件思想而建立，所以没有边界你就要记得，想要边界的时候自己加边界

### TCP头部

![image-20220716212131298](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220716212131298.png)

- 可以看到这里并没有TCP数据长度或总长度的字段，那传输层是如何知道你这一段的数据部分有多长的？

  记得IPv4里有个总长度字段吗？或者是IPv6的有效载荷长度？那我们拿这玩意算一下（把各个头部的长度去掉就行了）就能得到TCP数据长度了

  那UDP的总长度拿来干嘛？这不是显得UDP很蠢吗？首先咱得遵守协议规范（笑死，自己校验就没遵守），别总想着绑着别的层的协议干活（所以我们常说TCP/IP，这两个就是连体婴），其次，这个长度还真是冗余，制定协议时发现还有空间就把长度装进去的。

- 咱也可以看到TCP有了序号和确认（为了重传），这里的确认指期望对方下一个发送的序号。而且序号和确认都是以字节为单位，因为TCP是字节流

- 由于选项部分必为四个字节的倍数，所以头长度的单位也是四个字节，因为头长度都只有4位，所以头部最长只能60个字节，除去前面必须的，选项部分最长40个字节

- 下面我们来说说那8个比特的标志位

  - CWR和ECE是拥塞控制信号，当接收端收到ECN信号，则ECE置1，发回发送端叫他慢点，发送端收到ECE后，将CWR置1，发回接收端，告诉他已经接收到了，已经放慢速度了
  - URG（Urgent pointer），紧急指针设置位，置1时表示紧急指针有效
  - ACK，确认段有效位，几乎所有包都用这个，只有和后面的SYN搭配的时候需要置0来表示不同的阶段
  - PSH，即刻推送位，置1后TCP将不会积累足够字节数后再发送，而是一有数据就发送
  - RST，重置连接位，一般用于重置连接或拒绝一个连接请求（拒绝别人的连接请求就是叫别人重置连接）
  - SYN，连接建立时和ACK搭配来表示不同的连接阶段，SYN表示发起连接，所以
    - 发起连接时SYN=1，ACK=0（因为还没有要确认的序号，所以ACK=0）
    - 回复发起连接，同步序号时SYN=1，ACK=1（因为第一次已经带了一个序号了，所以有ACK了）
    - 确认建立连接时，SYN=0（因为已经不是发起连接了），ACK=1
  - FIN，表示请求释放一个连接，也和ACK配合表示释放的不同阶段
    - 请求释放时，FIN=1，ACK=0
    - 回复请求释放时，FIN=0，ACK=1
    - 发送最后一个包时，FIN=1，ACK=1
    - 告诉对面已经收到最后一个包时，FIN=0，ACK=1

- 校验位，这玩意是一定要校验的

- 选项，介绍几个

  - 最大长度，MSS option：和连接的对方说自己的最大尺寸是多少，你不说，对方就默认为536字节的有效载荷，加上头就556字节。双方的MSS可以不一样

  - 窗口尺寸，window scale option：原来是接收端告诉发送端你能发的窗口尺寸，但原来设计标志的只有16位，最多只能64k的缓冲，那怎么办呢，于是有这个选择，双方可以协商拓展多少个位，最多14位

  - 选择确认，SACK，selective ACKnowledgement：这样接收端可以发送已接收的段的序号范围，这样发送方就知道哪个缺了，就能直接发对应的了

  - 时间戳，timestamp option：序号数多，但网速也快，那序号重复怎么办？所以我们加一个时间戳，老东西图图就行了



### TCP连接建立

就和我们之前说的连接建立一样做就好了

![image-20220718073450924](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220718073450924.png)

- SYN=1，ACK=0，附带序号询问
- SYN=1，ACK=1，用ACK进行序号同步（这里返回的序号是发送方的窗口序号，也是有用的），如果服务端没有进行监听就RST=1
- SYN=0，ACK=1，建立连接的确认，并使用前面同步的序号，上面返回的序号的下一位做ACK（肯定得有人开个序号的头，那就在这里开了）

初始序号选择：和时钟有关，其他协议都是从零开始的

### TCP连接释放

和之前说的一样

![image-20220718074809949](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220718074809949.png)

- FIN=1，ACK=0，发起释放连接请求，序号正常发就行，没有需要发的东西
- FIN=0，ACK=1，发回释放连接请求确认，此时的序号没啥用，确认号就是确认刚才的序号
- FIN=1，ACK=1，发回最后一个包，确认号还是上面的序号
- FIN=0，ACK=1，发出最后一个包的确认

### TCP滑动窗口

缓存区为0的时候，那对方就不能发了，那缓存区又有了的时候，而我的带着我缓存区长度的ack又丢了，那就死锁了。所以对方要能发一个字节探测一下你有没有缓存区，这个称为窗口探测

### TCP发送与接收如何提高效率

我们发送肯定不是有一个字节就发，这样头部都多长了，你才发一个字节，效率太低了；同样，我们也不会以收到数据就要发回ACK，这样太浪费带宽了，发送方总不会那么快把窗口用完，那具体算法是什么呢？那就是下面讲的nagle算法和clark算法

### nagle算法

很明显，20个字节的TCP头和20个字节的IP头，如果每次都发一个字节或每次都是很小的包，那利用率太低了，所以有nagle算法

- 收到ack就马上把缓冲区的东西发出去
- 缓冲区缓存到一半或者收到一个最大尺寸的段，那就马上发

所以有TCP option的PSH可以关闭这个算法减少延迟

### clark算法

我们窗口收到东西，或者从窗口拿东西，那剩余长度肯定变了，那一般人都是想着马上发回去，但这样要是机器一次就读缓存区的一个字节，那窗口立马更新，发回ack，那发送端又只能发一个字节，那这样下去效率太他妈低了，这个称为**愚蠢窗口综合征**

所以我们有了clark算法

- 拿了最大尺寸的字节或者缓存区只剩一半以下了，才发回缓存区大小

### TCP累计确认

收到的包会先放到缓冲区，发回的ACK是缓冲区的下界，所以TCP是累计确认

### TCP计时器管理

我们的包有时可能很久才到，有时可能很快就到，那我们要动态的调整重传计时器的上限

所以有

#### 雅各布算法

R：当前测得的延迟

a：平滑因子，一般取7/8

SRTT：真正的计时器上限

**SRTT=a SRTT+（1-a)R**

这种公式称为**指数加权移动平均**（EWMA，exponentially weighted moving average）

简单来说就是每次调整的计时器上限就根据以前的RTT和当前测得的延迟，用a去调整二者影响的占比，这样就能动态调整上限了

但现实使用中并不好用，因为这玩意对变化不敏感，所以雅各布又补充改进了几个公式

R：还是之前那个测得的延迟

SRRT：还是按原来那样算，但不是计时器上限了

RTTVAR：往返时间变化，即SRTT平滑后的动态值

b：另一个平滑因子

RTO：真正的计时器上限

**SRTT = a SRTT + (1 - a)R**

**RTTVAR = b RTTVAR + (1-b) | SRTT - R |**

**RTO = SRTT + 4 * RTTVAR**

简单来说就是我们对SRTT的变化值再做了一次平滑，再把平滑值的若干倍（这里取4是因为4倍直接移位就好，而且4倍也够用）加回去

#### karn算法

如果一个报文超时了，那我现在收到一个ACK，那这个ACK是第一个超时了的报文的ACK，还是超时后重传的包的ACK呢？那RTT的估计就会出问题，所以有karn算法

- 区别不了就不根据这个判断了，如果一个报文重传了，那这个报文测得的延迟咱就不用于更新SRTT了
- 但如果延时突然变得很大，你一直重传又不能更新自己的计时器上限，那怎么办？所以每次重传时，超时时间间隔加倍（其实提高就好了，传统做法是加倍）

#### 其他计时器

TCP不止有重传计时器，还有

- 持续计时器，用于下面的情况：接收端发回缓冲区为0的ACK，发送端知道了，不发了，然后接收端有空间了，发ACK给发送端，但这个ACK丢了，那由于clark算法，只有收到最大字节长度的包或缓冲区在一半以下（刚才那个ACK就是一半以下的消息，但丢了）才会发回ACK，那现在发送端也不发东西，接收端也没法再发ACK，那就死锁了

  造成这个问题的原因就是接收端缓冲区不为0时的消息传达不到发送端，那我们启动一个持续计时器，超时的话就看看当前缓冲区是否为0，非0就发回一个ACK，0就啥也不干；并且每次超时就重置计时，这样就能保证周期性地探测窗口

- 保活计时器，有些TCP协议实现了这个，即一段时间没消息了就发回一个包看看对面还在连接吗，没回应就终止连接

# 第七章——应用层

不想写了，自己看
