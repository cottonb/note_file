# 编译原理

# 总结概论

这是复习了一遍编译原理写下的概论

首先我们要知道编译原理是干嘛的。编译原理即尽可能快速地分析完整个高级语言程序，然后将其翻译成汇编语言。

首先做的就是分析，分析分三个过程，词法分析，语法分析，语义分析，这三个分析做的都是语法是否正确的分析，注意，编译原理的思想都是先判断程序对不对，再做翻译，否则在错误的程序下是无法翻译的。

词法分析是分析每个空格间开的词到底是什么词，是关键字，还是变量名，还是运算符，还是注释无视它。词法分析并不判断变量的类型，也不判断变量的作用域是否正确，也不关心前面是否声明，定义过这个变量，它只做一件事，分析一个字符串，然后返回这个字符串里的每个词的名字和类型。在类型分析的过程中，也会对词本身的语法进行检测，像是数字是$(0+1+……+9)^++(0+1+……+9)^+.(0+1+……+9)^+\ 正则式$，那么中间出现了英文字母，那肯定得报错

而在语法分析中，就会调用词法分析，遇到一个词就调用一次，得到变量名和其类型，进行语法分析。语法分析干的就是分析这一句里的语法是不是对的。比如我设计了一个算数表达式语法，这个语法的语法分析就要能分析我写的算数表达式是不是按这个语法来写的，不是，得报错。又或者语句的声明语法，比如int a,b,c；要检查这一句是否遵循语法，不对要报错。而到这里，我们就发现我们是使用语法去描述一个语言的，也就是说，只要是遵循这个语法的，都是正确的，且我们只要按照设计出来的语法，就可以解决问题了。语法最大的作用就是将复杂的表达分成了若干个式子，然后我们后面设计时，只需要对文法进行修改，并且对文法进行证明，就能保证编译程序的正确运行，不用担心是否新加入的东西是否会让原有的结构被破坏。这就是数学系统的封闭性和严谨性

而在语法分析中，我们主要有两种分析方法，一种是自顶向下分析，一种是自底向上分析。

我们先来想想我们自己是怎么知道什么时候该用什么产生式的吧。s->aB，s->bB，我们怎么知道什么时候用第一个，什么时候用第二个的呢？其实我们是看了当前读取字符的第一个，第一个是a，那我们就选一号产生式，第二个是b，那我们就选二号产生式，所以我们就产生了第一个想法，自顶向下，向后看一个字符，然后根据当前所处的非终结符和对应的产生式中，选择该非终结符对应的产生式，继续推导，这就是LL1文法，我们也可以从我们的推导过程看出，LL1文法不能允许一个非终结符的产生式中有两个及以上的产生式的开头字符相同，这样我们就真的不知道选哪个了

然后我们又有了第二种想法，我遇到终结符我们压入栈，一到可以归约的时候我就归约，最后归约到起始符，那就说明语法对了。这个想法就是LR0文法。但很多时候，我们所构造的文法并不是LR0文法，我们也没法把它转换成LE0文法，那怎么办？还是我们最开始的那个想法，往后看一个字符。一个产生式规约后，那么就会变成一个非终结符，非终结符后面的字符总有一个范围，如果我们归约时，其他产生式不会和我们同样的字符进行归约，或者别的产生式这时可以移进，但他们能移进的字符和我们归约的后面的字符不一样，那我们就可以归约，这就是SLR1，LR1，的思想。但这个范围是什么呢？SLR1简单地将规约后的非终结符的后面会出现一个字符作为其范围，而每一步后面的状态范围都可能不同，所以LR1就每一步使用每一步后面的状态范围，缩小了范围，使得文法能够翻译的范围更广了，但同时状态也更多了，那么就引出了LALR文法，将同样产生式的状态合并，后面的范围也合并，如果合并后还是没有冲突，那么就是LALR1文法

所以语法分析的思想很简单，判断一个文法是否能用，不能用的扔掉重新构造，而不是构造一个文法，不能用就改造。在LL1文法中，我们可以使用函数栈递归地去实现，在LR文法中，我们可以在移进时把终结符压入栈，在归约时弹出对应数目的终结符，然后压入非终结符，然后由于压入非终结符，又可以跳转到一个状态，所以我们弹出这个非终结符，然后到达另一个状态。所以我们又LL1分析表，也有LR1分析表，LL1分析表就是什么非终结符遇到什么终结符使用什么产生式，LR1分析表就是什么状态遇到什么终结符/非终结符，然后转移到什么状态/使用什么产生式弹出对应数量的字符

然后第五章我们讲述语法制导分析技术，这个到第六，第八章用到。实际上就是我们前面做了这么多分析，但实际上我们还没有对变量声明的类型进行保存，也就是说，我们前面声明了int a;，但我们怎么将int这个属性传入到字符表中的a的存储空间呢？这个就要用到语法制导分析技术。我们给每个变量增加属性值，比如int.type=1，那么a.type=int.type=1，那么这样我们就完成值的传递了。但我们现在只有通俗语言的表达，我们还需要数学表达，所以我们有了语义规则，讲述了每个产生式所要干的事情，有了分析树，形象的体现了语法分析的过程，有了依赖图/注释图，写明了每个非终结符的属性的传递过程，有了翻译方案，将语义规则的每一步传值做的时机写明白了。我们还提出了继承属性和综合属性的概念，在归纳前使用父节点的继承属性和哥哥节点的综合属性的叫做继承属性，最后归纳时赋值的属性时综合属性。可以将继承属性理解为进入非终结符前的参数传值，综合属性就是该非终结符的返回值。实际上语法制导分析这一章就是为了避免使用前驱图来得到每个节点的属性的赋值顺序才提出的继承属性和综合属性的概念，使得属性的赋值可以简单地使用栈便可完成属性的赋值。我们在LR文法的时候就已经使用了栈，那我们可以再加一个栈，要进入一个非终结符首先干的就是将继承属性赋值并压栈，归纳这个非终结符的产生式时，把压入的所有继承属性弹出，并把该终结符的综合属性压入栈，这样我们所有的属性的赋值，都可以根据产生式，知道当前我们需要的值相对于栈顶的偏移是多少，就可以在语法分析的时候完成属性的赋值，爽的不行

第六章就讲了我们怎么分析作用域下的声明。即我们怎么知道当前作用域下用的是哪一层作用域的声明，或者有无声明。作用域采用的是最近原则，找不到往外层找，所以我们进一个作用域时，就把此时的声明过的变量的栈的位置压入定位栈，这个过程就叫定位，然后出这个作用域时，就需要把这个作用域的声明全部弹出，那么我们声明变量栈就要回到定位栈栈顶指向的位置，这个过程就叫重定位。当我们遇到一个不是在声明的变量时，我们从声明变量栈的栈顶开始往下找，如果找到一个，那就说明声明了，如果没找到，那说明没有声明。在检查的过程中我们同时构建了符号表，分配了传入参数和函数内声明的变量的空间，并在每个函数的开头记录了传入参数的空间大小和函数内声明的变量空间的大小，还有每个变量相对于该函数的其实地址的相对偏移，这样我们的空间就分配好了（虽然不知道为什么这里声明的函数变量的符号表的指针不占空间）

第六章我们还讲了类型等价和名字等价。像是我们可以给int去type int kkk，这样kkk的类型和int的类型实际上是等价的，我们希望能相互赋值。所以我们讲述了类型表达式，说了怎么判断类型等价。但只是类型等价不行，像是我们如果要判断结构体的类型等不等价，我们就需要不断的判断结构体内的变量的类型等不等价，这不仅很浪费算力，而且如果我们在结构体内声明结构体指针，那么我们使用类型等价就会陷入死循环。所以C在结构体使用名字等价，即给结构体命名的名字相同，那就等价，否则不等价；而且结构体内声明的本指针直接判断是否与本结构的名字相同即可，不会陷入死循环

第七章我们就讲了运行时数据的存储，开头讲了数据存储可以静态，编译的时候就全部，是全部，就确定好，这就意味着不能调用函数，否则就会存在递归调用；然后讲了可以栈存储，又讲了堆存储，这就是目前的三大存储方式。需要注意的是，在讲三大存储时，书里的每个存储方式都是纯这样的存储方式，而c是栈和堆结合的存储方式。而堆存储和栈存储的最大不同，就是堆不会弹出栈顶，而是保留到调用删除。另外c的可变数组实际上是把到了可变数组就在栈顶开一片空间，这样就可以实现可变数组了

第七章还讲了控制栈的结构，一个函数的栈可以分为返回值，参数域，控制链，访问链，机器状态域，局部数据区，临时变量区。首先我们要知道，控制链，访问链是个指针，而机器状态域是记录了进函数时前的寄存器的状态，出函数时需要还原的，所以这三个都是定长的。然后局部数据区的开头的地址称为top_ep，栈顶地址称为top_sp，而返回值，参数域的长度进函数的时候就定了，那么这也是个确定的值，那么我们就可以用top_ep去反过来找到压在栈的第二个top_sp，这样我们弹栈的时候就能知道弹到哪了。但上一个的top_ep我们没法确定啊，我们怎么回到原来的函数恢复top_ep呢？这就是控制链域的意义，其存储的就是调用者的top_ep，这样就可以恢复top_ep了。然后由于top_ep指向的是局部变量的开头，那么我们通过第六章字符表的里偏移量就可以找到对应变量，而top_ep又可以找到上次的top_sp，而top_sp又可以通过偏移量访问参数，这样一个top_ep就能访问所有的值，包括恢复时需要用到的控制链，访问时用到的访问链。

我们再来聊聊访问链，访问链是嵌套定义的产物，即能访问的数据只有所在函数和所在函数的外围过程的定义的变量。像是c就没有嵌套定义，即一个变量只能在全局或函数内定义，而函数只能在全局定义，不能在函数里定义函数；而嵌套定义即可以在函数里定义函数，例如函数a定义了函数b，那么函数b能访问在a中，在b之前定义的变量/函数，而a又称为b的外围过程。所以为了实现这种语法，弄出了一个访问链，其指向栈中最近一次的自己的直接外围过程的top_ep。不过这样我们也可以看到在建立访问链的时候，如果直接外围比较浅，那么我们就需要跳多次去建立访问链，所以我们整了一个display表，里面记录了每个深度的最新活动的函数的指针，而函数栈里的访问链指向上一个活动的同样深度的top_ep，这样就快了，但这样的深度也受display表的长度限制了

第七章我们还讲了传参数的方式。传值， 传引用，复制恢复，传名。前两个就不说了，复制恢复是传值进去，然后出来时再把出来时的值赋值回去，这个方式在传全局变量时，由于是传值进去，所以里面的变量并不是全局变量，所以有全局变量的修改的地方会和其他不一样；而传名就是将函数直接粘贴到对应地方，然后把参数名换成对应的参数，这样的做法在参数是数组相关时，就会出现和传引用不同的情况。c采用的是传值，java采用的是基本类型传值，对象类型传引用

第八章讲了如何生成中间代码，中间代码即三地址语句，可以用四元式/三元式来表示。其实后面的都是介绍文法给你了，翻译的过程其实靠人脑是可以想到的。更多的去看平板笔记吧

第九章讲了什么是基本块和流图，在基本块的基础上，我们讨论了如何判断一个变量是否活跃，然后根据活跃情况，来分配寄存器（这里会给个文法，不用背文法，知道文法在干嘛就行），将中间代码翻译成汇编代码，更多的看平板笔记吧

第十章讲了如何优化代码，主要讲的是优化中间代码，都是一些简单的技巧，没有讲文法。后面的窥孔优化就是随机检查一段代码，如果有可以优化的地方，就优化。注意我们学的优化都是基于基本块的优化，别两条语句属于两个基本块你也给优化了，不同基本块间的优化是一个np问题，别想了

# 概论

编译就是把源语言转换成目标程序的过程（从高级语言到计算机可识别的二进制语言）

毕竟我们高级语言写出来的文件只是一个文本文件，要经过编译后产生二进制的可执行文件（比如.exe文件）才能运行（其实我们也知道高级语言的编译是先汇编再机器语言，但其实就是经过几次编译，我们看起来只编译一次罢了）

高级语言的意义就在于提高编写程序的效率，是面向人的，并不意味着用高级语言能提高机器执行的效率（你能用汇编做程序那效率嘎嘎高），而且高级语言独立于机器，不至于编出来的程序不能移植

## 翻译程序

翻译程序包括编译程序和解释程序

### 编译程序

将一种语言翻译成等价的另一语言的程序称为编译程序，编译出文件后，计算机执行这个文件，然后载入数据

### 解释程序

能从源程序直接执行得到结果的的程序称为解释程序，不用编译出一个文件，一遍翻译源程序，同时载入数据即可

### 二者差别

前者事先翻译完，然后照翻译完的结果去做；后者执行到哪里，就翻译哪里，然后执行

这样解释程序的效率就比较低，到循环语句时，循环多少次，就要翻译多少次，这样就很烂。解决方法是先翻译成中间的某种形式，然后再去解释，能避免一些重复劳动。解释程序的优点是实时性好，跨平台性好

java就是编译和解释并用，平时用解释，到一段重复性高的部分就把它编成机器语言去执行。用了虚拟机技术使得java跨平台的效果好很多，而效率也不低

## 编译阶段和任务

- 分析阶段
  - 词法分析
  - 语法分析
  - 语义分析
- 综合阶段
  - 中间代码生成
  - 代码优化
  - 目标代码生成
- 符号表的管理
- 错误诊断和处理

![image-20220905134706304](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220905134706304.png)

### 词法分析

这个就是把语句的每个单词所属的类别（比如是程序原有的关键字，或者普通的标识符，或者数字等等类别），对应的内存空间做好对应，填入符号表

### 语法分析

就是把句子的结构分析出来

### 语义分析

做类型检查，检查运算符，数组下标，式子里的运算对象（比如数组和整数相加），形参的个数和类型等等是否符合要求，然后能处理的处理（比如加入一个转换符，把定点数变成浮点数）

### 中间代码生成

中间代码就是易于产生，易于翻译成目标语言的代码

### 代码优化

先对中间代码进行优化，比如我们之前说的在定点数前面加转化符变成浮点数，这句话其实就可以优化为浮点数，不用再做转化的语句

### 目标代码生成

干的就是生成目标代码，要注意的是对变量的内存和寄存器的分配

### 符号表管理

就是各个单词的意义的记录的数据结构，还要能快速地找道对应的标识符

当然区别标识符和关键字的工作是词法分析干的

### 错误处理

编译一次要能给出足够多的错误，不能一次只给出一个错误，这样太浪费时间了。而且要给出错误位置，性质和具体信息

## 编译有关的概念

### 前端和后端

前端就是那些和源语言有关而与目标机器无关的部分组成

- 比如三个分析，符号表，中间代码的生成
- 与机器码无关的代码优化
- 错误处理

后端就是和目标机器有关的部分，这样便于移植

### 遍

对源程序或中间程序扫描一遍称为“遍”

所以有

- 一遍扫描的编译程序
- 多遍扫描的编译程序

#### （分遍）多遍的优缺点

优点

- 对内存容量的要求减少
- 使各功能独立，联系简单，结构清晰
- 更好地优化
- 使前端和后端分开，方便移植

缺点

- 很明显，一遍能做完的事你做了多遍，那肯定做了不少重复的工作

# 词法分析

## 缓冲区

首先我们读单词的时候需要弄一个缓冲区，因为我们可能读了一个符号，需要往后读一定的字符，才能确定一个单词的性质（如“\==”，我们需要再往后再读一个字符才能判断这个是“=”还是“\==”)，还有一点就是因为从外存读到内存是一块一块读的，所以外存和内存之间要有缓冲区

### 读出单词

那咱就弄一个缓冲区，开始指针指向单词的开头，向前指针一开始和开始指针指向同一字符，向前指针指向的字符不是空格就往后走，走到空格为止，这样就拿下一个单词了，最后向前指针再往后走一个字符，开始指针和向前指针指向同一个字符，这样就回到开头了

### 分步更新缓冲区

但无论我们缓冲区弄多大，我们都不能保证程序读完了，或者说我们需要在一定的时机得更新一部分缓冲区，且更新的部分不能把还没词法分析的单词就更掉了，因为我们这里做的还只是弄出每个单词，还没进行词法分析。那我们就把缓冲区分成两半，向前指针读到左半边缓冲区终点时，就更新右缓冲区；读到右半缓冲区终点时，就更新右半边。指针指到缓冲区终点时，在走一步就回到缓冲区起点，所以这是个循环数组，分两半更新

### 实现和改进

所以用高级语言来说就是向前指针指向左半缓冲区终点或右半缓冲区终点时，更新对应半边缓冲区。但这样每次读一个字符就要判断左右，共两次，但只有在终点时才判断成功，这样浪费太多了。所以我们再改进一下，左半和右半的终点不填一般字符，填EOF，当向前指针指向的是EOF时，再判断是否左右终点还是文件结尾，这样就不用在常常遇到的非终点的字符判断两次，而在很少遇到的终点判断多点，这样就能提升程序运行的效率。这就是哨兵的作用

## 记号

记号就是词法分析的结果，输出。词法分析就是把每个单词的类别，标号写进符号表，方便后面去查的时候直到是哪个单词，类型是否正确

记号是一个单词的编码，带有单词所属的类别和附带信息，附带信息称为属性，不需要属性也够用的记号就可以不带属性。属性可以为指针，也可以为整数值，等等。例子如下图

![image-20220919134100918](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220919134100918.png)

## 模式

就是描述区分记号的规则

## 记号的描述和识别——正则文法

用来描述单词的方法叫词法；借助记号来描述语言结构的方法叫语法。所以有了词法分析和语法分析

词法分析我们用正规文法描述，语法分析我们用上下文无关文法描述

词法分析用正则文法描述一个记号，用自动机去输出记号

下面是一个判断的逻辑表示

![image-20220919140836923](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220919140836923.png)

可以看到我们高级语言的各种奇奇怪怪的规则都是为了词法分析时方便分析

然后用状态转移图表示

![image-20220919141432671](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20220919141432671.png)

然后我们按这个状态转移图用高级语言写词法分析就好了

当然后面有软件可以根据正则表达式给你写出c语言的程序，这个软件叫LEX

## 软件工具LEX

# 语法分析

词法分析的输入是字符串，语法分析的输入是记号

在一遍分析的语法分析中，是以语法分析为中心，当需要记号的时候调用词法分析

## 常用的分析方法

- 自顶向下
- 自底向上

两种方法对记号串的扫描都是自左向右的

## 语法错误的处理

### 错误的种类

- 词法错误
- 语法错误，算术表达式的括号不匹配等
- 语义错误，如算符作用于不匹配的运算对象
- 逻辑错误，如无穷递归

### 错误处理的基本要求

- 有错误能检测出来
- 能检查出尽可能多的错误，所以检查出错误要尽快恢复，继续下一次的检查
- 效率要够高

报告的错误至少应该报告出检测到的位置

错误的恢复遇到的困难是不妥当的恢复会产生大量的错误

### 错误恢复策略——没有明显差距

- 紧急方式恢复
- 短语级恢复
- 出错产生式
- 全局纠错

## 自顶向下分析方法

就是从起始符开始，能推导出的句子，那就是能识别的句子，就能得到要做的事。其实就是试探，不断地去试，试出了结果就行了

### 递归下降分析

就是从起始符开始试，遇到一个非终结符就用文法的一个右式代替，看看当前指向的终结符能否和目前推导出来的终结符相等，等的话就继续往下替换，全替换完了就能识别

#### 遇到的问题

- 左递归——可以消除左递归
- 回溯，匹配到一半发现匹配不上就得回头做
- 相当于穷举法，效率很低，没有实际应用的意义

### 递归调用预测分析

我们不能提升递归树本身，也找不到更好的算法，那我们就从输入改变，通过限制输入使得算法得以实现

那我们就限制文法，使其根据面临的输入的符号能确定能用哪个候选式

- 如果匹配成功，那么后面就不会有问题
- 如果不成功，那肯定是无法匹配，不存在一个能匹配的候选式，不需要回溯

简单来说就是我遇见一个符号，那我就知道用哪个产生式，并且是唯一的选择，没有选择就说明不能匹配了

那么就有一个很简单的实现方案

#### 文法限制方案1（可行，但限制过大）

- 所有产生式的右部都是以终结符开头
- 所有左部相同的产生式，右部都是以不同的终结符开头

这样从S开始，每一步都只有一个选项了

但这样文法限制性太大了，我们用的话自己都构造不出来

那我们再提一个宽松点的实现方案

#### 文法限制方案2（不可行，还需加以限制）

- 左部相同的产生式，右部开头是不同的终结符或非终结符
- 文法中无空产生式

这里就把“右部开头都必须为终结符”这一条去掉了，但相应的，我们要加上“左部相同，右部开头为不同的非终结符或终结符”这一条，这样换上非终结符了，非终结符也只有一个选择，这样就能保证每一步只有一个选择了

但这里还有个问题没有解决，我们每一步是不一样了，但开头是终结符的时候，我们只要和字符串比对一下就知道了该选哪个；但开头是非终结符的时候，非终结符套非终结符，每个都这样套，那我们怎么知道选哪个非终结符对应的产生式？我们要是知道还要限制文法干嘛?

那我们回到限制文法1的思路。限制文法1为什么能够成功？因为右部的开头都是终结符，我们能根据终结符选产生式。那我们现在为什么不知道选哪个产生式？因为我们开头都是非终结符的时候，我们没法和读入的字符串比较选择了。那换个思路，我们要是能知道每个非终结符往后推导所能推导出开头的终结符集，那这样不就能把限制文法2等价于限制文法1了吗？

这时候你就会发现，我们还需要限制每个产生式的右部开头的非终结符能推导出的开头终结符集都不相交才行，不然两个不同的非终结符，最后能推出两个相同的开头终结符，那就有两个选择了

所以我们后面提出了FISET集的概念

但这样还是不够，因为如果文法中有空产生式。举个例子：

> S->AAAa
>
> A->空|c
>
> 那么对于字符串ca，你就可以看出有多少种可能了，A全空，那自然匹配不上，但很明显这里是能匹配上的，那我们就要为这可能性付出回溯的代价，一个回溯了，那么其他就不能保证没有回溯了
>
> 那你肯定会说，那在所有产生式都匹配不上的时候再用空产生式试试呗
>
> 那咱再构造一个文法
>
> S->AcA
>
> A->cB|空
>
> B->d
>
> 那对于字符串ccd，你一看A的cB能匹配上，立马用cB换上了，那最后肯定匹配不上，必须要A先空再为cB才行。那有这种可能性，那你又得回溯
>
> 这里的问题就在于遇到一个字符，空和非空产生式都有可能，并不存在二者哪个更优先的问题，所以你并不确定哪个是对的，做完一个选择还得回溯
>
> 这就是不确定性的代价，因为不确定，你无法立刻决定是否错误，因而要用回溯来弥补不确定性

我们懒得处理了，所以我们还要加上一条，“文法中无空产生式”

#### 限制文法3（LL1文法）

我们对文法进行最后一次的限制，得到真正能用，且限制条件尽可能宽松的的文法

限制文法2不是不能用空产生式吗？我们觉得对允许空产生式出现的条件再加以限制，就能用空产生式了，且这样文法就能尽可能宽松了

那再回头看看加了空产生式为什么会有两种选择吧。假如代入了非空产生式，还要回头试试空产生式是因为我们怕后面刚好能匹配上，即后面的字符串的FIRST集和字符串相同，而能代入非空产生式，说明非空产生式的FIRST集也和字符串相同。

那么假如，空产生式的后面的FIRST集和非空产生式的FIRST集不相交，那么非空产生式匹配上的时候，空产生式不可能匹配上；空产生式匹配上的时候，非空产生式就不可能匹配上，那这样我们就不需要回溯，匹配不上就是匹配不上

然后我们把S能推出的句型中，非终结符A后面所能出现的字符串的FIRST集称为FOLLOW集

然后前面提到的，FIRST集就是一个字符串所能产生的终结符串的开头的终结符的集合

下面我们详细正式地介绍LL1文法

### LL1文法

咱先把FIRST集，FOLLOW集的概念讲清楚

#### FIRST集

> $$a,b是终结符和非终结符组成的字符串$$
> $$t是终结符\\$$
> $$则FIRST(a)定义为$$
> $$FIRST(a)=\{t|a能若干步推出tb \}$$
>
> 不能把a改为了非终结符或终结符，因为FIRST集也接收 空，如果a能推出空，那么FIRST集就要加上空，如果不是字符串，那空的情况就没法体现了（空的时候开头终结符取决于下一位）
>
> 

#### FOLLOW集

> $$起始符S，非终结符A，字符串a,b，终结符t$$
>
> $$FOLLRW(A)=\{t|S能若干步推出aAb，t\in FIRST(b)\}$$

可以看出FIRST集的参数是字符串，而FOLLOW集的参数是非终结符

到这里我们都是贯彻一个理念，我们要把文法等价于限制文法1，让每个产生式的右部的开头的终结符都不相同（空产生式就相当于看后面那个开头的终结符了） 

#### LL1文法定义

对于一个文法G，其中**任意**两个同左部的产生式，如A->a|b满足以下条件

- $$FIRST(a)\cap FIRST(b)=空$$
- $$a,b最多只能有一个推出空$$
- $$若b推出空，则FIRST(a)\cap FOLLOW(A)=空$$

简单来说就是，左部相同，那么右部不能推出相同开头的终结符的情况（FIRST对应开头为非终结符推出非终结符的情况，FOLLOW对应非终结符为空时的情况）

因为我们是根据输入字符串的第一个字符进行选择的，所以就相当于提前看了一个字符，又因为是从左边读的（所以要消除左递归），所以LL1的意思就是 Left Look 1，即从左提前看一个进行选择（预测，虽然我觉得把选择称为预测很蠢）。当然还有LL(k)，即提前看k个字符，但这里不讲了

我们再把上面的条件整合一下就能得到以下的LL1文法的表达方式

#### SELECT集

对于一个产生式$$A\rightarrow a$$

- $$当a推不出空时，SELECT(A\rightarrow a)=FIRST(a)$$
- $$当a能推出空时，SELECT(A\rightarrow a)=(FIRST(a)-\{空串\})\cup FOLLOW(A)$$

简单来说就是，$$SELECT(A\rightarrow a)$$就是产生式$$A\rightarrow a$$代换后（包括a为空的情况），开头所能出现的终结符集

#### LL1文法的SELECT形式的定义

对于文法G，左部相同的任意两个生成式，如$$A\rightarrow a, A\rightarrow b$$，满足以下条件

- $$SELECT(A\rightarrow a)\cap SELECT(A\rightarrow b)=空，且a,b至多一个能推出空$$

简单来说就是，每次代换，不同代换能推出来的开头的非终结符集不能相同，否则就会有不确定性，你做完一个选择就会怀疑会不会在另一个选择里能找到答案

### LL1文法的判别实现

前面说了这么多，还没说怎么找到FIRST和FOLLOW，还有LL1文法的判别实现，那这里就来详细讲讲

#### 能推出空的非终结符的计算

1. 用一个数组记录各个非终结符是否能推出空，并全初始化为“未知”
2. 把右部有终结符的产生式删除。没有产生式（被删完了）的非终结符改为“否”；右部为空（直接推出）的非终结符改为“是”；之后所有确定了状态的非终结符，都要把以它为左部的产生式删除
3. 扫描右部的每个符号k。
   - 若k为“是”的非终结符X，则把该产生式的X删除，表示取空；若做完这个操作为空，产生式右部为空，那么把产生式左部的非终结符改写为“是”
   - 若k为“否”的非终结符X，则把该产生式删除；若做完这个操作后，左部的非终结符没有对应的产生式（产生式左部没有它了），那么把该非终结符改为“否”
   - 重复步骤3，直到所有非终结符的状态不再变化

#### FIRST集的计算

我们先来计算单个字符的FIRST集

X为终结符或非终结符，a为开头的终结符。我们计算FIRST集的方式是往对应的终结符或非终结符加入算出的终结符

步骤如下，2~4步是需要重复到所有的单字符FIRST集都不再增大的时候

1. 若X为终结符，则FIRST(X)={X}
2. 若X->a……，则把a加入FIRST(X)
3. 若X->空，则把 空 加入FIRST(X)
4. 若X->Y1 Y2 ……Yn，且前 i 个 Yi 能推出空，那把 Y1~Yi 的FIRST集加入到 FIRST(X)中，若 i<n，那说明最后有人托底，那集合里的空记得去掉

然后我们再求右部字符串的FIRST集

- 把字符串b里涉及到的前 i 个能推出空的单字符FIRST(X)都合并到一起，不是所有的FIRST(X)都有空时，就要记得把空去掉

#### FOLLOW集的计算

要先算出所有的FIRST集

重复步骤2直到所有FOLLOW集不再增大

1. 设句子终结符号为\$，并把\$加入到 FOLLOW(S)里 
2. 若 $A\rightarrow a B b$
   - 把FIRST(b)加入FOLLOW(B)中
   - 当b能推出空时，再在原来的基础上，把FOLLOW(A)加入到FOLLOW(B)中（因为b空了，那么B后面的就是A后面的东西了）（所以起始符产生式的右部，末尾为非终结符X时，可以看作X后面是空，那么产生式左部的FOLLOW集要加入FOLLOW(X) ）

#### LL1文法的判别

1. 求所有能推出来空的非终结符
2. FIRST集的计算
3. FOLLOW集的计算
4. 按照定义计算SELECT集
5. 查看相同左部的SELECT集是否相交为空，都为空，则该文法是LL1文法

可以看到我们做了这么多，仅仅是为了判断一个文法是否是LL1文法，甚至还不能用一个算法去构造LL1文法，不过这也足够了

#### 某些非LL1文法到LL1文法的变换

先不写了，自己回去看书，就是提左公因子，消除左递归（先排队替换再消）之类的，可以去看作业2的4.5，4.7

### 非递归预测分析

之前我们实现LL1文法不都是用递归来实现的吗（咱现在不是在说LL1文法的判断），那现在我们就想要消除递归，所以叫非递归预测分析

其实就是用一个队列去存字符串，我们再构建一个分析表（就是根据队列的第一个字符选择用哪个产生式的表），然后替换后的开头的终结符对应得上，那就继续，直到结束；对应不上就结束，报错

## 自底向上的分析

就是从字符开始一步一步得向上归约，得到起始符就表示语法正确

有几种自底向上的分析

- 简单优先级分析
- 算符优先级分析
- LR分析

简单优先级太烂了，算符优先级效率高，但限制很大，只能用于算式表达式

所以我们现在只介绍LR文法，且LR文法能分析的文法类确实比LL文法分析的文法类多，且无回溯，且读入一个符号，就能立刻知道是否有问题

在介绍LR文法前，先介绍句柄，最左归约（规范归约）以及自底向上分析的过程

前面LL文法是最左推导，而这里的LR文法是最右推导，从而能够最左归约

而句柄就是每次归约的单位，简单来说就是推导树里只有父子树（不能有孙子往下的子树）的相关节点。而归约句柄的过程就可以理解为把逆推得到一个产生式的左部过程

所以最左归约就是从最左的句柄进行归约

而自底向上的分析过程主要就两步

- 移进：把缓冲区的字符压入栈
- 归约：把栈顶附近的串归约得到一个非终结符

那么我们什么时候移进，什么时候归约呢？我们其实很容易遇到两种会有问题的情况

- 现在可以归约了，但这里的正确的执行应该是先移进再归约。我们怎么知道什么时候移进，什么时候归约
- 现在可以归约，但归约有两种归约，选哪种归约

所以我们提出了LR文法

我们先讲一下LR文法的思路，首先和LL文法一样，我们并不打算解决冲突，或是避免，消灭冲突，而是要在部分冲突中做出选择。冲突是必然的，像是我们的自然语言，一个字，一个词，一句话都会有多种理解，但我们依旧能在大部分情况下正确理解（理性人情况下），我们是怎么做到呢？那我们肯定会说到语境，或者说是结合上下文理解，那这样我们就知道了，在文法中，只要我们设计的文法（对，我们这里研究的都不是怎么产生一个文法，而是设计一个文法，看看它是否满足一些性质，满足的话就能用而已）在冲突的时候，我们往后看若干个字符，如果冲突的每个选项的后面的字符组合都不一样，那我们就可以区分了，这样这个冲突就相当于不存在了。

然后如果我们设计的文法所有的冲突都能通过上面这种方式解决，那么就可以用了，如果还有冲突，要么你选用的文法规则还不够细化，比如后面讲的SLR和LR之间的区别，导致你在一些能区分的冲突不能区分，要么就是你这文法本来就是有二义性的，这些冲突本来就是不能区分的，那么你这文法设计就是有问题的，不能用的。

所以我们说的文法就不可能是二义性文法，或者说设计出二义性文法，该去解决的是那个设计的人的脑瘫，而不是一帮人抓耳挠腮地想着怎么帮他解决二义性冲突。而不是二义性的文法，那么就必然存在一个确定的最左推导和最右推导，上面我们LL文法的思路就是顺着最左推导，沿着产生式的方向走，而这里我们就是使用最右推导进行归约。在解决了上面的能解决的冲突后，我们就不可能遇到冲突，因为只要它是LR文法，就不存在无法解决的冲突，如果有，那说明这个文法就不是LR文法，我们在用这个文法的时候就已经错了（你肯定知道一个文法有没有无法解决的冲突的，所以知道有无法解决的冲突还要用那就是你自己纯纯的脑瘫了）

顺便一提，FIRST集和FOLLOW集都是相对于文法的概念，而向后看的字符是相对于读入字符串的概念，文法和读入字符串之间屁关系都没有。FIRST和FOLLOW都是为了解决文法本身的冲突而提出的概念，它们本身并不知道读入字符串的存在

上面说了这么多，那我们现在就从LR0文法说起吧

### LR0文法

这个文法没有做任何的冲突处理，所以相对于后面的SLR1，LR1，LALR1来说，所能使用的文法范围更小，毕竟很多冲突不处理，那文法就不能出现冲突，那文法的限制就很大，所以范围很小

LR0文法的核心思想就是文法既然可以用自动机来模拟，我们LL文法也用了自动机来模拟了，那我们LR0文法也可以用自动机来模拟。而且由于我们无视所有的冲突，所以在下面我们先默认没有冲突，有冲突的时候我们再找出来作为我们的反例来说明

那我们既然要用自动机，那我们是一个产生式一个状态吗？很抱歉虽然我们很想这样做，但我们的产生式都是为了递推而存在的，并没有已经读了几个字符的表示，这就导致我们没法直接用这些产生式来归纳

所以我们往产生式加了“·”，这个符合后面的第一个字符为准备读入的字符，如图

![image-20221022151157673](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221022151157673.png)

S'->·S遇到非终结符S时，就变成了S'->S· 了，这样我们就有产生式可以做自动机了

加了 “·” 的产生式称为 LR0项目（不是文法），具体规则如下

![image-20221022151509060](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221022151509060.png)

当圆点在产生式右部的末尾时，必须执行归约动作（我们默认没有冲突），并且用的是所在产生式进行归约，这个产生式就叫归约项目，表示要进行归约

而能把起始符S归约的话，说明识别成功，但S是起始符，没有哪个产生式能S'->S·，所以我们弄出了一个产生式S'->S，这样最开始就是S'->·S，最后归约是S'->S·，这样就能完成S的归约并接收了。所以增加了S'->S的文法叫增广文法，S‘->S· 称为接收项目，表示要接收

而如果圆点后面的符号是终结符，那么就要移进（默认没有冲突）（注意，我们所说的圆点后面的符号并不是指我们读的字符串的符号，而是文法里的圆点后面的符号。我们现在讨论的是一个文法如果遇到圆点后面的符号该变成什么状态，而不是读入字符串的第一个符号是什么的时候该变成什么状态）（圆点后面的符号对应我们文法所期待的栈顶的符号，读入字符串的第一个符号对应字符串队列的第一个符号，这是完全不同的。这也意味着当我们栈顶真的压入了文法所期待的符号，我们就能从当前状态走向文法所对应的下一个状态）

如果圆点后面的符号是非终结符，称为待约项目，为什么呢？举个例子

![image-20221022153537628](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221022153537628.png)

![image-20221022183205726](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221022183205726.png)

图中黄色部分就是增广文法，那我们就看S'->·S，现在我期待我栈顶有个起始符S，这样我就能直接到项目I1，即 S'->S·，我就希望能接收，即此时读入字符串就剩个末尾符号\$了，那我就移进，如果栈顶真是\$，那好，我直接接收。但哪有一开始就给了你一个S的，读入字符串里没有非终结符，你想要非终结符，得读入字符串的终结符，然后归纳得到非终结符，然后压入栈才行，所以我们期待一个非终结符A，实际上也是在期待这个A的产生式，所以I0本来只有S'->·S，但我们不仅在期待着S，还在期待着S的产生式，所以I0就多了两条S的产生式S->·aA, S->·bB，所以圆点后面的字符是非终结符时，该项目称为待约项目。一个状态每加入一个待约项目，就要把该待约项目的圆点后面的非终结符对应的产生式加入到该状态，最后状态所呈现的产生式的集合也称为对应的产生式的闭包

所以总而言之有四种项目

![image-20221022163332792](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221022163332792.png)

在不同的文法里（LR0, SLR1, LR1, LALR1里），LR0项目对应的



![image-20221022165120097](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221022165120097.png)

![image-20221022165133540](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221022165133540.png)

![image-20221022165146197](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221022165146197.png)

![image-20221022182810579](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221022182810579.png)

![image-20221022182925465](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221022182925465.png)

![image-20221022201606491](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221022201606491.png)

LR0每走一步，就是往栈里压一个符号，走到下一个状态，而归约就是弹出若干个符号，然后压入一个非终结符，一个符号对应一个状态，那么弹出多少个符号，那就要弹出多少个状态，压入一个非终结符，那就要压入一个状态，而压入的状态就是未压入终结符前的状态要往这个非终结符方向走的状态。记住压入任何一个字符，都是往这个字符对应的方向去，无论这个压入是从读入字符串里压入的，还是归约后压入的



SLR1怎么解决冲突？其实解决的是一个状态里的冲突，然后一个一个状态地去解决，移进的是一个终结符，归约后得到一个非终结符，这个非终结符后面总会跟一个终结符，所以只要移进和归约和归约之间的后面跟的终结符集不同，那么我们就能做出选择

LR0怎么解决冲突？LR0不打算解决冲突，要么一个状态全是移进-待约项目，要么只有一个项目，那就是归约项目

LR1怎么解决冲突？就是对SLR1的细化，SLR1归约的时候不是用FOLLOW集来区分吗，但一个产生式后面跟的集合大部分情况下只是FOLLOW集的子集，那我们在一个状态里，想要归约的时候就认为是FOLLOW集里的字符就归约岂不是扩大范围了？我们应该区分出每一个状态的待约状态在后面归约回来后，用不同的字符集区分，所以我们提出了LR1项目集的概念，每个状态一加入待约项目a，还是会把待约项目对应产生式k加入，并且由于k是a产生的，这就意味着想要用a来归约的话，就会走k的道路，最后会从k的道路归约回来得到a，并用a归约，那么这一整条道路和其他道路的区分就在于a后面的FIRST集的不同。所以我们的k的区分符号集就是a的非终结符后面的FIRST集

LALR1怎么解决冲突？LALR1本身并不打算解决冲突，它只是想把LR1的状态减少，至于减少后是否会产生归约归约冲突，它不关心（不会产生移进归约冲突的），合并同心集后，如果没有归约归约冲突，那这个文法就是LALR1文法，就可以用，如果冲突了，那说明对应状态是不能合并同心集的

LR0和SLR1的区别就在于SLR1会根据归约后的非终结符的FOLLOW集去填表，而LR0只会把一行都填上

总而言之，所有的冲突都是发生在同一个状态里的，如果任何冲突处理的手段，那么移进归约冲突就在于一个状态里同时存在归约项目和移进-待约项目，我根本不知道该选哪个产生式，而归约归约冲突就是一个状态里存在多个归约项目，我也不知道该用哪个产生式。而我们解决的办法就是根据移进的字符和归约后的非终结符后的字符不同来选择不同的产生式。这时的移进归约冲突是一个产生式的移进字符和另一个产生式的归约后的非终结符的后一个字符有重叠，所以不知道该选哪个产生式，归约归约冲突也是两个产生式归约后的非终结符后的字符有重叠，所以合并同心集冲突的产生就在于合并后，两个产生式之间移进字符和归约后的非终结符后的字符，归约和归约的字符的重叠导致的。举个例子

I1: A-> c·,d	B->c·, e

I2: A-> c·,e	B->c·, d

那么两个状态合并后就变成了

I3: A-> c,d/e     B->c·, d/e

那我们遇到d或e的时候，我们到底该用A的产生式还是B的产生式来归约呢？所以这种情况下就不能用合并同心集



没有归约，就不会有冲突

有个问题，只合并一部分同心集是LALR1文法吗



















# 语法制导技术

继承（inherit)

综合（synthetical)

继承属性传参，综合属性返回值，非终结符看作一个函数

实际上语法知道都在想办法约束属性传递达到用一个栈就能完成语法翻译所需要的属性传递

2022.12.19

语义规则是给出了这个产生式在推导或归约的时候执行的，这一条产生式的所有语义规则不一定要同时进行。准确的说，能确定的时候就执行，由于综合属性要通过子节点，所以是归约的时候，产生式的末尾赋值；而继承属性通过父节点或左兄弟节点，所以继承属性要在进入这个非终结符前赋值

2022.12.15

归约的时候会执行语义规则，对于一个属性t=f(c1,c2,……,cn），如果其所属的节点是当前归约的左部，且c1-cn都是右部的属性或左部的继承属性，那么t是综合属性

如果t所属的节点是右部，且c1-cn是左右部的属性，那么t是继承属性

给语法分析时的分析树的节点加上属性，属性有两大类，一种叫继承属性，可以直接由父节点/兄弟节点的属性得到，一种叫综合属性，由自己的子节点的属性得到。我们会有一个继承属性和综合属性从哪个节点的属性得到的自己定义的函数，我们就按这个函数去给每个节点的属性赋值

把各个属性之间的得到的关系画一个图，这个就叫依赖图，然后对依赖图进行拓扑排序，然后按排序的结果计算每个节点的属性

很明显啊，这样做又得遍历来建立依赖图，又得遍历进行拓扑排序，太浪费时间了，所以我们又又又又又对文法进行约束，希望能遍历一次甚至只要跟着语法分析就能得到每个节点的属性

- S属性：只有综合属性的语法制导定义（自底向上，一遍得到综合属性）
- L属性：要么是综合属性，要么继承属性只能继承自己的父节点或位于自己左边的兄弟节点（深度优先）
- 两种属性实际上都用到了自底向上的LR文法，但S属性是跟着语法分析得到每个节点的属性的，而L属性要先建一颗树（应该吧，应该是用自底向上的方法建的……之后再详细谈吧）
- 所以S属性能用LR1文法，而L文法只能用LL1文法了（可能吧，我不知道，后面详细谈）

然后我们就希望可以在语法分析的同时得到用S属性（都是自底向上）。那这改造起来就很简单了，我们再弄一个栈，装综合属性，之前压入一个状态时，我就再压入这个状态对应的综合属性，归约出栈时，同时把对应的综合属性弹出，用哪个产生式归约，那就用哪个综合属性的函数映射得到归约后的节点的综合属性，然后和归约结果一起压入栈（注意属性是可以为数值，而不仅仅是一个记号，比如一个数字的综合属性可以为数字本身的数值，对这个数字的综合属性的处理其实就是对数字的加减乘除。这里想表达的是对综合属性的处理不要理解为记号的映射）



我们后面又提出了可以自底向上的L属性，当然这种算法是弯弯绕绕得到的，所以可以使用的文法只能是LL1文法和部分LR1文法（虽然自底向上就是为了LR1文法服务的，但我们可以用LL1的时候，算属性用栈区实现，从而实现属性的自底向上）（也正是因为不能保证所有的自底向上的L属性算法都可以让LR1文法无二义性，所以我们自底向上的L属性算法统一限制用LL1文法去做）

自底向上的L属性的继承属性就放在栈里，和其同样位置的非终结符相对应，综合属性就放在另一个表里。继承属性只能从它哥的属性或它爹的继承属性得到。终结符没有继承属性，只有综合属性

出了插非终结符，还可以改写文法把L属性变成S属性





注意一点，标识符就是我们变成语言里的变量，别忘了。还有就是，我们在词法分析的时候，只给标识符添加了属性，即它是标识符和是哪个标识符（对应表中的位置）但我们并没有给这个标识符类型，即声明类型，检查类型是语义分析做的，词法分析并没有干这个。所以我们语法制导分析里，可以赋标识符类型，而赋类型的过程就是用 addtype()函数表示



















# 语义分析

词法分析检查了单词有没有问题，语法分析检查了一句话有没有问题（只能做上下文无关的小子集），而一般的语言是有作用域，类型是否一致，重复声明等上下文有关的问题，而这些问题就交给语义分析去做。但上下文有关文法太难做了，所以我们用语法制导等技术去做

## 语义分析的任务

- 收集存储上下文信息
  - 存储位置，作用域
- 类型检查
  - 动态检查：程序执行时检查，效率明显很低
  - 静态检查：单纯检查文本

![扫描全能王 2022-11-20 21.59_1](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/%E6%89%AB%E6%8F%8F%E5%85%A8%E8%83%BD%E7%8E%8B%202022-11-20%2021.59_1.jpg)

![image-20221120224408089](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20221120224408089.png)

![image-20221120224422166](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20221120224422166.png)

![image-20221120224539439](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20221120224539439.png)

![image-20221120224558182](%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.assets/image-20221120224558182.png)





## 嵌套过程

这个实际上是指在函数里面定义函数，这个在c语言是没有的，c语言的声明要么全局声明，要么在函数里声明，而函数只能在全局声明，所以c语言是没有嵌套过程的

而嵌套过程是一件很麻烦，又很没用的事情。首先你嵌套声明了，那么程序执行的时候，一个变量能否访问一个东西就不是程序块去定义的事情了，而是由文本定义的问题了，这这样我们栈中的每个活动就要有访问链去指向它能访问的活动的局部变量，这实在是太傻逼了

但教科书还是讲了这玩意，也讲了这玩意是怎么建立的

原来的访问链就长长的一条，有点脑瘫，这样访问某个东西要不停地跳，太慢了

所以我们整了一个display表，记录每个嵌套深度的活动，每个嵌套深度的活动又组成一个链表，表头就是最新的活动，那这样访问起来就只要访问一次就够了









 
