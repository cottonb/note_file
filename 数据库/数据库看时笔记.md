# 数据库看时笔记

数据库不仅有用网络连接的，还有可以直接装到进程里的数据库，如SQLite

## create database 

```sql
create database database_name
```

## 切换数据库

```sql
use database_name
```



## create table

```sql
create table department
(dept_name varchar(20),
 building varchar(15),
 budget numeric(12,2),#定点数，第一个参数是能精确存储的数字的位数，比如这里就能存包括小数位在内的12位数，第二个参数指明保留小数点后几位，比如这里就要保留小数点后两位，相应的，整数部分就能保留10位
 time float(10),#浮点数，精度至少为n位，比如这里就是10位，或许对于上面的numeric，这里没有指定小数点后几位，所以导致浮点了
 primary key (dept_name,budget)#完整性约束之一，指明这个关系的主键是哪些 
);

create table course
(
    dept_name varchar(20),
    course_id varchar(20),
    primary key (course_id),
    foreign key (dept_name) references department #完整性约束之一，指明这个关系里的哪个属性是属于哪个列表里的主键，这样就能约束外键，使得外键的取值必须取对应主键的拥有的值。这种约束对应到现实就是一个课程对应一个系名，若填入的系名是不存在的，那么数据绝对是错的，所以有这个完整性约束
    
);

create table instructor
(
    ID varchar(5) not null ,#这里的not null就指明了这个属性不能为空值，主键不能为空，不能重复，但如果我们只想要不能为空的限制，那我们在属性声明后面加not null
    name varchar(5),
    dept_name varchar(20),
    salary numeric(8,2),
    primary key (name),
    foreign key (dept_name) references department
);

#数据库会阻止违反了完整性约束的任何数据更新，比如不允许有空值而你传入的数据有空值，这个更新会被阻止，其他类似插入等操作也一样
```

## insert, delete, alter, add, drop概述

```sql
#上面我们建了一张表，但表还是空的，那我们就往里面加一个元组
insert into department
	value('部门名','建筑名',12.2,10.1);
#按声明时的顺序填入即可

#还可以附加列名
INSERT INTO employees (id, name, age)
VALUES (1, 'John Doe', 30),
       (2, 'Jane Doe', 25),
       (3, 'Bob Smith', 40);


#当然我们还可以删除一个元组
delete from departement;#这样是删除所有元组


#我们还可以为一个表增加属性
alter table department add manNum numeric(10,0);
#还可以去掉
alter table department drop manNum;
#alter本身的意思就是更改嘛

#当然我们还可以删除表
drop table department;

```

## select, from, where

```sql
#然后我们进行查询
select name from instructor;#这样我们就得到了一个由name组成的表，这样做只是筛选出了instructor里的所有名字

select dept_name from instructor;#我们筛出了dept_name，但很明显，多个导师可能来自同一个系，那么系名就有可能重复，所以dept_name出现一次，就会在筛出来的表里出现一次，以至于可能会有很多重复

#那我们就想要去除重复，怎么做？加一个关键字distinct即可，即有区分地筛选
select distinct dept_name from instructot;

#当然我们还可以显示地表示，我们不想去除重复，那么可以加关键字all
select all dept_name from instructor;

#我们还可以在select的属性名后面加一些操作，比如
select salary*1.1 from instructor;
#这样筛出来的表就把薪水*1.1了，当然这并没有对原来的表做任何操作

#那很明显，这里给出的操作我们还是很不满意，筛不出我们想要的东西，那我们下面再加一个where
select name from instructor
where dept_name='计算机系' and （salary > 1000 or salary <100);
#这个语句就很强大了，满足where的条件的语句才能被选中
```

```sql
#上面我们只做了单个关系的筛选，那下面我们要做多个关系的筛选
select name,instructor.dept_name,building
from instrcutor,department
where instructor.dept_name=department.dept_name
#这里就很有意思了，我们用两个关系都有的dept_name去限制了building和（name,instructor.dept_name）的组合，这样就不会出现一个（name,instructor.dept_name）连接上了所有building的情况
#而且这里我们可以看出，当两个关系有同样的属性名时，我们需要用"."去指明是谁的属性
#当然这样还是有些问题，在某些情况下我们查不到我们想要的东西，比如我们要查同一个关系下的name相同的两个元组，这样的表达方式就不够用了，所以我们后面还有别的方法
```

```sql
#这里我们再聊一聊from吧，from做的其实就是将多张表做笛卡尔积，很明显，这是一个很大，很麻烦的工作，而where便是从这这个大大的表里面找到符合条件的元组
#注意，笛卡尔积并没有合并属性名相同的两列，属性名相同，但所属的表不同，那自然还是可以用不同表的"."去区分的
#还有，虽然我们写的时候是select,from,where这样的顺序，但实际执行的顺序是from,where,select，即先拼接，再筛选，select只是起一个列表名的作用
```

## natural join, join …… using……

```sql
#由此我们引出了自然连接
#我们连接的过程实际上是对分表的补偿，我们本可以将所有的关联的属性都排到一个表里，但这样会造成大量的信息冗余（比如所有元组的一个属性都是一个值，但我们却要在所有元组里面存储它），所以我们分表了，表与表之间用某些属性相连，那我们在分表之后，我们查询的时候，就需要把分了的表再连接起来，而连接的根据就在于两个表的相同属性的部分，这个属性值相同的元组就来连接起来便好，这样我们也不用全部连起来做笛卡尔积，再从茫茫人海里找到对应的那一组
#而这个操作，就叫自然连接，把两个表里，相同属性的值相同的元组连接起来，并放到结果表里的操作，如下
select A1,A2
from r1 natural join r2
where P;
#注意，natural join是把所有相同属性里的值都相同的元组挑出来连接，如果有两种相同的属性，那么这两种相同的属性各自的值都要各自相等，否则就不会被挑选。所以为了防止某些不想选中的属性也被放到自然连接的判定范围内，我们可以用join …… using
select A1,A2
from r1 join r2 using (A3)
where P;
#这样我们就能限制两个表相连时根据A3属性名去相连的了
```

## as

```sql
#下面我们再说一说一些其他的运算方法

#更名运算
#我们select后总不可能就这样完事了，我们总会经历大大小小的表的合并，那这样不可避免的总会有相同的属性，那难道在新的表里，我们还有用旧的表的属性名去标识，而不能有自己的属性名吗？另外，我们对一个属性进行算术表达式操作后，比如salary*1.1，那这个属性是没有名字的。再者，我们也会有改表的属性的名字的需求，为此，我们需要更名操作
select old_name as new_name
from old_r1 as new_r1
where P;
# as在select和from都能用，可以用来简化输入，如下
select t.name,s.course_id
from instructor as t, teaches as s
where t.ID = s.ID;

#更名还有一个很重要的作用就在于比较同一个关系里的元组
#就举个例子，我们要找一个关系里属性a的值相同的所有元组，如果不用更名操作的话，那么你就会写出如下的代码
select distinct name
from instructor,instructor
where instructor.a =instruct.a
#那这时的编译器就要骂你了，他妈的你说的instructor.a是哪个instructor？左边的还是右边的？
#所以我们需要重命名，有如下写法
select distinct t1.name
from instructor as t1 ,instructor as t2
where t1.a = t2.a;
```

## like

```sql
#字符串的匹配like
#在c之类的语言里面，字符串一般只能比较是否相等，但这里我们可以匹配一部分，如下
select dept_name
from department
where building like '%aaa%'
#"%aaa%"就是子串的意思，building like '%aaa%'就是选出有aaa这个子串的串的意思
#而"aaa%"则是以aaa开头的字符串的意思
#"_"是占位符，可以匹配任意字符，如"___%"即至少有三个字符的意思

#当然我们也需要一个转义字符，但这个字符不是固定的\，而是可以自己定义的，用escape定义，如下
select dept_name
from department
where building like '%\%aaa%' escape '\';
'
#当然似乎在typora默认\就是转义字符
#like还有许多变体，像什么not like，自己去了解吧
```

## order by

```sql
#我们总会希望列表打印的时候能按照一定的顺序去打印，那么就有了order by
select name
from instructor
where dept_name='物理系'
order by name;
#默认使用升序
#当然你还可以对不同的属性使用不同的升/降序
select a1
from r1
where P
order by a2 asc, a3 desc, a4 desc;
#这样就可以优先按a2排序，a2相同就按a3排序，a3相同就按a4排序，asc为升序，desc为降序，所以a2排序为升序，a3，a4排序为降序
```

## between

```sql
#对于数字范围，sql还给了between的表达方式
select name
from instructor
where salary between 9 and 10000;#左闭右闭

#对于where的语句表达，sql还给出了元组的表达方式
select name
from instructor, teaches
where (instructor.ID,dept_name)=(teach.ID,'生物学');
```

## union, intersect, except

```sql
#sql还支持并，交，差的集合运算，举个例子，2009年秋的课程表和2010年春的课程表
select course_id
from section
where semester='fall' and year=2009;

select course_id
from section
where semester='spring' and year=2010;

#那我们要拿到2009秋或2010春开课的所有课程，那我们可以把两个查询语句合并union
(select course_id
from section
where semester='fall' and year=2009)
union
(select course_id
from section
where semester='spring' and year=2010);
#当然union是自动去重的，在2009开设的计算机课和在2010开设的计算机课放到集合里面只有课程名了，合并的时候自然会去重
#所以你可以加一个all来防止去重
(select course_id
from section
where semester='fall' and year=2009)
union all
(select course_id
from section
where semester='spring' and year=2010);
```

```sql
#下面我们来讲交运算，intersect，我们要找2009和2010都开课的课程名，和上面是一样的
(select course_id
from section
where semester='fall' and year=2009)
intersect  #看起来typora不认intersect
(select course_id
from section
where semester='spring' and year=2010);
#这个也是会去重的，如果你想要不去重，同样，加all即可（intersect一样会有可能会有重复）
```

```sql
#然后我们来讲差运算，except，我们要找2009开课但2010不开课的课程名，和上面一样
(select course_id
from section
where semester='fall' and year=2009)
except
(select course_id
from section
where semester='spring' and year=2010);
#同样，不去重加all
```

## null, unknown, is null, is not null

```sql
#我们终于讲到空值了，空值即null，和空值的任何比较的结果不是true/false，而是unknown
true and unknown =unknown;
false and unknown =false;
unknown and unknown =unknown;

true or unknown =true;
false or unknown =unknown;
unknown or unknown =unknown;

not unknown = unknown;

#如果where得到的逻辑结果是false 或者 unknown，那么这个结果不会被选中

#那我们要怎么知道一个空值是空值呢？所以有了is null和is not null谓词
select name
from instructor
where salary is null;
#is null 在是空值时返回true
#这里设计is null这个谓词就是为了避免和上面的“空值和任何值做逻辑运算都得到unknown”的规则冲突，你自己想一下，null = null 的结果是unknown，没有is null的话，你很难判断一个值是否为空

#有些sql还允许用is unknown来测试一个表达式的结果是否为unknown，当然这只是部分sql

#再说回来去重，去重是怎么判断两个元组是否重复的呢？当两个元组的每个属性，要么不空且相等，要么都为空，则两个元组相同，这个规则适用于distinct，union等各种会去重的场合
```

## group by, 聚集函数, having

```sql
#sql还提供了一些对集合操作的函数，叫做聚集函数
avg; #平均值
count; #计数
sum; #总和
min; #最小值
max; #最大值

#avg，平均值，找教师的平均工资
select avg(salary) as avg_salary
from instructor
where dept_name='某个系';
#很明显啊，这样找出来的表，只有一个元组
#聚集函数默认是不去重的（除了集合，谁没事去重啊）。当然你想要在使用聚集函数时去重，如下
select count(distinct ID)
from teaches
where semester = 'spring' and year = 2010;

#如果你想计算元组个数，可以这样用count
select count(*)
from course;
#sql不允许使用count(*)时使用distinct，但在max和min里可以（可能是因为结果无差别）
```

```sql
#那如果我们只想把聚集函数作用于某一组元组，而不是全部元组，那么就有了group by ，把元组分组。比如找每个系的平均工资
select dept_name,avg(salary) as avg_salary
from instructor
group by dept_name;
#group by实际就是告诉编译器，我们用什么作为分组的标准
#那到这里你肯定对group by有很多疑惑，这玩意对于没有被分组的属性，到底怎么输出？就比如下面
select dept_name,ID,avg(salary)
from instructor
group by dept_name;
#每个分组输出一项，但ID并没有被分组，那一个分组一般都对应一堆ID，那难道我输出一堆ID吗？
#编译器可不想这么多事，用了group by，那么除了被分组的属性和聚集函数，其他的属性不能出现在select里
```

```sql
#我们之前的where语句是对元组为单位限制的，但我现在想对group by后的分组进行限制，但我又不想再次筛，那怎么办？所以有了having 子句，它的生效时间在group后。举个例子，我们要找平均薪水超过42000的系
select dept_name,avg(salary) as arg_salary
from instructor
group by dept_name
having avg(salary) > 42000;
```

最后在这里说一句，使用group后，不在group里的属性不能放到select里，有以下原因

首先group并不是分组，而是把元组组成集合，这两句话最大的区别是，分组后，表的组成单位是元组，而用元组组成集合，表的组成单位是集合。也就是说，用了group后，你select的其实是一个集合的属性，而不是一个元组的属性

![image-20221128205509618](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221128205509618.png)

```
create table testgroup(
a1 integer,
a2 integer,
a3 integer
);
```

```
insert into testgroup
values(1,1,1);

insert into testgroup
values(1,1,2);

insert into testgroup
values(1,2,3);

insert into testgroup
values(1,2,4);

insert into testgroup
values(1,3,5);

insert into testgroup
values(2,1,6);

insert into testgroup
values(2,1,7);

insert into testgroup
values(2,2,8);

insert into testgroup
values(2,2,9);
```

```
select a1
from testgroup
group by a1
having count(a2)=5;

select a1
from testgroup
group by a1,a2
having count(a2)=5;

select a1
from testgroup
group by a1,a2
having count(a2)=2;
```

![image-20221128210749857](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221128210749857.png)

所以在group加一个属性是有影响的，而且很大，分组完全不同了

1、SQL 严格区分层级，包括谓词逻辑中的层级（EXISTS），也包括集合论中的层级（GROUP BY）；
　　2、有了层级区分，那么适用于个体上的属性就不适用于团体了，这也就是为什么聚合查询的 SELECT 子句中不能直接引用原表中的列的原因；
　　3、一般来说，单元素集合的属性和其唯一元素的属性是一样的。这种只包含一个元素的集合让人觉得似乎没有必要特意地当成集合来看待，但是为了保持理论的完整性，我们还是要严格区分元素和单元素集合；

总之sql基于数学理论就要按理论走，不然出bug了也没人能救你

## select之后的子句的执行顺序的归纳

```sql
#最后我们归纳一下各个子句的执行顺序吧
#from先把多个表笛卡尔积/自然连接，where挑出符合的元组，group再从这些元组里，按group的分组标准分组，然后得到每个分组的输出元组，最后用having子句，执行having的谓词语句（可以有聚集函数），挑出符合条件的分组，最后select上的语句执行，把要的属性输出（注意聚集函数作用的单位始终是分组，没有group by的时候，分组就是整个组）
```

## 聚集函数对空值处理

```sql
#最后我们来聊一聊聚集函数对空值的处理
#count(*)以外的所有聚集函数，遇到空值都忽略统计，如果全是空值，那么这些聚集函数会返回空值，而count(*)由于统计的是元组个数，所以没有元组的时候，返回0，表示元组个数为0
```

```sql
#后面sql还引入了对布尔值的聚集函数some和every，some是存在一个为真即为真，every是每一个都为真才为真
```

## in

```sql
#我们总会有判断一个属性值是否在一个集合的需求，所以有了in 和not in，举个例子，我们要找2009年和2010年都开的课，之前我们用集合交运算解决了，那下面我们用in的方式去解决
select distinct course_id
from section
where semester = 'fall' and year = 2009 and
	course_id in (select course_id
                  from section
                  where semester = 'spring' and year =2010
                 );
#有多种方式实现确实会有冗余，但这样会让语言更加灵活，更能适应人现实生活中的思考

#当然in还可以用于枚举的集合
select distinct name
from instructor
where name not in ('路人甲','路人乙');

#in还可以更灵活地写多属性是否在一个集合
select count (distinct ID)
from takes
where (course_id,sec_id,semester,year) in (
    select course_id,sec_id,semester,year
    from teaches
    where teaches.ID=10101);
)
```

```sql
#sql还提供了集合间的比较方式，用到了some和all，当然这个玩意也可以用前面的方式去实现
select name
from instructor
where salary > some (select salary
                     from instructo
                     where dept_name = 'Biology'
                    );
#这一句的意思就是挑选出比对应集合里的一个的薪水高的元组，你把some改成all就是比对应集合的所有薪水都高的元组
select name
from instructor
where salary > all (select salary
                     from instructo
                     where dept_name = 'Biology'
                    );
```

```sql
#我们还可以看看子查询的集合里面有没有元组
select course_id
from section as S
where semester = 'fall' and year = 2009 and
	exists(
        select *
        from section as T
        where semester = 'spring' and 2010 and 
        	S.course_id=T.course_id
    );
#存在元组就返回true
#这里我们也可以看出外面那层的更名操作section as S同样可以作用于子查询
#当然还配套了not exists
```

```sql
#我们还有看看集合里是否有重复元组的关键字unique，但这个结构并没有广泛实现
select T.course_id
from course as T
where unique (select R.course_id
              from section as R
              where T.course_id=R.course_id and
              R.year=2009
             );
#没有重复元组unique就会返回true
#当然我们有不需要unique的表达方式
select T.course_id
from course as T
where 1 >= (select count(R.course.id)
              from section as R
              where T.course_id=R.course_id and
              R.year=2009
             );

```

## 嵌套子查询（from里套select）

```sql
#from本身就是拼接表，所以我们select后的表也可以放到from里面，如下
select dept_name,avg_salary
from (select dept_name,avg(salary) as avg_salary
      from instructor
      group by dept_name
     )
where avg_salary > 42000
#我们还可以对select查出来的集合起名字，同时对其属性重命名
select dept_name,avg_salary
from (select dept_name,avg(salary)
      from instructor
      group by dept_name
     )
     as dept_avg(dept_name,avg_salary)
where avg_salary > 42000
```

我们在from里用select有时候很难看，所以我们又引入了with，这样能把from里的select搬到外面，这样就好理解一点

![image-20221018214140302](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018214140302.png)



当我们的select只搜到了一个元组的一个属性，那我们可以把它放到select里作为一个属性，但这要保证里面的select只搜到一个元组，如下

![image-20221018214349959](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018214349959.png)

select只搜到一个元组的一个属性称为标量子查询，可以当道select，where，having里，但都需要保证里面的select（即子查询）只有一个结果





## delete

我们终于说到删除了

前面我们说了把整个表里的元组都删了，那我想要有选择地删呢？用where来限定就好了

![image-20221018214633841](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018214633841.png)

上面查询能做的骚操作，这里都能做



## insert

还有插入操作

我们可以简简单单地插入一个元组

![image-20221018214953159](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018214953159.png)

填入的属性的顺序就按表定义的顺序，那如果你记不起来顺序了，那你也可以指定一下属性

![image-20221018215108852](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018215108852.png)

没被赋值的属性就为空值

当然，我们不可能就一个个插，我们更多的是把查到的东西插入表中

![image-20221018215143862](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018215143862.png)

注意，我们在insert和select的时候，是select做完后才insert的，而不是一边select一边insert（因为这样有可能死循环，如下）

![image-20221018215851192](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018215851192.png)

## update

现在讲到更新了，我们只希望对某些属性值做修改

![image-20221018215751030](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018215751030.png)

进一步的，我只想对某些元组的某些属性做修改

![image-20221018215819842](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018215819842.png)

同样，我们一样是先where再update

![image-20221018215933535](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018215933535.png)

## case

当然，我们可能会遇到很多种情况的更新，那如果一个个条件地写就太麻烦了，如下

![image-20221018220106262](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018220106262.png)

所以推出了case语句

![image-20221018220124266](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018220124266.png)

case语句语法如下

![image-20221018220158899](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018220158899.png)

当然，标量子查询也可以用，举个把成绩不是F也不是空的学分加起来的例子

![image-20221018220518425](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018220518425.png)

当然，当这个学生什么也没学的情况，学分会为空（sum()返回的空，只有count(*)不会返回空），如果我们想要sum()空时赋学分0，可以把上面的select语句用下面的case形式替换

![image-20221018220852611](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018220852611.png)





## join的各种形式

前面我们介绍了from的链接和自然连接natural join 和限定某些属性相等时才连接的join …… using，那如果我们要在某些条件时才连接怎么办？（虽然全部连接再用where筛出来也行，但我们就想要先限定条件连接）

所以有了join …… on，这玩意就是把on后面的当作谓词，谓词为真才能连接join两边的表的元组，如下

![image-20221018221420687](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018221420687.png)







再来看看下面这种情况，自然连接是要一个表有另一个表的相等的属性值时才连接，那举学生和选课的两个表的例子，学生是存在的，但有些学生就没选课，那如果两个表用了自然连接，那么没有选课的学生就完全被剔除在外了，这不是我们想要的，我们想要的是没有选课的学生连上一堆空的属性就好，那这个连接就叫外连接

然后外连接又分为三种

- 左外连接，关键字left outer join，保留左边的表，在左边的元组在右边的表没有对应时，也能产生一个空元组与之对应
- 右外连接，关键字right outer join，保留右边的表
- 全外连接，关键字full outer join，保留两边的表

与外连接相对应，我们之前学的连接方式称为内连接（笛卡尔积那个应该叫拼接吧）

外连接用法如下

![image-20221018223245641](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018223245641.png)

![image-20221018223252696](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018223252696.png)

![image-20221018223301296](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018223301296.png)

上面写的natural是把同样的属性名合并的作用

当然，外连接还可以和on一起用，但natural不能和on一起用，所以下面的查询结果的属性ID没有被合并

![image-20221018223658723](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018223658723.png)

连接类型是可以和连接条件任意组合的，如下

![image-20221018223936499](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018223936499.png)

inner join = join





## create view

我们虽然做了一张表，但我们可能并不希望给别人看到所有的属性，那我们最先想到的做法就是select，把相应的属性挑出来，如下

![image-20221018224201270](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018224201270.png)

但这就是一张新表了，等于说我手抄了一份表，那你原来的表改变了，我又得手抄一遍吗？这个问题就在于我们数据的存储结构变了，我们提供给用户的数据又是一个存储结构，而我们并不能建立起新的存储结构和旧的存储结构的关系

这时候你就会骂用想不出办法的人傻逼了，像c一样，用指针或引用不就好了吗？对了，这就是视图，我们给用户看的并不是我们的存储结构，逻辑模型，而是一个引用，一个虚关系。我们称数据之间我们设计的表与表之间的关系称为关系，提供给用户的，没有表与表之间的关系的视图称为虚关系



然后我们就可以创建视图了

![image-20221018224816938](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221018224816938.png)

![image-20221019082649245](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221019082649245.png)

然后我们就可以把视图当作一个表来用了

![image-20221019082944136](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221019082944136.png)

可以看到定义视图时，可以在后面加东西来重定义属性名

**虽然我们说了视图就作为表的引用就好了，但这只是方便理解的说辞，视图的实际运行是把后面存储的select放到视图的地方去执行，所以视图只存储了select，而没有存储数据或引用**

由于视图也是一个表，所以视图也可以用视图来定义

![image-20221019083339591](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221019083339591.png)





虽然前面我们说了，视图存储数据的话就会很傻逼，但sql还是提出了一个概念叫物化视图，即存储了数据的视图，或存储了视图关系的视图。物化视图会随着定义它的关系变化，和普通的视图没有什么区别，只是数据库里真的存了数据，定义它的数据发生变化，数据库会自动更改物化视图，而这个过程就称为物化视图维护

视图和物化视图其实就是在select查询和更新数据的开销之间权衡的过程，每次都要查一个很大的表，但更新数据并不多，那我肯定想用物化视图，老是要更新，但查表不不麻烦，那我肯定想要视图。当然，物化视图的存储开销也要考虑到





虽然我们提出了视图的概念，但如果从视图插入，删除或更新，怎么办？我们视图只是提供了一个看的地方，而上述操作都要对应到具体的表里（视图不表达关系，所以操作必须作用在真正存储了关系的表里）

那我们来看下面的情况，如果从视图插入，但视图本身缺少表的某几项属性，那我们是把这几项属性看作空还是直接拒绝插入呢（虽然这样就意味着不允许更新视图）。把属性作为空看似可行，但如果视图本身是两个表的自然连接得到的，如果两个表连接的属性没有在视图中给出，那么我们就会在两个表里填上无法连接的两项，那视图也不可能更新（自然连接会把这两项去掉）

所以除了某些情况，视图是不允许修改的，具体的情况看使用数据库的手册，一般可以修改的条件如下，虽然满足以下条件的还是会出问题

![image-20221019092131928](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221019092131928.png)





## 事务

现在我们提出事务的概念，这个和操作系统的原子操作或锁的概念是相同的，我们有些操作要有原子性，要么做完，要么不做，所以我们把这种原子性的操作称为事务，事务里面的sql语句，要么全部做完，要么做到一半恢复到做之前的样子，这就是事务。sql规定，一条语句必须是一个事务，这就保证了每条语句的原子性，当然，如果我们想要一堆语句作为一个事务，那么我们就会在外面包一层东西，这个后面再讲



## 完整性约束

现在我们来讲完整性约束，这个其实就是非空啊，不能相同啊，要大于0啊之类的约束

除了主码的约束，我们还可以在建表的时候加下面几种约束

![image-20221019172430275](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221019172430275.png)

```sql
create table section
(
    property1 varchar(1) not null,
   	property2 varchar(1) ,
    property3 varchar(1) ,
    property4 varchar(1) ,
   	property5 varchar(1) ,
    property6 varchar(1) ,
    primary key(property1,property2),#加上主键限制的属性就被unique和not null同时限制了
    unique(property3,property4),#被unique限制的属性就不能有相同值了，但可以为空，其实unique就是候选码
    check(property2 <> 'a' and property6 = '0' and property5 in otherSection)#check就是执行里面的谓词语句，如果里面的谓词语句不为真，那么就不允许插入，更新
);
```





前面在建表的时候说过，当我们一个学生的老师属性在另一个表里不存在时，我们不希望把他加入表中，那么这个就叫参照完整性，即参照别的表的属性的限制，这个在前面就是在建表的时候用foreign key来限制。我们用上面的表改一下来举例子

```sql
create table section
(
    property1 varchar(1) not null,
   	property2 varchar(1) ,
    property3 varchar(1) ,
    property4 varchar(1) ,
   	property5 varchar(1) ,
    property6 varchar(1) ,
    primary key(property1,property2),
    unique(property3,property4),
    check(property2 <> 'a' and property6 = '0' and property5 in otherSection),
    
    foreign key (property5,property6) references otherSection, #这个就是正常的完整性约束
    #那如果我在一个操作违反了参照完整性，但我不想拒绝这个操作，而是修改表，使得这个操作符合参照完整性，怎么办？所以有了on的使用，如下
    foreign key(dept_name) references department
    on delete cascade
    on update cascade,
    #on delete cascade即当删除违反参照完整性时（即一个属性被别人拿来参照了，结果你现在要删这个属性，那用它来参照的属性不是全违反了参照完整性吗），我们不拒绝这个删除操作，而是把参照这个属性的属性的元组也删了，on update cascade也是这样，当更新被参照字段，导致参照别人的属性没法对上了，那么参照别人的属性也跟着更新，cascade的意思就是级联，当被参照的字段被更改，参照字段跟着更改的意思
    #当然，除了cascade，我们还可以用set null，表示被参照字段被更改时，参照字段被改为null。参照完整性是这样的，要么为空，要么有一个对应的参照字段。还可以用set default，改为默认值
    
    #一般来说被参照字段都是候选码，即unique或primary key的，但sql也提供了不是候选码的参照方式，后面讲
);
```

我们可能会在一个事务里面暂时违反完整性约束，但事务完成时，我们又会满足完整性约束，像是夫妻之间的关系，无论先加入哪个元组，中间都会经历一个没有对应配偶的情况，如果因为这样而不能加入元组，那就太傻逼了，所以sql提供了initally deferred关键字，能让完整性约束不在事务中途检查，而是做完后检查

当然，许多数据库并不支持这种延迟检查，所以我们可以迂回地做，比如一开始的配偶都填null，后面再更新，当然如果不允许填null那这个方法就行不通了





我们再说回来check，前面我们说了check要满足里面的谓词，但其实里面的谓词对于大部分数据库来说，select是不支持的，因为你想啊，每次加入一个数据，都得select，这开销得多大啊，如下

![image-20221019182214788](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221019182214788.png)

更何况check子句还不仅仅在加入更新数据的时候检测，还在time_slot表更新的时候，上面这个check语句还得执行，那这代价也太大了



顺着检查的思路，我们再提出一个概念，叫断言，简单来说就是一个我们希望经常检查的条件，可以说我们前面介绍的各种约束方式，都是断言的特殊形式。断言的例子如下

![image-20221019211026988](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221019211026988.png)

可以看到，断言就是一个放在外面的check，每次修改数据库时，都要检查这个数据是否符合断言，所以断言很鸡巴浪费效率







除了基本数据类型外，还支持日期和时间相关的几个数据类型

![image-20221019211606155](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221019211606155.png)





我们在定义表的时候，还可以把数据的默认值设置一下，当插入元组时，没有给出属性的话，就会自动填默认值，设置默认值如下，在后面加个default 和对应的值就行

![image-20221019211802219](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221019211802219.png)



学到这里你就会发现，我们现在全是基于元组的查找，你肯定会觉得这样查询的效率高不到哪去，肯定是一个属性的查询最好，所以有了索引这种数据结构，索引从一个表里抽出了一个属性，用B+树的方式组织数据，使得能高效地进行查询，例子如下

![image-20221019212434410](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221019212434410.png)

这也算是我们从集成到分布的各种妥协吧





## 更多的数据类型

学到这里，你肯定会觉得基础数据类型还是不够用，我们要存储各种二进制文件怎么办？存储图片怎么办？

所以有了字符型的大对象数据类型clob和二进制数据的大对象数据类型blob，其中lob表示 large object。下面我们举个例子

![image-20221019212809907](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221019212809907.png)

很明显，我们select后的结果调入了内存，那么把大对象的调入内存是一件很傻逼的事情，如果能像c语言一样，用一个定位器去读一个文件就好了，所以我们后面会介绍嵌入式sql，用宿主语言去获得一个定位器去读大对象





但这些数据类型你肯定还不满意，c语言有的都要有！我们还不能自己定义数据结构呢。每一种数据应该有它自己的域，即便域相同，两种数据也应该是不同的种类，就像一元人民币和一元津巴布韦币一样。所以有了type关键字

![image-20221019213435832](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221019213435832.png)

这玩意和c的typedef差不多，但有个好处是dollars类型和pounds类型确实不同，不用担心两种类型互相赋值的问题

但这又带来一个问题了，numeric和dollars属于不同类型了，我现在想给dollars加点数字都不行了，所以我们还得做类型转换，cast，用法如下

![image-20221019213758860](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221019213758860.png)

做了类型转换再做回来就好了，虽然贼鸡巴麻烦



和table一样，被create的东西就可以被drop和alter，type也是如此



在type之前还有个和type很像的关键字，domain，但它可以给数据类型上完整性约束，如下

![image-20221019214124601](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221019214124601.png)

但domain不是一个强类型，这就意味着domain不会像type一样，即便基本类型一致，还是需要cast才能进行赋值

但domain和type都没有得到大多数数据库的完全支持



## 各种拓展

sql还定义了create table的各种拓展，比如说我想建一个和某个表的定义一样的表，那就可以用create table like

![image-20221019214807653](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221019214807653.png)

我们还可以从select哪里建表（可以看出我们之前select真的只是挑出来，而没有建表了）

![image-20221019214908090](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221019214908090.png)

如果没有with data 这句话的话，在sql标准里，表会被创建，但数据不会导入，也就是说是个空表，但实际上很多数据库在没有with data这句话时还是默认导入数据（实际和标准总是差这么远，这不纯纯脑瘫吗？）

还有，create table like 和create table as在各种数据库里都有不同的语法，请查询手册

## 调整安全模式

```sql
SET SQL_SAFE_UPDATES = 0;#关闭
SET SQL_SAFE_UPDATES = 1;#开启
```

防止误删数据的模式，对初学者很烦，把删除语句加到二者之间就行了



## 模式详解

现在我们再来说说命名空间的问题，数据库也有命名空间的问题，多人合作一合并，就会出现命名重复的问题，这很鸡巴操蛋，那数据库也是像c一样对每个数据库加个using namespace 吗？这还得回到数据库的本质上来说，数据库系统并不是操作系统，数据库系统是一系列软件，硬件，人员的系统的组合，而数据库管理系统才是数据库的软件，而数据库管理系统是建立在操作系统之上的，但数据库管理系统还是采用了操作系统的文件系统的形式，操作系统的多用户就是分文件夹/目录，每个用户占有一个目录，登录的时候就把用户占有的目录认为是主目录，这样就能实现多用户的情况了。那数据库管理系统也采用这种想法了，一个数据库就是一个目录，或者说数据库就是一堆数据的集合，而这个集合放在一个文件夹里，所以我们就把目录/文件夹/数据库这几个名词当作一个名词来用了（虽然我一直觉得这太脑瘫了），然后我们肯定想把数据库分几块，给某个人一块，另一个人一块，那这一块一块其实还是文件夹，但在数据库/文件夹/目录里的文件夹就不叫文件夹了，叫模式（就像python不同文件里的代码就叫模块，然后python文件夹还要叫python包一样，虽然python包确实比一般的文件夹多了一个init的文件），然后模式里面就可以建表了，而且建这个数据库的user其实就是管理员，他可以新建其他用户，你可以给这些用户user分配访问每个模块的权限，这样每个用户就能用读/写模块里的表了。

然后这就是模式，就是个文件夹，里面存了各种表/关系模式，而外模式（子模式）就是提供给用户的东西，其实就是视图，而内模式就是数据的真实存储，然后外模式和模式的设计的方式就是逻辑模式，而设计内模式的就是物理模式，然后模式实际上就是作为内模式，外模式，数据库管理员的接口而存在的，内模式和模式的接口保证了内模式改变的时候，模式和外模式不受影响，而外模式的存在，使得即使我们改变了数据间的逻辑关系，甚至是重建了一个表，外模式作为接口，也不会让用户修改程序

所以模式即指文件夹，也指文件夹里的表，这个表就是数据的集合和数据间的关系的集合，所以模式又指表/关系模式的地位，所以我觉得这种概念的混用极大地增加了理解的难度







我们在模式中提到了权限，所以我们就说到授权

































# 第七章——ER模型

这个模型最大的思想是entity-relation，它不仅仅把我们要存储的东西看作一张表，还把表与表之间的关系看作一张表，从而有效地解决了像是一个老师对应多个学生的情况，并减少了信息冗余，所有的信息都凝练到了关系上面

然后我们就来讲讲ER模型的画图

我们用矩形来表示实体集，矩形的第一行作为实体集的名字，表名，表内的每一行代表一个属性，作为主键的属性下面用下划线标识，如下图

![image-20221020154624109](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221020154624109.png)

然后我们用菱形来表示联系集，菱形里写的就是联系集的名字，如图

![image-20221020154821758](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221020154821758.png)

实体集之间的通过联系集联合起来，而实体集和联系集之间的联系用实线连起来，如下图

![image-20221020155049862](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221020155049862.png)

然后我们还可以给每条实线加箭头指向实体集，被箭头所指的实体集表示“一”，没被箭头所指则表示“多”，这样我们就可以表示一对一，一对多，多对多的映射基数了，如下图

![image-20221020155429466](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221020155429466.png)

当然，联系集也可以有属性，那么这些属性就写在一个矩形里面，然后用虚线和联系集相连，表示它们是联系集的属性，如下图

![image-20221020155601188](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221020155601188.png)

当然我们还可以用另外的方式来表示映射基数

在线上加数字，数字表示线连着的实体集a可以映射多少个关系对应的实体集b

![image-20221020190711387](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221020190711387.png)



虽然在sql里没有复合属性，但可以在ER图里表示复合属性，就用类似文件夹归属的方式方式就好了

![image-20221020190859523](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221020190859523.png)

我们还可以弄一个多元ER图

![image-20221020192012909](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221020192012909.png)

但在多元联系里，一个联系集连的线只允许有一条线有箭头，因为有多个箭头会有映射基数的歧义



那现在再来看一种情况，现在两个实体集的主键是同一种，那现在两者联系在一起，那两个同样的主键不就冗余了吗？注意这里我们不想用二者都用同一个主键作为隐含的联系而删除联系集。那怎么办？

那我们就想借用二者都是用同一个主键的隐含联系怎么办？那只要有一个实体集依赖于另一个实体，而这个依赖通过联系来实现，那么依赖别的实体的主键不就可以去掉了吗。那么依赖别的实体集的实体集称为弱实体集，有主键的实体集称为强实体集。然后弱实体集之间用来区分的属性用虚下划线标识，而联系弱实体集的联系集用双线画上，双线连着的叫弱实体集

![image-20221020195634233](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221020195634233.png)

弱实体集的意义就对应现实世界某些实体集必须依附于别的实体集才能存在，就像职工子女的信息必须以职工的存在为前提的

其实这里双线的意思是相连的实体集全部参与到了关系之中，单线是部分参与，因为弱实体集必须依赖于别人，所以弱实体集必须全部参与

还有就是一个实体集可能在不同情况下扮演不同的角色，像是人这个实体集，它可能作为自己实体集下的父母，即自己和自己有个联系集，那么我们就需要在连线上标注其扮演的角色。举个另外的例子如下

![image-20221020200205860](C:/Users/lenovo/AppData/Roaming/Typora/typora-user-images/image-20221020200205860.png)









```
musicians(__musicianID,name,address,phoneNumber)

instrument(__instrumentID,name)

song(__title,author,albumID)

album(__albumID,title,copyright date,format,producer)

play(musicianID,instrumentID)

perform(musicianID,title)
```





当多值属性时，就要用到关系表了，或者说多对多的情况，一对一，一对多还可以用加属性的方式隐式地解决

![image-20221218074153374](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221218074153374.png)

![image-20221218074212632](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221218074212632.png)

![image-20221218074228940](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221218074228940.png)

































# 数据库设计

关系设计要有一些原则，遵守这些原则会比较好

首先我们每个属性应该是不可分割的，则这个属性称为原子的。而每个属性都是原子的关系模式，则称这个关系模式为第一范式

函数依赖即一个关系模式下，如果属性a不一样，属性b就不一样，a一样就一样，即属性a和属性b一一对应，那么则称这个关系有函数依赖，用sql语句就是挑选属性a相等且属性b不相等的元组，如果查询结果为空，则有函数依赖，当然还可以用group by分组计数，如果一组计数为0，那么也说明有函数依赖。

很明显，如果属性a和b函数依赖，b和c函数依赖，那么我们就可以推出a和c有函数依赖，这时候说c被a逻辑蕴含。同样，如果我们得到了一个关系里的所有明面上的函数依赖，那么我们就可以用推导得到这个关系的所有函数依赖，所有函数依赖就是明面上的函数依赖的闭包。所以这个关系上的每个函数依赖都被闭包所蕴含。

函数依赖是作为主键的好方法



a->b, a->c, so a->bc

a->bc, so a->b, a->c

a->b, bc->d, so ac->d





有了函数闭包，那么就有了属性闭包，即一个属性集合能用函数依赖推导得到的所有属性集合



我们可以用属性闭包测试一个属性集合是否为所在关系的超键/候选键（超键是唯一确定元组的键，候选键是自己的子集不能唯一确定元组的超键）



函数闭包虽然能推出很多的东西，但我们用不到，甚至我们希望你别推出来这么多东西，我每次只检查最少的条件就能保证正确了。所以我们有了正则覆盖，把函数依赖变成最小函数依赖



实现正则覆盖Fc的方法如下

首先用a->bc, so a->b, a->c把所有推导式的右部全变成单属性

然后我们去除推导式的左部的冗余属性，例如xy->a, 假设y是冗余的，去掉，然后看看去掉后，x的属性闭包是否改变，即去掉y后看看x还能不能推出a，能的话y就是多余的

然后我们再把上述操作得到的每个函数依赖都尝试去掉，如果去掉后对应的属性闭包没有改变，那么这个函数依赖是冗余的，可以去掉

实际上就是尝试去掉一些式子，如果去掉后会影响属性闭包，那就说明不能去掉

到这里我们就得到最小函数依赖了

然后我们再把最小函数依赖的右部合并就好了，例如a->b,  a->c, so a->bc。这样就能得到正则覆盖了，正则覆盖就是最小函数依赖的式子数量的简化，主要是为了数据库一次就能读出多个属性方便比较

从上面看出最小函数依赖和正则覆盖都不确定，会随着操作顺序的不同而不同











无损连接分解

我们把大表拆成小表后，能用自然连接完美还原，称为无损连接分解。这样就需要拆成小表后，一个小表a用原来的主键，另一个小表b要有外键和a相连

当然我们还希望拆表后，能保持函数依赖（就是可以直接在子表上检查，而不用拼接在一起后再检查）（如果一个函数依赖的两边分布在不同的表上，这个函数依赖可以由表内从函数依赖推导出来，那么这个函数依赖可以不检查）









# 第八章——关系数据库设计

我们有两种设计思路

- 属性更多的表
- 属性更少的表

更大的表容易有数据冗余，而且容易有空值的问题

更小的表没有冗余，空值方面的问题，但查询的时候就得联合多个子表才能查到，所以在查询的时候效率较低

所以后面我们介绍一些分解的方法，使其分解后再合并没有信息损失，即无损分解，而这些分解的方法，就对应一些范式（即用某些规则限制的关系）

## 第一范式

即关系的所有属性都是不可分的，即每个属性都是原子的，不可再分的。

可以看出这个限制太小了，所以对我们没啥帮助

## 第二范式

这个只有历史意义了

在第一范式的基础上，如果所有非主属性完全依赖于主属性，则为第二范式

什么是完全依赖？即主属性再少一部分属性，就不能有非主属性和主属性的函数依赖存在了

部分依赖正相反，只要主属性的一部分属性就能完成函数依赖

## 函数依赖

这个函数就是平时所说的函数，就是一个映射，我扔一个东西进去，只会得到一个结果。即我可以用若干属性的集合的元素单射出若干属性的集合的元素，仅此而已

### 超键

然后如果若干属性k能映射出R的所有属性，即k->R，那么我们就可以把k称为超键，这也算是一种数学上的定义吧

### 平凡

然后有些函数依赖可以在任何关系实例上成立，如x->y, y in x，即自身和自身的一部分映射，那就算本身映射本身也能单射完，所以必定在任何关系实例上成立。所以我们称 x->y, y in x，这个函数依赖是平凡（trivial）的

### 传递性，传递依赖

那很明显啊，映射这个性质本身就有传递性，像 a->b, b->c, 那么 a->c，那我们有称 a->c 为传递依赖（爱记不记，只要知道有传递性就行）

### 闭包

有了传递性，我们自然就会提出闭包的概念，闭包这个概念实际上就是把有传递性的关系的所有隐含/显示的关系全部推导出来后的一个集合。闭包的闭和包都表示出不去的意思，即无论你再怎么推导，再怎么传递，其实我都已经把你所能走的结果全部包在这个集合里了，那你是出不去的，这就叫闭，封闭的意思。我们把一个关系R满足的函数依赖的集合记为F，那么F的闭包就是F+（加号在右上角，懒得写数学式了）

### 函数依赖的现实意义

让我们来想一下函数依赖有什么意义吧。函数依赖最重要的就在于单射，而我们现实生活中的单射呢？我说一个名字，你想到一个人，我说一个身份证号，你找到一个人，我说一个建筑名，你想到一个建筑，挺有意思的。那这对我们分解有什么意义吗？有一点，至少我们不会把（身份证号，人，建筑名，建筑）绑到一起，因为人和建筑之间并没有明确的映射关系，我们总不会说，我说一个人，你想到某一个建筑吧？你可以说某人住在某个建筑里，这是一个关系；但你不会说一个人，就对应一个建筑，没有人对应的建筑，就是不存在的。看到函数依赖的意义所在了吗？实体是需要标识的，而标识是唯一指向实体的，这就是函数依赖，大多数情况下，有函数依赖的地方，我们就认为有实体。但实体之间，应该用关系去连起来，而不是强硬地绑在一起，所以这就是我们所说的分解，把大表分成小表

于是我们想出了一个绝妙的分解方法，如果一个关系有函数依赖a->b，而a又不能唯一地标识元组，即a就不是超键，那很可能我们的表由多个实体拼起来的，而a是其中某个实体的超键，那反过来说，我们就可以把这个表拆成多个实体的表，这样我们不就完美分解，不会产生因为把表拼起来产生的各种冗余了吗。所以当我们分解到每个子表都没有上面所说的函数依赖，那我们就分解完了，然后我们称这种子表为Boyce-Codd 范式（Boyce-Codd formal function, BCNF），后面我们会给出它的详细定义，再往后我们还会讲到BCNF分解，即如何将一个表（假如它不满足BCNF定义）分解为多个BCNF

## BCNF

### 定义

F是r(R)所满足的函数依赖，对于所有 (a->b) in F+，至少满足以下一项

- a->b 是平凡函数依赖，即 b in a
- a是R的超键

### 分解思路

分解的思路很简单，导致不满足条件的原因在于定义的两个条件都不满足，那都不满足的函数依赖很可能对应一个实体，那我们把这个函数依赖的属性踢出去让它自己作为一个表不就好了吗？如果踢出去后，还是有表不是BCNF，那就继续踢，直到全部表都是BCNF就好了

所以一次分出来的表有两个，假设 a->b 不满足两个条件，a是一堆属性的集合，b也是一堆属性的集合，R是这个表的所有属性，那么分出来的两个表如下

- $(a \cup b)$，这个是踢出去的表
- $(R-(b-a))$，这个就是踢完后的表，(b-a)只是因为b和a可能有重合，不小心把a的东西删了，那么合并的时候就没有合并依据了，a还是要完整保留的

### BCNF对函数依赖的破坏

前面我们说了，我们默认一个非超键非平凡的函数依赖对应一个实体，但很明显啊，这只是在大部分情况下满足而已，在不满足的情况下，那我们就会分错，从而破坏函数依赖

举个例子，我们生搬硬造一个例子，就假如学生，老师，系这三个实体之间的联系是dept_advisor，如下

![image-20221029221153186](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221029221153186.png)

我们再对这个生搬硬造的例子加一个生搬硬造的条件，每个学生可以对应多个老师，但这些老师都要来自不同的系，正因这个限制条件，我们dept_adviosor的属性为

dept_advisor(s_ID,i_ID,dept_name)

如果我们就这样搞，那这样我们只要检查一下dept_advisor的应有的函数依赖就可以了（这些函数依赖都对应我们现实的意义，比如一个老师对应一个学生，一个老师对应一个系）如下

i_ID -> dept_name

(s_ID,dept_name)->i_ID //某个系的某个老师对应某个学生

那很明显啊，这种设计几乎已经完美了，没有信息冗余，限制检查也可以在一个表里完成

但dept_advisor很明显不是BCNF啊，i_ID肯定不是超键，因为一个学生可以有很多个不同系的老师，那i_ID就会有很多个（但s_ID是超键）,那么i_ID->dept_name就违反了BCNF

那我们就得拆表了，拆成

(i_ID,dept_name) //第一个函数依赖，踢出去的玩意

(s_ID,i_ID)//踢剩下的玩意

那这完蛋了啊，很明显，这两个表满足BCNF了，但 (s_ID,dept_name)->i_ID 这个函数依赖我们要检查就麻烦了，我们又得把两个表连起来，然后检查这个函数依赖，那这样我们检查的代价就会大大增加

所以这就是破坏函数依赖的代价，或者说函数依赖本来就是我们认为希望加上去检查的东西，现在你BCNF分解把函数依赖放到不同表里了，那就破坏了函数依赖，那我们检查的代价自然增加了

所以BCNF不是完美的，它有可能会破坏函数依赖，破坏函数依赖就会导致我们检查的代价增加，所以我们提出了3NF，第三范式（实际上第三范式是第二范式的条件收紧版，而BCNF是第三范式的条件收紧版，后面还有第四范式，是BCNF的条件收紧版，所以说第三范式做到不破坏函数依赖就在于条件的放宽）

## 第三范式（3NF）

对于R的F+中的 a->b，以下至少一项成立

- a->b 是平凡的
- a是R的超键（函数依赖都对超键依赖，就不会有中间依赖了）
- (b-a) 的每个属性A都包含于R的候选码中（即A1和A2可以属于不同的候选码，比如候选码A1B1和A2B2）（对候选键部分依赖，bcnf是3nf的加强，所以bcnf是没有这一项，即需要对候选键完全依赖）

可以看出啊，这个第三范式就比BCNF加多了一个条件，就是第三个条件，这他妈很不明显啊，这个在后面3NF分解的时候用处会明显一点，这里我也不懂

但举个例子可以，就举我们上面的例子

dept_advisor(s_ID,i_ID,dept_name)

i_ID -> dept_name

(s_ID,dept_name)->i_ID //某个系的某个老师对应某个学生

之前不是i_ID不属于超键吗，但dept_name被包含于候选码

## 函数依赖理论

给几个定理，先给Armstrong公理

- 自反律，a是属性集，b属于a，则a->b
- 增补律，若a->b成立，且r是属性集，则ra->rb
- 传递律，若a->b，b->c成立，则a->c成立

这个公理正确但不好用，所以我们推导了一些其他公理

- 合并律，若a->b，a->c，则a->bc
- 分解律，若a->bc，则a->b，a->c
- 伪传递律，若a->b，bc->d，则ac->d

然后我们可以用这些公理去得到F+

![image-20221030004524533](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221030004524533.png)

## 属性集的闭包

我们之前都是F的闭包，但F+可能会无限大，所以我们提出了属性集的闭包，即一个属性集通过函数依赖能推出的属性集，比如a->bc，c->d，那么a的闭包就是{a,b,c,d}。属性集不可能无限大，因为再大也不过R的大小

计算属性集a的闭包a+算法

![image-20221030005716738](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221030005716738.png)

a+的用途如下

- 如果a+等于R，那么a就是超键
- 我们可以看看b是否属于a+，如果属于，那说明a->b成立
- 这给了我们另一种计算F+的方法，由于各种函数依赖可以自由组合推导出更多无用的函数依赖，所以之前那种计算F+方法就是一坨屎。其实我们只要类似于a->b，a,b都是尽可能少的属性集的函数依赖集就行了，那我们只要把所有属性的闭包找到，这样我们就找到了所有属性的函数依赖，那这就是我们要找的闭包

## 正则覆盖

### 逻辑蕴含

简单来说就是一个函数依赖m能通过公理推出函数依赖n，那么m逻辑蕴含n

再推广，函数依赖集F能推导出另一个函数依赖集M，那么F逻辑蕴含M

### 正则覆盖的概念

我们已经有了简单的找F+的方法了，但找到的F+有个问题，它不是最简的，举个例子，F+里有 a->b, b->c, a->c，但很明显啊，a->c可以由 a->b, b->c 推导得到，那么 a->c有个鸡巴用，就他妈是多余的。所以我们希望找到一个最简的F+，里面再少一个函数依赖都不行的最简。所以这就叫正则覆盖，$F_c$

那么我们就要去找那些没用的函数依赖

### 无关

首先定义无关的概念

一个属性A对于函数依赖a->b 满足以下之一，则A是a->b的无关属性

- 如果A属于a，且F逻辑蕴含集合M= $(F-\{a\rightarrow b\})$$\cup{\{(a-A)\rightarrow b\}}$
- 如果A属于b，且F逻辑蕴含集合N=$(F-\{a\rightarrow b\})$$\cup\{a\rightarrow (b-A)\}$
- 注意，上述的两个逻辑蕴含的方向可以互换，在这里是等价的

简单来说无关的概念就是一个属性在一个函数依赖里是可以去掉的，那我们就尝试去掉这个属性（对应上面的M和N），如果去掉以后，还是能由原来的函数依赖集推导得到，那说明确实无关

### 正则覆盖的算法

简单来说就是用合并律把左部相同的全部合并，然后把F里的所有无关属性全部删除。注意，左部或右部因尝试删去时被删干净了，那么认为这个函数依赖被删除了

![image-20221030100820247](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221030100820247.png)

当然正则覆盖并不唯一，会随着你选择不同而不同



## 保持依赖的函数依赖理论的表示方法

### 限定

F是R的函数依赖集，$R_1,R_2,……R_n$是R的分解。然后$R_i$上的函数依赖集$F_i$就称为$F^+$在$R_i$上的限定（就是把$F^+$里有$R_i$的所有属性的函数依赖放到$F_i$里）

### 保持依赖的定义

记$F'=F_1\cup F_2\cup……\cup F_n$，如果$F'=F$，即二者相互逻辑蕴含，或者说（$F'^+=F^+$），那么我们称这种分解是保持依赖的

![image-20221030153833002](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221030153833002.png)

但这样的定义就要用$F^+$来算$F'$（$F_i$就是从$F^+$来的）了，我们可不想算$F^+$，所以还是想用上面的属性集的闭包的概念，有了下面的方法

我们对F里的每个函数依赖 a->b 使用下面的算法，如果得到的属性集合c=b，那么说明这个函数依赖是保持了（下面的属性集的闭包的函数依赖集是F）（算法简单来说就是函数依赖在每个限定推出的限定有的属性集，等于没有限定前的依赖推导出来的属性集，那就这个函数依赖保持了）

![image-20221030154828971](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221030154828971.png)

关键就在于对 $t=(result \cap R_i)^+\cap R_i$ 的理解

$(result\cap R_i)^+$是对在$R_i$里的属性集作为函数依赖左部时，所能推导出来的属性集，而$(result\cap R_i)^+\cap R_i$则是对推导出来的属性集，即产生式的右部再限制在$R_i$里面。

破坏函数依赖的关键就在于分解，在于一个函数依赖的属性被分到不同的表里去了。

如果一个函数依赖左部被分到不同的表里，那么这个函数依赖就不能被推导出来，即$(result\cap R_i)^+$都导不出来；如果右部被分到不同的表里，那么$(result\cap R_i)^+ \cap R_i$就会把不同表的部分剔除；如果右部被分到不同表里，但有其他的函数依赖帮这里的函数依赖的缺少的右部填上了，那说明这里的函数依赖本来就是多余的，也不用管

这样我们只要对每个F里的函数依赖的左部进行这个算法，看看算出来的有没有缺就行

## BCNF分解

前面我们说了，如果一个函数依赖不是平凡和超键，那就把对应属性踢出去就好了，但是之前我们所说的超键是建立在F的基础上的，在子表里，F的范围就不够了，所以我们要用F+，对于一个在$R_i$上成立的a->b，如果非平凡，且a->$R_i$不属于F+（不是超键），那我们就把它右部的属性踢出去，左部的属性留下来作为自然连接的标记

下面这个算法默认a->b时，a交b为空，并且result是关系的集合，即集合的集合，而不是属性的集合，所以result-$R_i$是去掉$R_i$这个集合，然后再并上$(R_i-b)$和$(a,b)$这两个集合，就是用$(Ri-b)和(a,b)$代替了$R_i$

![image-20221030174322891](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221030174322891.png)

其实我们完全可以按照之前我们所说的，把result改写成
$$
result:=[(reult-R_i)\cup (R_i-(b-a))]\cup(a\cup b)\\
前半段是一个属性集合，后半段是一个属性集合
$$

## 3NF分解

这个算法很有意思啊，与其叫分解，不如叫合成。先不讨论为什么和怎么来的问题，我们单刀直入地讲怎么做

先求F的正则覆盖$F_c$，然后对于正则覆盖的每一个函数依赖a->b，构造一个子表$R_i=ab$，然后如果刚才构造的子表里全都不包含R的候选键，那我们就挑一个R的候选键c，构建一个子表$R_j=c$，最后我们把被其他子表包含的子表删除，这样就得到分解了。附教材的烂图

![image-20221030213746562](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221030213746562.png)

所以3NF分解并不是自顶向下分解，而是自底向上合并

而且有趣的是，3NF分解的复杂度是多项式级别，而3NF判断却是不太可能用多项式级别的时间来解决的

3NF分解的正确性我不想写了，以后有想法再说吧

## 求所有候选键

这里也别去纠结为什么了，直接上方法

把属性分为四类

- L：属性在F中只出现在函数依赖的左部
- R：属性只出现在右部
- LR：左右部都有出现
- N：左右不都没有出现

其中L，N的属性是一定被包含于候选码的属性集中的，R是不可能被包含于候选码中，LR可能被包含

所以算法如下（其实就是试试LR里有多少个属性是被包含的，一试发现属性闭包齐了，那说明LR里有这么多属性被包含，能齐活属性闭包的属性集就是候选键）
$$
\begin{align}
&(1)记 set1=L\cup N,set2=LR\\
&(2)设i=0\\
&(3)从set2取出i个属性作为集合set3\\
&(4)尝试所有set3的可能，记set4=(set1\cup set3)^+，\\
&\ \ \ \ \ 若set4==R，则此时的set4是候选码。\\
&\ \ \ \ \ 若尝试了所有set3的可能，仍没有一个set4==R，则\\
&\ \ \ \ \ i++,跳回(3)\\
&(5)输出当前得到的所有set4
\end{align}
$$

## 第二范式

为了以防万一，我还是讲一下第二范式的定义吧

在第一范式的基础上，如果所有非主键属性完全依赖于主键，则为第二范式

什么是完全依赖？即主键再少一部分属性，就不能有非主键属性和主键的函数依赖存在了

部分依赖正相反，只要主主键的一部分属性就能完成函数依赖

## 各范式的总结-2023.2.8

### 名词解释

![image-20230208173607324](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20230208173607324.png)

超键：能唯一标识元组的属性集

候选键：缺少其中一个属性就不能标识元组的超键

主键：被用来标识的候选键

主属性/主关键字：候选键中的属性

非主属性/非主关键字：反之

### 第一范式

定义：数据库表中的字段都是单一属性的，不可再分。

简单的说，每一个属性都是原子项，不可分割。

1NF是关系模式应具备的最起码的条件，如果数据库设计不能满足第一范式，就不称为关系型数据库。也就是说，只要是关系型数据库，就一定满足第一范式。

### 第二范式

非主属性完全依赖于主键

2NF相比于1NF可以减少插入异常，删除异常和修改异常。

消除了部分依赖，从而减少异常。可能部分依赖在删除一些主属性时会出现并不影响其他依赖的情况，但由于这些主属性被删除，导致整个元组被删除的情况？

### 第三范式

第二范式的基础上，不存在非主属性对主属性的传递依赖，即为第三范式（注意，候选码中的属性就是主属性）

即一个非主属性a会依赖于非主属性b，b又依赖于主属性c，则a传递依赖于c，那么对b的修改还是删除，都会影响到a，那么就会出现删除更新异常？

![image-20230208173021646](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20230208173021646.png)

举个例子，学生表，学生ID->学院名->学院长名字，那么我们想要增加一个学院和学院长都不行，必须要有一个学生是这个学院的才行，否则学生版iu会出现没有学号，没有主键的元组

问题在哪？学院长依赖于学院名，被依赖者可以成为一个表的主键，依赖者就可以成为这个表的非主属性，一个非主属性依赖于另一个非主属性，那么说明这两个属性可以自己分出去一个表，而因为没有分，所以导致属性的冗余和异常，分完表如下

![image-20230208173037714](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20230208173037714.png)

### BCNF范式

在第三范式的基础上，所有非主属性对任意候选键都是完全函数依赖

这就意味着主键不能包含候选键，否则非主属性就会部分依赖于主属性，违反第二范式

消除了主属性间的传递依赖，在第二范式时，主键中的属性是没有传递依赖的，因为如果有，那么a->b，那么非主键属性就可以部分依赖踢开b的属性。但候选键里的属性，即主属性没有去除传递依赖，所以我们可以用同样的方法，让所有候选键都被完全依赖就好了。候选键之间是相互依赖的，因为一个元组会被候选键唯一标记，所以候选键之间都是一一映射

第三范式只消除了非主属性到主属性的传递依赖，没有消除主属性间的传递依赖，主属性一般认为是放在当前表的，如果弄出去了，就可能会破坏依赖















# 文件管理

## 记录

我们之前说数据库的时候把一行叫做一个元组，现在在文件管理里面叫做一个记录，关系称为文件

记录有各种属性，属性有的定长，有的变长。如果我们变长的属性默认用其最大的长度存储，那么这个记录就叫定长记录，如果就按占有的长度存储，那么就叫变长记录。那我们就来说一下变长记录吧，如下

![image-20221111105125180](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221111105125180.png)

这条记录的前三个属性都是变长属性，然后变长属性的起始地址，占有长度就可以定长地存到变长记录的开头，这样开头就都是定长的了（像是开头第四个属性本来就是定长属性，这个就可以和其他三个变长属性放在开头了），然后三个变长属性的真实存储就可以放到记录后面了，然后中间存的叫空位图，一位表示对应的属性为空值

然后我们说一下变长和定长记录的存储，定长记录直接顺序地存就好了，如下

![image-20221111110229563](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221111110229563.png)

但顺序存储问题多多，插入删除都很麻烦

但我们还是说一下删除后怎么找空闲空间吧。我们把空闲的空间用链表连起来

![image-20221111110413738](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221111110413738.png)

还有要注意，文件是有大小的，文件会有一个文件头记录文件的各种信息，由于有大小，所以一个文件里只能存可以存的记录数，可能会剩下不足一条记录的空间大小

然后我们讲一下变长记录的存储

我们用操作系统的页的概念来存（下面也称页为块），一个页里存若干个变长记录。如下

![image-20221111110829391](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221111110829391.png)

一个页的开头存了记录个数可空闲空间的开头指针，还有各个记录的指针，然后记录的实际数据从后往前填。当然这样还是没有解决插入删除的各种问题。当然分页的好处就是就算一个页内需要排序，移动，代价也小很多了，但这只是我个人的想法，而且这样做久了我感觉各个页之间的记录干涉会越来越严重，最终还是要全局调整

## 记录组织

之前我们说过顺序文件组织了，但很多种组织方法，如堆文件组织，散列文件组织，多表聚簇文件组织

- 堆文件组织：一条记录可以放在文件的任何地方，这样就没有顺序可言了，而且一个关系一个文件
- 散列文件组织：用记录的某个属性来计算哈希，从而得到放到文件的哪个块里，后面的章节讲述

### 顺序文件组织

如果我们假定某个属性为搜索码，然后文件中的记录顺序就按搜索码去排，那我们找起来就相对好找一点。搜索码任何属性都行，不用主属性

然后我们是用链表的形式组织的，

![image-20221111111906645](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221111111906645.png)

这样插入删除就好一点了，如下

![image-20221111111948677](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221111111948677.png)

但这样插入的数据的物理顺序和逻辑顺序就不一致了，即我们并没有复制一个记录到对应位置，只是改了链表指针。而且这条插入的记录并不在这个块（页）中。如果这些溢出块的记录比较少，那么这种方法就会比较好，但如果全乱了，只能靠链表了，那么效率就太鸡巴低了。所以这时候有了重组技术，统一把文件全部按逻辑顺序存到物理顺序里，但这样代价还是太高了

## 多表聚簇文件组织

之前我们不是说一个关系对应一个文件吗？一个文件对应多个块（在数据库里，块好像就是对应硬盘读取的最小单位，也就是说这里的页的大小还和操作系统的页不一样），那么一个块就对应一个关系。但是如果我们把两个关系自然连接，那么每读一条记录，就要读一次块，这属实是有点难以接受。很明显啊，只要我们把两个关系放到一个块里，那么我们读一次块就可以连起来，那这样效率就好很多了

所以多表聚簇文件组织就是一个块里存储两个或多个关系，如果一个关系元组过多，比其他关系都多，那么多的部分就放到临近的块里

在某些查询最为频繁时，谨慎地使用多表聚簇能明显地提高性能

![image-20221111114925491](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221111114925491.png)

## 数据字典存储

我们目前一直在讨论记录，但关系的信息都没讨论过怎么记录

所以我们称管理数据的数据为元数据（metadata），如

- 关系的模式：名字，属性名字，完整性约束，域的长度；
- 或者用户的名字，权限，账户信息；
- 或者哪个关系在哪个块的数据结构；
- 或者索引

然后存储元数据的就称为数据字典或系统目录，所以数据字典的关系模式如下

![image-20221111120737782](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221111120737782.png)

## 数据库缓冲区

在多表聚簇的时候已经说过了，访问磁盘次数太多了，所以我们要搞一个缓冲区

这里的缓冲区就可以理解为操作系统的内存，存放了一定数量的块（操作系统的内存里用页为单位，虽然数据库的块和页是一个东西，但在操作系统的页是磁盘块的2^n倍），所以内存的替换策略都可以用到这里

所以先不写了，回去看吧







# 索引和散列

## 索引

- 顺序索引
  - 聚集索引/主索引，元组的存储时按照搜索码的顺序存储的，所以主索引一般都用主码作为搜索码
  - 非聚集索引/辅助索引，搜索码并没有按照其顺序存储，所以效率会比主索引低
  - 稠密索引，即每个搜索码都有索引项
  - 稀疏索引，即部分搜索码有索引项
  - 稠密索引一查就查到了，那肯定比稀疏索引快，但增删的时候可能就要修改多点，存储空间就多点
  - 由于主索引是按顺序存的，所以主索引可以用稀疏索引，毕竟你要范围查找，我只要地址偏移即可
  - 而辅助索引没有按顺序存，那么辅助索引就必须稠密索引，没法通过地址偏移去实现
  - 当搜索码相同时，我们有两种方法来记录
    - 索引指针指向第一个搜索码的元组的地址，以后增加都往后增加
    - 索引指针指向一个指针桶，指针桶里存了每个元组的指针
  - 多级索引，就像是页表的概念一样，但作用不一样，只是为了索引搜索的更快，而且第一级索引足够小可以放到内存，这样比去硬盘查快多了
- 哈希索引
  - 不能实现范围查找



## B+树

很明显，如果频繁地增删改，普通索引的效率也会下降，所以提出了B+树索引

B+树是平衡树，所以查找到每个记录的次数都会被log，所以次数不会太高。而且B+树的增删改也不会很麻烦，所以目前绝大部分的数据库还是用B+树



# 15章

磁盘的查找的A0~A10

元组数较多的放到外部循环，少的放到内部循环



select的查询一层一层的，如果先用where全部挑出来缓存到磁盘，在拿回来用select，这样太慢了（这种是实体化方式）

所以现在是流水线形式，where挑出一个元组，就马上交给select，这样就快很多了。实际上就是一层挑出一个元组就交给下一层，而不是一层做完后交给下一层







# 16章——查询优化

- 为什么要查询优化
- 查询优化的基础
- 查询优化的方法

所有语言还是上手写过最理解，自己在这里看还是太慢了 

连接顺序就和矩阵连乘问题一样，我们希望尽可能减少计算成本，减少中间结果

我们还需要对每个关系代数的消耗有估计方法

优化方式又分为两种

- 基于成本
- 启发式



选择下移能降低查询规模（就是先挑选后连接）

natural join 好像比from where更高效

尽量不要用嵌入式select，可以转化成表连接

我们使用关系代数进行等价变换来得到消耗较小的等价

各种关系代数等价介绍

投影下移

## 2022.12.17看时笔记

### 语句执行代价

代价评估过于复杂，我们就简单以磁盘传输的时间和搜索块的时间作为评估标准

设传输一个块的耗时为$t_T$，搜索到一次的耗时为$t_S$，则传输b个块，进行S次搜索耗时为$b*t_T+S*t_S$

搜索一次本身也要传输块来对传输来的块进行搜索，所以线性搜索需要对所有的块，即b个块进行传输，然后一次搜索

### 各种搜索的代价

![image-20221217172631809](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221217172631809.png)

![image-20221217172709062](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221217172709062.png)

主索引即文件存储顺序和索引一样，辅助索引即不一样

顺序存储的好处就是你找到开头了，那么后面的就纯纯的传输时间，没有查找时间了。由于查找时间占大头，所以顺序存储在B+树的时候其实能节省非常多时间

注意B+树的每个节点都是放在磁盘块里的，所以每找一个节点，都要花费$t_T+t_S$的时间

码属性即key属性，候选码属性，即属性值唯一，这里即指索引的属性是否唯一，唯一查到一个就行，不唯一就还需要在一定范围遍历

上面这个图的花费有些地方是错的，下面这个是对的

![image-20221217211413217](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221217211413217.png)

![image-20221217211422018](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221217211422018.png)





# 事务管理

## 事务的概念

单位化的操作集合。又可以把操作集合里的操作分为读操作和写操作

事务不仅有单位化问题，也有并发问题

事务还有一致性，即事务执行前后不能违反完整性约束

逻辑读写和物理读写应该就是操作系统内存修改，然后页换出后才正式写入物理块里，然后内存修改后会先放到外存和内存间的缓存，内存写到缓存的过程就是逻辑读写，缓存写入物理块就是物理读写。

为了读写不受影响，我们先提出了独立性，即事务之间是串行执行

由于有缓存的存在，数据库实际上是延迟写的。所以事务就算commit了，实际上还是在缓存而没有放到硬盘，所以事务需要持久性，如果没有放到硬盘而出问题了，那么事务也需要回滚

## 事务的状态

- aborted，因为错误而退出
- committed，提交
- rollback，
- terminated，结束

![image-20221202103238078](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221202103238078.png)

回滚会撤销当前事务的所有修改，恢复到事务发起前的状态

执行过程中途违反完整性也会触发回滚

## 独立性

之前我们说了串行执行都不会有问题，无论执行顺序。但其实这里说到串行执行指的是对一个数据的串行执行，保证这个事务内部可以交织执行？这样就是并发调度，把IO减少。那哪些操作是可以并行执行的，这就叫并发调度

冲突等价，冲突可串行

并发调度存在回滚的问题，即存在不可恢复的调度，一个事务执行完时，另一个未完成的事务发生回滚，那么可能带动另一个事务也回滚，这就叫整体回滚。如果已完成的事务不回滚，那么未完成的事务回滚可能数据就会发生错误，这就叫部分回滚。回去看一下吧



---

## 2022.12.15 事务管理看时笔记

### 事务要点注意看的地方

各种概念，冲突等价，冲突可串行，可恢复调度，无级联调度，

### 事务4大性质

事务要有

- 原子性，要么做完，要么不做
- 一致性，做完后不能破坏数据的完整性约束，不能多，不能少
- 隔离性，事务的并行要看起来跟串行一样，对于每个事务都没有影响
- 持久性，提交了的信息就要保证了保存了，持久化了，就算你系统崩溃了也要保存了

一致性和隔离性在串行的时候都没有什么可说的，但串行的吞吐率太低了，所以我们要搞并行，很多的IO语句就交织着做如下

![image-20221215110911635](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221215110911635.png)

![image-20221215110932429](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221215110932429.png)

### 并行read，write顺序要求seqf

但这样并行很可能会出错，以下的串行时的语句在并行时顺序一旦调换，就很可能出错

- t1.read(a),

  t2.write(a)

- t1.write(a)

  t2.read(a)

- t1.write(a)

  t2.write(a)

所以反过来说，只要不违反上面的顺序，那么语句怎么换都无所谓

在笔记里把这个顺序原则称为seqf

### 冲突等价，冲突可串行

那么我们就可以把一个调度变为另一个调度，这叫做冲突等价，然后如果能转换成串行调度，那么就叫做冲突可串行的

我们想要的就是冲突可串行的调度

所以我们为了判断是否冲突可串行，我们用了优先图/前驱图/precedence graph，只要一个事务t1和另一个事务t2存在seqf关系，则称t1->t2，t1是t2的前驱，t2是t1的后继。然后我们就有了一个拓扑排序图，如果这个如是有环的，那么说明两个事务相互为前驱后继，那么就不存在拓扑排序的序列，也就不是冲突可串行的；相对的，没有环，那我们就能找到一个串行化顺序

### 事务的恢复

然后到事务的恢复。我们总会有回滚的时候，并行的话，一个事务回滚就得带动别的事务回滚了，但更严重的是无法回滚的情况，如下

![image-20221215113537877](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221215113537877.png)

如果T7已经commit了，那么T6回滚的话就无法回滚T7了，所以我们又提出了可恢复调度的概念

- 如果t2 read()了t1 write()的东西，那么称t2依赖于t1
- 如果t2 read()了t1 write()的东西，**但t1先于t2提交**，那么这就是个**可恢复调度**

可恢复调度就是避免了回滚的时候，依赖于自己的事务已经提交的问题，而不是解决了这个问题

但就算是可恢复调度，也只是可恢复，而不是避免了多个并行的事务一起回滚的问题。所以我们又提出了无级联调度的概念

- 如果t2 read()了t1 write()的东西，**但t1.write 后就提交了，**，那么这就是个**无级联调度**

无级联调度在可恢复调度的基础上又加强了限制，相当于说是解耦，从而避免级联回滚

### 事务的隔离级别

加大了限制就降低了并行性，所以我们又提出了不同的限制级别/隔离级别

- 可串行化
- 可重复读，只能读已提交的数据，且该事务读取同一个数据项时，其他事务不能更新该数据。这里就取消了可串行化的要求
- 已提交读，只能读已提交的数据，但不要求两次读同一个数据时，其他事务不能更新该数据并提交
- 未提交读，能够读未提交的数据

注意，以上所有级别都不允许脏写。脏写即一个数据项已经被未提交/终止的事务写入了，又被其他事务write

### 锁

保证隔离性，我们又提出了锁的概念

所以有了共享锁S（类似读）和排他锁（类似写）

同时只要是锁就有可能死锁，所以我们仍旧可以把seqf的拓扑排序用到这里，只要没有环就是不死锁的

### 避免排他锁饥饿

还有就是这个锁是个读写者模型，所以如果读者一直来，那写者就可能饿死了，所以要求共享锁加锁的前提是可以加锁且没有排他锁在等着

### 两阶段封锁协议

然后我们又提出了两阶段封锁协议来约束锁的使用

两阶段封锁协议即每个事务一旦开始释放锁，那么后面只能释放锁不能加锁，由此分为了增长阶段和缩减阶段，两个阶段转折点称为封锁点

两阶段封锁协议只保证了冲突可串行化，并没有保证不死锁

最主要的是封锁点的顺序不变的情况下，很多无关的数据项就可以并发执行

两阶段封锁协议的串行化就是找到封锁点的前驱图，然后按照封锁点的顺序执行每个事务，把每个事务的语句相应地上移下移，从而得到等价的串行

### 严格两阶段封锁协议

但现在还没有解决锁相关的级联回滚的问题（我也不清楚是什么问题），然后提出了严格两阶段封锁协议，即所有排他锁必须在事务提交后才能释放

### 强两阶段封锁协议

这个协议即所有锁只有在提交后才能释放

### 锁转换(lock conversion)

我们还可以把共享锁升级为排他锁，排他锁降级为共享锁，不过锁升级只能发生在增长阶段，锁降级只能发生在缩减阶段

锁转换就是为了加大并行性

### 死锁检测与恢复

数据库一般不适用银行家算法，因为锁太多，代价太大

一般使用死锁检测和恢复，检测到死锁就把某个事务回滚来释放锁

所以我们选择回滚后代价最小的事务去回滚

### 多粒度锁

我们有时候是对整个表进行修改，有时候只是对某几个元组进行修改，有时候甚至对整个数据库进行修改，那么如果我们都用同样大小的锁去锁，那么并行性就几乎没有了

所以我们提出了多粒度锁，我们可以对数据库/表/元组等等加锁，而给大的范围加锁，其范围内的所有节点都会隐式地加锁

![image-20221216095425550](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221216095425550.png)

那我们怎么实现这一点呢？如果我们要访问某个节点，直接从数据库根节点看往下看是否加了锁，比如我要访问某个元组，先看数据库加了锁了吗，再看表加了锁了吗，在看元组加了锁了吗，都没有就可以访问了，这就是隐式加锁

那如果我们要往数据库排他锁，但现在在某个元组也有排他锁，那照这样我们是没法往数据库加锁的。那我们怎么知道能不能加呢？当然我们可以用遍历的方式，但很明显，这样效率太低了。

现在的问题是小范围在大范围没有体现，那我们只要让它在大范围体现就好了。所以提出了意向锁的概念，在小范围加锁，要在其路径上加意向锁，IS表示其范围内有共享锁，IX表示其范围内有排他锁，SIX表示其范围内有共享锁，互斥锁，这样我们要往数据库加锁时，一看有个IS，那么互斥锁就加不上去了，这样就很方便了

![image-20221216100238771](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221216100238771.png)



### 时间戳协议

我们只是想保证隔离性，所以除了锁，我们还可以用时间戳的方式来保证

每个事务都有个时间戳（计数器值），TS(Ti)表示Ti的时间戳，W-timestamp(Q)表示Q数据项的最大的成功执行的write(Q)的事务时间戳，R-timestamp(Q)表示成功执行的read(Q)的事务时间戳

Ti 按如下规则读写

- read(Q)
  - 如果 TS(Ti)<W-timestamp(Q)，说明此时的read(Q)已经被别的事务覆盖了，可能会不一致，那么就拒绝read，Ti回滚
  - 如果 TS(Ti)>=W-timestamp(Q)，说明read(Q)的值还在，可以执行，并将R-timestamp(Q)设置为MAX{R-timestamp(Q), TS(Ti)}
- write(Q)
  - 如果 TS(Ti)<R-timestamp(Q)，说明有事务读了，那不可以再写，回滚
  - 如果 TS(Ti)<W-timestamp(Q)，说明有事务写了，那不可以再写，回滚
  - 否则，write()的同时，将W-timestamp(Q)设置为TS(Ti) （这里不用选最大值是因为读是有多个的，有最大，而写只有一个，所以它就是最大）

时间戳协议就是基于回滚的协议，解决问题的方法就是回滚，并不会等待或怎么样，所以时间戳协议是冲突可串行化的（按时间戳排），也是不会有死锁的

但有可能因为长事务一直和别的事务冲突回滚，导致长事务饥饿。解决的方法就是如果发现有事务一直回滚，那么和它冲突的事务应暂时阻塞

但还是没解决不可恢复调度问题，但可以通过以下方法解决（不想写了，贴图）

![image-20221216081337999](%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9C%8B%E6%97%B6%E7%AC%94%E8%AE%B0.assets/image-20221216081337999.png)

### 多版本时间戳协议

Ti每写一次，就增加一个版本Qk和对应的TS(Ti)的W-timestamp时间戳；每个版本Qk都有一个R-timestamp，记录了访问该版本的最大的时间戳

然后按照如下规则执行

- Qk是其写时间戳小于TS(Ti)，最大的写时间戳的版本（其实就是从堆顶开始往下找，找到哪个是哪个）

- 如果Ti.read(Q)，返回Qk的内容

- 如果Ti.write(Q)

  ```c
  if(TS(Ti)<R-timestamp(Qk))
  	回滚();
  else{
      if(TS(Ti)==W-timestamp(Qk))
          覆盖Qk();
      else
          创建新版本();
  }
  ```

  

从这里我们可以看出，多版本时间戳的读不会被阻塞或失败，当然可能得到的数据是老版本，不过我们已经对write()进行了限制，所以不用担心数据不一致的问题，因为如果读的是老版本而去写，那么根本写不了

多版本时间戳协议主要用于高铁查询这种，你查的时候是一个版本，刷新后就是另一个版本了

其实说这么多，时间戳就是基于读写互斥，写写互斥，如果读的时候有事务写了，那就回滚，写的时候有事务读了/写了，那就回滚，仅此而已













 
